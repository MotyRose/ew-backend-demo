---
".codecov-prep":
  variables:
    COVERAGE_TYPE: ut
    FB_COMPONENT_TYPE: service
    FB_COMPONENT_MAIN_LANG: typescript
    COVERAGE_FILES_PATH: coverage/
    SERVICE_SCOPE: shell
  stage: test
  script:
  - "if [ \"$SKIP_CODE_COVERAGE\" == \"true\" ]; then\n  echo \"Skipping coverage
    upload to codecov - due to SKIP_CODE_COVERAGE: ${SKIP_COVERAGE_FLAG} flag\"\nelse\n
    \ apk add jq\n  curl -Os https://cli.codecov.io/v0.4.8/alpine/codecov || /bin/true
    \n  chmod +x codecov || /bin/true \n  echo \"Preparing to upload coverage to codecov\"\n
    \ SLUG=$(echo \"${CI_PROJECT_PATH%/*}\" | sed 's|/|:|g')\n  CONFIG_RES=$(curl
    \"https://api.codecov.io/api/v2/gitlab/${SLUG}/repos/${SERVICE_NAME}/config/\"
    --header \"Authorization: bearer ${CODECOV_API_TOKEN}\")\n  UPLOAD_TOKEN=$(jq
    -r '.upload_token' <<< $CONFIG_RES)\n  if [ -z \"${COVERAGE_SPECIFIC_FILES_PATH}\"
    ]; then\n    ./codecov --verbose upload-process -t \"${UPLOAD_TOKEN}\" -f \"${COVERAGE_SPECIFIC_FILES_PATH}\"
    -F \"${COVERAGE_TYPE}\" -F \"${FB_COMPONENT_TYPE}\" -F \"${FB_COMPONENT_MAIN_LANG}\"
    || /bin/true\n  else\n    ./codecov --verbose upload-process -t \"${UPLOAD_TOKEN}\"
    -s \"${COVERAGE_FILES_PATH}\" -F \"${COVERAGE_TYPE}\" -F \"${FB_COMPONENT_TYPE}\"
    -F \"${FB_COMPONENT_MAIN_LANG}\" || /bin/true\n  fi\n  echo \"Done upload coverage
    to codecov\"\nfi"
".cleanup-echos":
  before_script:
  - start_time=$(date +%s)
  - echo "export start_time=${start_time}" >> .variables
  - echo "Docker cleanup job started running"
  after_script:
  - source .variables
  - echo "Docker cleanup job finished running. took $(expr $(date +%s) - $start_time)s"
  - rm .variables
".cleanup-job":
  before_script:
  - start_time=$(date +%s)
  - echo "export start_time=${start_time}" >> .variables
  - echo "Docker cleanup job started running"
  after_script:
  - source .variables
  - echo "Docker cleanup job finished running. took $(expr $(date +%s) - $start_time)s"
  - rm .variables
  retry: 2
  extends: ".cleanup-echos"
  stage: provision
  when: manual
  script:
  - docker images -q | xargs docker rmi -f || true
  - docker volume rm $(docker volume ls -qf dangling=true) || true
".cleanup-job:rb-runners:common":
  script:
  - touch .npmrc
  - echo "@fireblocks:registry=https://gitlab.com/api/v4/packages/npm/">>.npmrc
  - echo "//gitlab.com/api/v4/packages/npm/:_authToken=${NPM_REG_READ_TOKEN}">>.npmrc
  - echo "//gitlab.com/api/v4/projects/20565764/packages/npm/:_authToken=${NPM_REG_READ_TOKEN}">>.npmrc
  - docker login -u gitlab-ci-token -p $CI_JOB_TOKEN $CI_REGISTRY
  - cd /cache/build/remoteblocks || /bin/true && ./stop.sh --purge || /bin/true
  - docker image prune -f
  - docker images --format "{{.ID}} {{.Repository}}:{{.Tag}}" | grep "/fireblocks/\|e2e_.*"
    | grep -vE ':main|:latest|/remoteblocks/|/data-service:duplicate-master' | awk
    '{print $1}' | xargs -r -P 10 docker rmi -f || true
  - docker volume rm $(docker volume ls -qf dangling=true) || true
".cleanup-job:rb-runners:v1":
  before_script:
  - start_time=$(date +%s)
  - echo "export start_time=${start_time}" >> .variables
  - echo "Docker cleanup job started running"
  after_script:
  - source .variables
  - echo "Docker cleanup job finished running. took $(expr $(date +%s) - $start_time)s"
  - rm .variables
  image: registry.gitlab.com/fireblocks/build-docker/node:14.19.0
  variables:
    MODE: local
  retry: 2
  extends: ".cleanup-echos"
  stage: provision
  when: manual
  script:
  - apk add docker docker-compose jq bash yq
  - - touch .npmrc
    - echo "@fireblocks:registry=https://gitlab.com/api/v4/packages/npm/">>.npmrc
    - echo "//gitlab.com/api/v4/packages/npm/:_authToken=${NPM_REG_READ_TOKEN}">>.npmrc
    - echo "//gitlab.com/api/v4/projects/20565764/packages/npm/:_authToken=${NPM_REG_READ_TOKEN}">>.npmrc
    - docker login -u gitlab-ci-token -p $CI_JOB_TOKEN $CI_REGISTRY
    - cd /cache/build/remoteblocks || /bin/true && ./stop.sh --purge || /bin/true
    - docker image prune -f
    - docker images --format "{{.ID}} {{.Repository}}:{{.Tag}}" | grep "/fireblocks/\|e2e_.*"
      | grep -vE ':main|:latest|/remoteblocks/|/data-service:duplicate-master' | awk
      '{print $1}' | xargs -r -P 10 docker rmi -f || true
    - docker volume rm $(docker volume ls -qf dangling=true) || true
  - cd /cache/build/remoteblocks
  - "./init.sh"
  - "./start.sh || /bin/true"
  - "./stop.sh --purge"
".cleanup-job:rb-runners:v2":
  before_script:
  - start_time=$(date +%s)
  - echo "export start_time=${start_time}" >> .variables
  - echo "Docker cleanup job started running"
  after_script:
  - source .variables
  - echo "Docker cleanup job finished running. took $(expr $(date +%s) - $start_time)s"
  - rm .variables
  image: registry.gitlab.com/fireblocks/build-docker/node:14.19.0
  variables:
    MODE: local
  retry: 2
  extends: ".cleanup-echos"
  stage: provision
  when: manual
  script:
  - - touch .npmrc
    - echo "@fireblocks:registry=https://gitlab.com/api/v4/packages/npm/">>.npmrc
    - echo "//gitlab.com/api/v4/packages/npm/:_authToken=${NPM_REG_READ_TOKEN}">>.npmrc
    - echo "//gitlab.com/api/v4/projects/20565764/packages/npm/:_authToken=${NPM_REG_READ_TOKEN}">>.npmrc
    - docker login -u gitlab-ci-token -p $CI_JOB_TOKEN $CI_REGISTRY
    - cd /cache/build/remoteblocks || /bin/true && ./stop.sh --purge || /bin/true
    - docker image prune -f
    - docker images --format "{{.ID}} {{.Repository}}:{{.Tag}}" | grep "/fireblocks/\|e2e_.*"
      | grep -vE ':main|:latest|/remoteblocks/|/data-service:duplicate-master' | awk
      '{print $1}' | xargs -r -P 10 docker rmi -f || true
    - docker volume rm $(docker volume ls -qf dangling=true) || true
".create-and-fill-npmrc":
  script:
  - touch .npmrc
  - npm config set --location=user @fireblocks:registry https://gitlab.com/api/v4/packages/npm/
  - npm config set --location=user '//gitlab.com/api/v4/packages/npm/:_authToken'
    "${NPM_REG_TOKEN}"
  - npm config set --location=user '//gitlab.com/api/v4/projects/20565764/packages/npm/:_authToken'
    "${NPM_REG_TOKEN}"
  - echo "@fireblocks:registry=https://gitlab.com/api/v4/packages/npm/">>.npmrc
  - echo "//gitlab.com/api/v4/packages/npm/:_authToken=${NPM_REG_TOKEN}">>.npmrc
  - echo "//gitlab.com/api/v4/projects/20565764/packages/npm/:_authToken=${NPM_REG_TOKEN}">>.npmrc
  - yarn global add @fireblocks/fb-cli dot-json
".monitor-timings":
  start:
  - echo -e "\033[1;36mStep $stepName started at $(date)\033[0m"
  - startTime=$(date +%s)
  - sleep 1
  end:
  - duration="$(expr $(date +%s) - "$startTime")s"
  - echo "$stepName $duration" >> $CI_PROJECT_DIR/metrics.txt
  - echo -e "\033[1;36mStep $stepName finished at $(date) and took $duration\033[0m"
".setup-remoteblocks":
  image: registry.gitlab.com/fireblocks/shell/infra/images/node-infra-18:18.19-alpine3.19-fb1.4
  artifacts:
    name: "${CI_JOB_NAME}_${CI_COMMIT_REF_NAME}"
    paths:
    - report
    expire_in: 1 week
    when: always
    reports:
      metrics: metrics.txt
  variables:
    MODE: local
    GITLAB_TOKEN: "$CI_JOB_TOKEN"
    BUILD_ROOT: "/cache/build"
    GI_VOLUMES_FOLDER: "/cache/rb_it_goldenimage"
    KUBECONFIG: "/root/.kube/config"
    ENABLE_CROSSPLANE: 'false'
    NOTIFY_ALREADY_EXISTS_RESOURCES: 'true'
    DEVTOOLS_NOTIFICATIONS_CHANNEL: C07AVQ0Q2G6
    SERVICES_LOGS_FOLDER: services_logs
    COVERAGE_DOCKER_SIGTERM_TIMEOUT: "$DEFAULT_COVERAGE_DOCKER_SIGTERM_TIMEOUT"
    COVERAGE_DOCKER_SIGTERM_SLEEP: "$DEFAULT_COVERAGE_DOCKER_SIGTERM_SLEEP"
    FB_COMPONENT_TYPE: service
    FB_COMPONENT_MAIN_LANG: typescript
    COVERAGE_SPECIFIC_FILES_PATH: "$CI_PROJECT_DIR/report/coverage/cobertura-coverage.xml"
  before_script:
  - ls -la $CI_PROJECT_DIR/
  - apk add yq sudo openssl kubectl helm
  - ln -s /root /home/ubuntu
  - - touch .npmrc
    - npm config set --location=user @fireblocks:registry https://gitlab.com/api/v4/packages/npm/
    - npm config set --location=user '//gitlab.com/api/v4/packages/npm/:_authToken'
      "${NPM_REG_TOKEN}"
    - npm config set --location=user '//gitlab.com/api/v4/projects/20565764/packages/npm/:_authToken'
      "${NPM_REG_TOKEN}"
    - echo "@fireblocks:registry=https://gitlab.com/api/v4/packages/npm/">>.npmrc
    - echo "//gitlab.com/api/v4/packages/npm/:_authToken=${NPM_REG_TOKEN}">>.npmrc
    - echo "//gitlab.com/api/v4/projects/20565764/packages/npm/:_authToken=${NPM_REG_TOKEN}">>.npmrc
    - yarn global add @fireblocks/fb-cli dot-json
  - docker login -u gitlab-ci-token -p $CI_JOB_TOKEN $CI_REGISTRY
  - stepName="Init_Docker_Network"
  - - echo -e "\033[1;36mStep $stepName started at $(date)\033[0m"
    - startTime=$(date +%s)
    - sleep 1
  - docker network create -d bridge core_integration || /bin/true
  - CURR_CONTAINER_ID=$(docker ps | grep "$HOSTNAME" | awk '{print $1}')
  - docker network connect core_integration $CURR_CONTAINER_ID
  - docker network connect minikube $CURR_CONTAINER_ID || /bin/true
  - mkdir -p $BUILD_ROOT && cd $BUILD_ROOT
  - sleep 1
  - - duration="$(expr $(date +%s) - "$startTime")s"
    - echo "$stepName $duration" >> $CI_PROJECT_DIR/metrics.txt
    - echo -e "\033[1;36mStep $stepName finished at $(date) and took $duration\033[0m"
  - stepName="Cleanup_K8s_Resources"
  - - echo -e "\033[1;36mStep $stepName started at $(date)\033[0m"
    - startTime=$(date +%s)
    - sleep 1
  - kubectl get -n services-resources managed -o name | xargs -r -I % -P 20 kubectl
    patch % -p '{"metadata":{"finalizers":[]}}' --type=merge &>/dev/null || /bin/true
  - kubectl get -n services-resources claim -o name | xargs -r -I % -P 20 kubectl
    patch -n services-resources % -p '{"metadata":{"finalizers":[]}}' --type=merge
    &>/dev/null || /bin/true
  - helm ls --all --short -n services-resources | xargs -r -P 20 helm delete -n services-resources
    &>/dev/null || /bin/true
  - kubectl get -n services-resources managed -o name | xargs -r -P 20 kubectl delete
    -n services-resources &>/dev/null || /bin/true &
  - kubectl get -n services-resources claim -o name | xargs -r -P 20 kubectl delete
    -n services-resources &>/dev/null || /bin/true &
  - |
    if [ "$RB_CLEAN_CROSSPLANE" == "true" ]; then
      kubectl delete all --all -n default --ignore-not-found=true --grace-period=0 --force || /bin/true
      kubectl delete all --all -n crossplane-system --ignore-not-found=true --grace-period=0 --force || /bin/true
      kubectl get crds 2>/dev/null | grep -qE "crossplane.io|fireblocks|upbound" | awk '{print $1}' | xargs -r -P 10 kubectl delete crd || /bin/true
    fi
  - - duration="$(expr $(date +%s) - "$startTime")s"
    - echo "$stepName $duration" >> $CI_PROJECT_DIR/metrics.txt
    - echo -e "\033[1;36mStep $stepName finished at $(date) and took $duration\033[0m"
  - stepName="Cleanup_RB_Runners_Before"
  - - echo -e "\033[1;36mStep $stepName started at $(date)\033[0m"
    - startTime=$(date +%s)
    - sleep 1
  - - - touch .npmrc
      - echo "@fireblocks:registry=https://gitlab.com/api/v4/packages/npm/">>.npmrc
      - echo "//gitlab.com/api/v4/packages/npm/:_authToken=${NPM_REG_READ_TOKEN}">>.npmrc
      - echo "//gitlab.com/api/v4/projects/20565764/packages/npm/:_authToken=${NPM_REG_READ_TOKEN}">>.npmrc
      - docker login -u gitlab-ci-token -p $CI_JOB_TOKEN $CI_REGISTRY
      - cd /cache/build/remoteblocks || /bin/true && ./stop.sh --purge || /bin/true
      - docker image prune -f
      - docker images --format "{{.ID}} {{.Repository}}:{{.Tag}}" | grep "/fireblocks/\|e2e_.*"
        | grep -vE ':main|:latest|/remoteblocks/|/data-service:duplicate-master' |
        awk '{print $1}' | xargs -r -P 10 docker rmi -f || true
      - docker volume rm $(docker volume ls -qf dangling=true) || true
  - - duration="$(expr $(date +%s) - "$startTime")s"
    - echo "$stepName $duration" >> $CI_PROJECT_DIR/metrics.txt
    - echo -e "\033[1;36mStep $stepName finished at $(date) and took $duration\033[0m"
  - intTestsBranch="${INTEGRATION_TESTS_BRANCH:-master}"
  - cd $BUILD_ROOT
  - echo "Cloning Integration tests $intTestsBranch branch"
  - rm -fr integration-tests && git clone --depth 1 --recurse-submodules --shallow-submodules
    -b $intTestsBranch https://gitlab-ci-token:${CI_JOB_TOKEN}@gitlab.com/fireblocks/shell/infra/integration-tests
  - - touch .npmrc
    - npm config set --location=user @fireblocks:registry https://gitlab.com/api/v4/packages/npm/
    - npm config set --location=user '//gitlab.com/api/v4/packages/npm/:_authToken'
      "${NPM_REG_TOKEN}"
    - npm config set --location=user '//gitlab.com/api/v4/projects/20565764/packages/npm/:_authToken'
      "${NPM_REG_TOKEN}"
    - echo "@fireblocks:registry=https://gitlab.com/api/v4/packages/npm/">>.npmrc
    - echo "//gitlab.com/api/v4/packages/npm/:_authToken=${NPM_REG_TOKEN}">>.npmrc
    - echo "//gitlab.com/api/v4/projects/20565764/packages/npm/:_authToken=${NPM_REG_TOKEN}">>.npmrc
    - yarn global add @fireblocks/fb-cli dot-json
  - cd $BUILD_ROOT
  - rbBranch="${REMOTEBLOCKS_BRANCH:-main}"
  - echo "Cloning Remoteblocks's $rbBranch branch"
  - rm -fr remoteblocks && git clone --depth 1 --recurse-submodules --shallow-submodules
    -b $rbBranch https://gitlab-ci-token:${CI_JOB_TOKEN}@gitlab.com/fireblocks/shell/infra/tools/remoteblocks
  - |
    if [ "$RUN_ALL_MASTERS" != "true" ]; then
      cd $BUILD_ROOT/remoteblocks
      echo ${SERVICE_NAME}
      echo ${IMAGE_TAG}
      ./update_commit_by_repo.sh ${SERVICE_NAME} ${IMAGE_TAG}
    fi
  - stepName="Building_branch"
  - - echo -e "\033[1;36mStep $stepName started at $(date)\033[0m"
    - startTime=$(date +%s)
    - sleep 1
  - excludeFlag=""
  - |
    if [ "$IMAGE_ALREADY_BUILT" == "true" ]; then
      echo "$SERVICE_NAME was already built in other job"
      SKIP_CODE_COVERAGE=$(echo "true") # Skipping code coverage instrumentation check because we didn't compile image
    elif [ "$RUN_ALL_MASTERS" != "true" ]; then
      echo "Running ${SERVICE_NAME} on image tag: ${IMAGE_TAG}. Rest of the services will run on master"
      cd $CI_PROJECT_DIR/
      if [ "$SERVICE_NAME" == "console-app-v2" ]; then
        cp packages/platform/env/.env.localstack packages/platform/env/.env
        docker build --build-arg DELMAPS=${DELMAPS} --build-arg CI_COMMIT_SHORT_SHA=${CI_COMMIT_SHORT_SHA} -t ${IMAGE_PATH}:${IMAGE_TAG} -f Dockerfile.localstack .
      else
        /bin/bash -c $BUILD_ROOT/remoteblocks/coverage-config/coverage-setup.sh || /bin/true
        docker build -t ${IMAGE_PATH}:${IMAGE_TAG} .
      fi
      excludeFlag="--exclude $CI_PROJECT_NAME"
    else
      SKIP_CODE_COVERAGE=$(echo "true") # Skipping code coverage instrumentation check because we didn't compile image
      echo "Finished modifying running all Remoteblocks services on master"
    fi
  - sleep 1
  - - duration="$(expr $(date +%s) - "$startTime")s"
    - echo "$stepName $duration" >> $CI_PROJECT_DIR/metrics.txt
    - echo -e "\033[1;36mStep $stepName finished at $(date) and took $duration\033[0m"
  - stepName="Golden_image_download_and_extract"
  - - echo -e "\033[1;36mStep $stepName started at $(date)\033[0m"
    - startTime=$(date +%s)
    - sleep 1
  - cd $BUILD_ROOT/remoteblocks/remote/docker-volume-tool
  - mkdir -p docker-volumes && cd docker-volumes
  - |
    if [ -z "$GOLDEN_IMAGE_VERSION" ]; then
      GOLDEN_IMAGE_VERSION=$(curl --header "JOB-TOKEN:$CI_JOB_TOKEN" "$CI_API_V4_URL/projects/35096363/packages?sort=desc" | jq 'map(select(.name == "golden_image")) | sort_by(.version) | .[].version' | tail -1 | tr -d '"')
    fi
  - echo "Using latest golden image version:$GOLDEN_IMAGE_VERSION"
  - 'wget --header="JOB-TOKEN: $CI_JOB_TOKEN" ${CI_API_V4_URL}/projects/35096363/packages/generic/golden_image/${GOLDEN_IMAGE_VERSION}/rb_golden_image.tar.gz'
  - rm -rf $GI_VOLUMES_FOLDER || true
  - mkdir -p $GI_VOLUMES_FOLDER && tar -xzf rb_golden_image.tar.gz -C $GI_VOLUMES_FOLDER
    --strip-components=1 && find $GI_VOLUMES_FOLDER -type f -name '._*' -delete
  - - duration="$(expr $(date +%s) - "$startTime")s"
    - echo "$stepName $duration" >> $CI_PROJECT_DIR/metrics.txt
    - echo -e "\033[1;36mStep $stepName finished at $(date) and took $duration\033[0m"
  - stepName="Golden_image_population"
  - - echo -e "\033[1;36mStep $stepName started at $(date)\033[0m"
    - startTime=$(date +%s)
    - sleep 1
  - cd $BUILD_ROOT/remoteblocks
  - "./volume-tool.sh --import $GI_VOLUMES_FOLDER"
  - - duration="$(expr $(date +%s) - "$startTime")s"
    - echo "$stepName $duration" >> $CI_PROJECT_DIR/metrics.txt
    - echo -e "\033[1;36mStep $stepName finished at $(date) and took $duration\033[0m"
  - stepName="Pulling_images-init.sh"
  - - echo -e "\033[1;36mStep $stepName started at $(date)\033[0m"
    - startTime=$(date +%s)
    - sleep 1
  - cd $BUILD_ROOT/remoteblocks
  - "./init.sh $excludeFlag"
  - - duration="$(expr $(date +%s) - "$startTime")s"
    - echo "$stepName $duration" >> $CI_PROJECT_DIR/metrics.txt
    - echo -e "\033[1;36mStep $stepName finished at $(date) and took $duration\033[0m"
  - cd $BUILD_ROOT/remoteblocks
  - "./volume-tool.sh --edit-docker-compose $CI_JOB_ID $SERVICE_NAME"
  - stepName="Starting_remoteblocks-start.sh"
  - - echo -e "\033[1;36mStep $stepName started at $(date)\033[0m"
    - startTime=$(date +%s)
    - sleep 1
  - cd $BUILD_ROOT/remoteblocks
  - "./start.sh $excludeFlag --skip-provisioning"
  - cd $BUILD_ROOT/remoteblocks/remote
  - bash service-checker.sh
  - - duration="$(expr $(date +%s) - "$startTime")s"
    - echo "$stepName $duration" >> $CI_PROJECT_DIR/metrics.txt
    - echo -e "\033[1;36mStep $stepName finished at $(date) and took $duration\033[0m"
  after_script:
  - rm -rf $CI_PROJECT_DIR/report
  - COVERAGE_METRIC_NAME="remoteblocks_it_coverage"
  - COVERAGE_TYPE="it"
  - "if [ \"$PIPELINE_SOURCE\" == \"e2e-tests\" ]; then\n  cd $BUILD_ROOT/e2e\n  echo
    \"Uploading e2e-tests artifacts\"\n  COVERAGE_METRIC_NAME=\"remoteblocks_e2e_coverage\"\n
    \ COVERAGE_TYPE=\"e2e\"\n  docker cp $E2E_CONTAINER_NAME:e2e/results $CI_PROJECT_DIR/report
    || /bin/true\n  docker cp $E2E_CONTAINER_NAME:e2e/test-config.json $CI_PROJECT_DIR
    || /bin/true\n  echo \"Stopping $E2E_CONTAINER_NAME container\"\n  docker-compose
    -p $E2E_CONTAINER_NAME down -v --remove-orphans\t--rmi local || /bin/true\nfi\n"
  - |
    if [ "$PIPELINE_SOURCE" == "integration-tests" ]; then
      echo "Uploading integration-tests artifacts"
      cd $BUILD_ROOT/integration-tests
      cp -r output $CI_PROJECT_DIR/report
    fi
  - stepName="Uploading_services_logs"
  - - echo -e "\033[1;36mStep $stepName started at $(date)\033[0m"
    - startTime=$(date +%s)
    - sleep 1
  - cd $BUILD_ROOT/remoteblocks
  - "./coverage-config/coverage-collect.sh || /bin/true"
  - "./volume-tool.sh --export-logs $SERVICES_LOGS_FOLDER"
  - cd remote/docker-volume-tool
  - cp -r $SERVICES_LOGS_FOLDER $CI_PROJECT_DIR/report
  - - duration="$(expr $(date +%s) - "$startTime")s"
    - echo "$stepName $duration" >> $CI_PROJECT_DIR/metrics.txt
    - echo -e "\033[1;36mStep $stepName finished at $(date) and took $duration\033[0m"
  - stepName="Final_containers_stopping-stop.sh"
  - - echo -e "\033[1;36mStep $stepName started at $(date)\033[0m"
    - startTime=$(date +%s)
    - sleep 1
  - cd $BUILD_ROOT/remoteblocks
  - "./stop.sh --kill || /bin/true"
  - - duration="$(expr $(date +%s) - "$startTime")s"
    - echo "$stepName $duration" >> $CI_PROJECT_DIR/metrics.txt
    - echo -e "\033[1;36mStep $stepName finished at $(date) and took $duration\033[0m"
  - cp $CI_PROJECT_DIR/metrics.txt $CI_PROJECT_DIR/report || /bin/true
  - if [ "$RUN_ALL_MASTERS" != "true" ] && [ "$IMAGE_ALREADY_BUILT" != "true" ]; then
    docker rmi -f ${IMAGE_PATH}:${IMAGE_TAG} || /bin/true; fi
  - echo -e "\033[38;5;39mReport can be found here- $CI_PROJECT_URL/-/jobs/$CI_JOB_ID/artifacts/browse/report/\033[0m"
  - stepName="Cleanup_RB_Runners_After"
  - - echo -e "\033[1;36mStep $stepName started at $(date)\033[0m"
    - startTime=$(date +%s)
    - sleep 1
  - - - touch .npmrc
      - echo "@fireblocks:registry=https://gitlab.com/api/v4/packages/npm/">>.npmrc
      - echo "//gitlab.com/api/v4/packages/npm/:_authToken=${NPM_REG_READ_TOKEN}">>.npmrc
      - echo "//gitlab.com/api/v4/projects/20565764/packages/npm/:_authToken=${NPM_REG_READ_TOKEN}">>.npmrc
      - docker login -u gitlab-ci-token -p $CI_JOB_TOKEN $CI_REGISTRY
      - cd /cache/build/remoteblocks || /bin/true && ./stop.sh --purge || /bin/true
      - docker image prune -f
      - docker images --format "{{.ID}} {{.Repository}}:{{.Tag}}" | grep "/fireblocks/\|e2e_.*"
        | grep -vE ':main|:latest|/remoteblocks/|/data-service:duplicate-master' |
        awk '{print $1}' | xargs -r -P 10 docker rmi -f || true
      - docker volume rm $(docker volume ls -qf dangling=true) || true
  - - duration="$(expr $(date +%s) - "$startTime")s"
    - echo "$stepName $duration" >> $CI_PROJECT_DIR/metrics.txt
    - echo -e "\033[1;36mStep $stepName finished at $(date) and took $duration\033[0m"
".rb_changes_anchor":
- configurations/**/localstack/**/*
- deployment/**/localstack/**/*
- src/**/*
- package.json
- Dockerfile
- hooks/**/*
- packages/**/*
- Dockerfile.localstack
remoteblocks:integration-tests:
  image: registry.gitlab.com/fireblocks/shell/infra/images/node-infra-18:18.19-alpine3.19-fb1.4
  artifacts:
    name: "${CI_JOB_NAME}_${CI_COMMIT_REF_NAME}"
    paths:
    - report
    expire_in: 1 week
    when: always
    reports:
      metrics:
      - metrics.txt
  variables:
    MODE: local
    GITLAB_TOKEN: "$CI_JOB_TOKEN"
    BUILD_ROOT: "/cache/build"
    GI_VOLUMES_FOLDER: "/cache/rb_it_goldenimage"
    KUBECONFIG: "/root/.kube/config"
    ENABLE_CROSSPLANE: 'false'
    NOTIFY_ALREADY_EXISTS_RESOURCES: 'true'
    DEVTOOLS_NOTIFICATIONS_CHANNEL: C07AVQ0Q2G6
    SERVICES_LOGS_FOLDER: services_logs
    COVERAGE_DOCKER_SIGTERM_TIMEOUT: "$DEFAULT_COVERAGE_DOCKER_SIGTERM_TIMEOUT"
    COVERAGE_DOCKER_SIGTERM_SLEEP: "$DEFAULT_COVERAGE_DOCKER_SIGTERM_SLEEP"
    FB_COMPONENT_TYPE: service
    FB_COMPONENT_MAIN_LANG: typescript
    COVERAGE_SPECIFIC_FILES_PATH: "$CI_PROJECT_DIR/report/coverage/cobertura-coverage.xml"
    ENVIRONMENT: localstack
    PIPELINE_SOURCE: integration-tests
  before_script:
  - ls -la $CI_PROJECT_DIR/
  - apk add yq sudo openssl kubectl helm
  - ln -s /root /home/ubuntu
  - - touch .npmrc
    - npm config set --location=user @fireblocks:registry https://gitlab.com/api/v4/packages/npm/
    - npm config set --location=user '//gitlab.com/api/v4/packages/npm/:_authToken'
      "${NPM_REG_TOKEN}"
    - npm config set --location=user '//gitlab.com/api/v4/projects/20565764/packages/npm/:_authToken'
      "${NPM_REG_TOKEN}"
    - echo "@fireblocks:registry=https://gitlab.com/api/v4/packages/npm/">>.npmrc
    - echo "//gitlab.com/api/v4/packages/npm/:_authToken=${NPM_REG_TOKEN}">>.npmrc
    - echo "//gitlab.com/api/v4/projects/20565764/packages/npm/:_authToken=${NPM_REG_TOKEN}">>.npmrc
    - yarn global add @fireblocks/fb-cli dot-json
  - docker login -u gitlab-ci-token -p $CI_JOB_TOKEN $CI_REGISTRY
  - stepName="Init_Docker_Network"
  - - echo -e "\033[1;36mStep $stepName started at $(date)\033[0m"
    - startTime=$(date +%s)
    - sleep 1
  - docker network create -d bridge core_integration || /bin/true
  - CURR_CONTAINER_ID=$(docker ps | grep "$HOSTNAME" | awk '{print $1}')
  - docker network connect core_integration $CURR_CONTAINER_ID
  - docker network connect minikube $CURR_CONTAINER_ID || /bin/true
  - mkdir -p $BUILD_ROOT && cd $BUILD_ROOT
  - sleep 1
  - - duration="$(expr $(date +%s) - "$startTime")s"
    - echo "$stepName $duration" >> $CI_PROJECT_DIR/metrics.txt
    - echo -e "\033[1;36mStep $stepName finished at $(date) and took $duration\033[0m"
  - stepName="Cleanup_K8s_Resources"
  - - echo -e "\033[1;36mStep $stepName started at $(date)\033[0m"
    - startTime=$(date +%s)
    - sleep 1
  - kubectl get -n services-resources managed -o name | xargs -r -I % -P 20 kubectl
    patch % -p '{"metadata":{"finalizers":[]}}' --type=merge &>/dev/null || /bin/true
  - kubectl get -n services-resources claim -o name | xargs -r -I % -P 20 kubectl
    patch -n services-resources % -p '{"metadata":{"finalizers":[]}}' --type=merge
    &>/dev/null || /bin/true
  - helm ls --all --short -n services-resources | xargs -r -P 20 helm delete -n services-resources
    &>/dev/null || /bin/true
  - kubectl get -n services-resources managed -o name | xargs -r -P 20 kubectl delete
    -n services-resources &>/dev/null || /bin/true &
  - kubectl get -n services-resources claim -o name | xargs -r -P 20 kubectl delete
    -n services-resources &>/dev/null || /bin/true &
  - |
    if [ "$RB_CLEAN_CROSSPLANE" == "true" ]; then
      kubectl delete all --all -n default --ignore-not-found=true --grace-period=0 --force || /bin/true
      kubectl delete all --all -n crossplane-system --ignore-not-found=true --grace-period=0 --force || /bin/true
      kubectl get crds 2>/dev/null | grep -qE "crossplane.io|fireblocks|upbound" | awk '{print $1}' | xargs -r -P 10 kubectl delete crd || /bin/true
    fi
  - - duration="$(expr $(date +%s) - "$startTime")s"
    - echo "$stepName $duration" >> $CI_PROJECT_DIR/metrics.txt
    - echo -e "\033[1;36mStep $stepName finished at $(date) and took $duration\033[0m"
  - stepName="Cleanup_RB_Runners_Before"
  - - echo -e "\033[1;36mStep $stepName started at $(date)\033[0m"
    - startTime=$(date +%s)
    - sleep 1
  - - - touch .npmrc
      - echo "@fireblocks:registry=https://gitlab.com/api/v4/packages/npm/">>.npmrc
      - echo "//gitlab.com/api/v4/packages/npm/:_authToken=${NPM_REG_READ_TOKEN}">>.npmrc
      - echo "//gitlab.com/api/v4/projects/20565764/packages/npm/:_authToken=${NPM_REG_READ_TOKEN}">>.npmrc
      - docker login -u gitlab-ci-token -p $CI_JOB_TOKEN $CI_REGISTRY
      - cd /cache/build/remoteblocks || /bin/true && ./stop.sh --purge || /bin/true
      - docker image prune -f
      - docker images --format "{{.ID}} {{.Repository}}:{{.Tag}}" | grep "/fireblocks/\|e2e_.*"
        | grep -vE ':main|:latest|/remoteblocks/|/data-service:duplicate-master' |
        awk '{print $1}' | xargs -r -P 10 docker rmi -f || true
      - docker volume rm $(docker volume ls -qf dangling=true) || true
  - - duration="$(expr $(date +%s) - "$startTime")s"
    - echo "$stepName $duration" >> $CI_PROJECT_DIR/metrics.txt
    - echo -e "\033[1;36mStep $stepName finished at $(date) and took $duration\033[0m"
  - intTestsBranch="${INTEGRATION_TESTS_BRANCH:-master}"
  - cd $BUILD_ROOT
  - echo "Cloning Integration tests $intTestsBranch branch"
  - rm -fr integration-tests && git clone --depth 1 --recurse-submodules --shallow-submodules
    -b $intTestsBranch https://gitlab-ci-token:${CI_JOB_TOKEN}@gitlab.com/fireblocks/shell/infra/integration-tests
  - - touch .npmrc
    - npm config set --location=user @fireblocks:registry https://gitlab.com/api/v4/packages/npm/
    - npm config set --location=user '//gitlab.com/api/v4/packages/npm/:_authToken'
      "${NPM_REG_TOKEN}"
    - npm config set --location=user '//gitlab.com/api/v4/projects/20565764/packages/npm/:_authToken'
      "${NPM_REG_TOKEN}"
    - echo "@fireblocks:registry=https://gitlab.com/api/v4/packages/npm/">>.npmrc
    - echo "//gitlab.com/api/v4/packages/npm/:_authToken=${NPM_REG_TOKEN}">>.npmrc
    - echo "//gitlab.com/api/v4/projects/20565764/packages/npm/:_authToken=${NPM_REG_TOKEN}">>.npmrc
    - yarn global add @fireblocks/fb-cli dot-json
  - cd $BUILD_ROOT
  - rbBranch="${REMOTEBLOCKS_BRANCH:-main}"
  - echo "Cloning Remoteblocks's $rbBranch branch"
  - rm -fr remoteblocks && git clone --depth 1 --recurse-submodules --shallow-submodules
    -b $rbBranch https://gitlab-ci-token:${CI_JOB_TOKEN}@gitlab.com/fireblocks/shell/infra/tools/remoteblocks
  - |
    if [ "$RUN_ALL_MASTERS" != "true" ]; then
      cd $BUILD_ROOT/remoteblocks
      echo ${SERVICE_NAME}
      echo ${IMAGE_TAG}
      ./update_commit_by_repo.sh ${SERVICE_NAME} ${IMAGE_TAG}
    fi
  - stepName="Building_branch"
  - - echo -e "\033[1;36mStep $stepName started at $(date)\033[0m"
    - startTime=$(date +%s)
    - sleep 1
  - excludeFlag=""
  - |
    if [ "$IMAGE_ALREADY_BUILT" == "true" ]; then
      echo "$SERVICE_NAME was already built in other job"
      SKIP_CODE_COVERAGE=$(echo "true") # Skipping code coverage instrumentation check because we didn't compile image
    elif [ "$RUN_ALL_MASTERS" != "true" ]; then
      echo "Running ${SERVICE_NAME} on image tag: ${IMAGE_TAG}. Rest of the services will run on master"
      cd $CI_PROJECT_DIR/
      if [ "$SERVICE_NAME" == "console-app-v2" ]; then
        cp packages/platform/env/.env.localstack packages/platform/env/.env
        docker build --build-arg DELMAPS=${DELMAPS} --build-arg CI_COMMIT_SHORT_SHA=${CI_COMMIT_SHORT_SHA} -t ${IMAGE_PATH}:${IMAGE_TAG} -f Dockerfile.localstack .
      else
        /bin/bash -c $BUILD_ROOT/remoteblocks/coverage-config/coverage-setup.sh || /bin/true
        docker build -t ${IMAGE_PATH}:${IMAGE_TAG} .
      fi
      excludeFlag="--exclude $CI_PROJECT_NAME"
    else
      SKIP_CODE_COVERAGE=$(echo "true") # Skipping code coverage instrumentation check because we didn't compile image
      echo "Finished modifying running all Remoteblocks services on master"
    fi
  - sleep 1
  - - duration="$(expr $(date +%s) - "$startTime")s"
    - echo "$stepName $duration" >> $CI_PROJECT_DIR/metrics.txt
    - echo -e "\033[1;36mStep $stepName finished at $(date) and took $duration\033[0m"
  - stepName="Golden_image_download_and_extract"
  - - echo -e "\033[1;36mStep $stepName started at $(date)\033[0m"
    - startTime=$(date +%s)
    - sleep 1
  - cd $BUILD_ROOT/remoteblocks/remote/docker-volume-tool
  - mkdir -p docker-volumes && cd docker-volumes
  - |
    if [ -z "$GOLDEN_IMAGE_VERSION" ]; then
      GOLDEN_IMAGE_VERSION=$(curl --header "JOB-TOKEN:$CI_JOB_TOKEN" "$CI_API_V4_URL/projects/35096363/packages?sort=desc" | jq 'map(select(.name == "golden_image")) | sort_by(.version) | .[].version' | tail -1 | tr -d '"')
    fi
  - echo "Using latest golden image version:$GOLDEN_IMAGE_VERSION"
  - 'wget --header="JOB-TOKEN: $CI_JOB_TOKEN" ${CI_API_V4_URL}/projects/35096363/packages/generic/golden_image/${GOLDEN_IMAGE_VERSION}/rb_golden_image.tar.gz'
  - rm -rf $GI_VOLUMES_FOLDER || true
  - mkdir -p $GI_VOLUMES_FOLDER && tar -xzf rb_golden_image.tar.gz -C $GI_VOLUMES_FOLDER
    --strip-components=1 && find $GI_VOLUMES_FOLDER -type f -name '._*' -delete
  - - duration="$(expr $(date +%s) - "$startTime")s"
    - echo "$stepName $duration" >> $CI_PROJECT_DIR/metrics.txt
    - echo -e "\033[1;36mStep $stepName finished at $(date) and took $duration\033[0m"
  - stepName="Golden_image_population"
  - - echo -e "\033[1;36mStep $stepName started at $(date)\033[0m"
    - startTime=$(date +%s)
    - sleep 1
  - cd $BUILD_ROOT/remoteblocks
  - "./volume-tool.sh --import $GI_VOLUMES_FOLDER"
  - - duration="$(expr $(date +%s) - "$startTime")s"
    - echo "$stepName $duration" >> $CI_PROJECT_DIR/metrics.txt
    - echo -e "\033[1;36mStep $stepName finished at $(date) and took $duration\033[0m"
  - stepName="Pulling_images-init.sh"
  - - echo -e "\033[1;36mStep $stepName started at $(date)\033[0m"
    - startTime=$(date +%s)
    - sleep 1
  - cd $BUILD_ROOT/remoteblocks
  - "./init.sh $excludeFlag"
  - - duration="$(expr $(date +%s) - "$startTime")s"
    - echo "$stepName $duration" >> $CI_PROJECT_DIR/metrics.txt
    - echo -e "\033[1;36mStep $stepName finished at $(date) and took $duration\033[0m"
  - cd $BUILD_ROOT/remoteblocks
  - "./volume-tool.sh --edit-docker-compose $CI_JOB_ID $SERVICE_NAME"
  - stepName="Starting_remoteblocks-start.sh"
  - - echo -e "\033[1;36mStep $stepName started at $(date)\033[0m"
    - startTime=$(date +%s)
    - sleep 1
  - cd $BUILD_ROOT/remoteblocks
  - "./start.sh $excludeFlag --skip-provisioning"
  - cd $BUILD_ROOT/remoteblocks/remote
  - bash service-checker.sh
  - - duration="$(expr $(date +%s) - "$startTime")s"
    - echo "$stepName $duration" >> $CI_PROJECT_DIR/metrics.txt
    - echo -e "\033[1;36mStep $stepName finished at $(date) and took $duration\033[0m"
  after_script:
  - rm -rf $CI_PROJECT_DIR/report
  - COVERAGE_METRIC_NAME="remoteblocks_it_coverage"
  - COVERAGE_TYPE="it"
  - "if [ \"$PIPELINE_SOURCE\" == \"e2e-tests\" ]; then\n  cd $BUILD_ROOT/e2e\n  echo
    \"Uploading e2e-tests artifacts\"\n  COVERAGE_METRIC_NAME=\"remoteblocks_e2e_coverage\"\n
    \ COVERAGE_TYPE=\"e2e\"\n  docker cp $E2E_CONTAINER_NAME:e2e/results $CI_PROJECT_DIR/report
    || /bin/true\n  docker cp $E2E_CONTAINER_NAME:e2e/test-config.json $CI_PROJECT_DIR
    || /bin/true\n  echo \"Stopping $E2E_CONTAINER_NAME container\"\n  docker-compose
    -p $E2E_CONTAINER_NAME down -v --remove-orphans\t--rmi local || /bin/true\nfi\n"
  - |
    if [ "$PIPELINE_SOURCE" == "integration-tests" ]; then
      echo "Uploading integration-tests artifacts"
      cd $BUILD_ROOT/integration-tests
      cp -r output $CI_PROJECT_DIR/report
    fi
  - stepName="Uploading_services_logs"
  - - echo -e "\033[1;36mStep $stepName started at $(date)\033[0m"
    - startTime=$(date +%s)
    - sleep 1
  - cd $BUILD_ROOT/remoteblocks
  - "./coverage-config/coverage-collect.sh || /bin/true"
  - "./volume-tool.sh --export-logs $SERVICES_LOGS_FOLDER"
  - cd remote/docker-volume-tool
  - cp -r $SERVICES_LOGS_FOLDER $CI_PROJECT_DIR/report
  - - duration="$(expr $(date +%s) - "$startTime")s"
    - echo "$stepName $duration" >> $CI_PROJECT_DIR/metrics.txt
    - echo -e "\033[1;36mStep $stepName finished at $(date) and took $duration\033[0m"
  - stepName="Final_containers_stopping-stop.sh"
  - - echo -e "\033[1;36mStep $stepName started at $(date)\033[0m"
    - startTime=$(date +%s)
    - sleep 1
  - cd $BUILD_ROOT/remoteblocks
  - "./stop.sh --kill || /bin/true"
  - - duration="$(expr $(date +%s) - "$startTime")s"
    - echo "$stepName $duration" >> $CI_PROJECT_DIR/metrics.txt
    - echo -e "\033[1;36mStep $stepName finished at $(date) and took $duration\033[0m"
  - cp $CI_PROJECT_DIR/metrics.txt $CI_PROJECT_DIR/report || /bin/true
  - if [ "$RUN_ALL_MASTERS" != "true" ] && [ "$IMAGE_ALREADY_BUILT" != "true" ]; then
    docker rmi -f ${IMAGE_PATH}:${IMAGE_TAG} || /bin/true; fi
  - echo -e "\033[38;5;39mReport can be found here- $CI_PROJECT_URL/-/jobs/$CI_JOB_ID/artifacts/browse/report/\033[0m"
  - stepName="Cleanup_RB_Runners_After"
  - - echo -e "\033[1;36mStep $stepName started at $(date)\033[0m"
    - startTime=$(date +%s)
    - sleep 1
  - - - touch .npmrc
      - echo "@fireblocks:registry=https://gitlab.com/api/v4/packages/npm/">>.npmrc
      - echo "//gitlab.com/api/v4/packages/npm/:_authToken=${NPM_REG_READ_TOKEN}">>.npmrc
      - echo "//gitlab.com/api/v4/projects/20565764/packages/npm/:_authToken=${NPM_REG_READ_TOKEN}">>.npmrc
      - docker login -u gitlab-ci-token -p $CI_JOB_TOKEN $CI_REGISTRY
      - cd /cache/build/remoteblocks || /bin/true && ./stop.sh --purge || /bin/true
      - docker image prune -f
      - docker images --format "{{.ID}} {{.Repository}}:{{.Tag}}" | grep "/fireblocks/\|e2e_.*"
        | grep -vE ':main|:latest|/remoteblocks/|/data-service:duplicate-master' |
        awk '{print $1}' | xargs -r -P 10 docker rmi -f || true
      - docker volume rm $(docker volume ls -qf dangling=true) || true
  - - duration="$(expr $(date +%s) - "$startTime")s"
    - echo "$stepName $duration" >> $CI_PROJECT_DIR/metrics.txt
    - echo -e "\033[1;36mStep $stepName finished at $(date) and took $duration\033[0m"
  stage: test
  retry: 1
  tags:
  - rb-runner
  rules:
  - if: $DISABLE_RB_IT_TESTS == "true"
    when: never
  - if: $IS_MULTI_SERVICE_DEPLOYMENT == "true"
    when: never
  - if: $IS_PROD_SERVICE != "true"
    when: never
  - if: "$ENFORCE_RB_PIPELINE_1 == 'false'"
    when: never
  - if: "$CI_PIPELINE_SOURCE == 'merge_request_event' && $CI_MERGE_REQUEST_TITLE =~
      /^Draft:/"
    when: manual
    allow_failure: false
    changes:
    - configurations/**/localstack/**/*
    - deployment/**/localstack/**/*
    - src/**/*
    - package.json
    - Dockerfile
    - hooks/**/*
    - packages/**/*
    - Dockerfile.localstack
  - if: "$CI_PIPELINE_SOURCE == 'merge_request_event' && ($CI_MERGE_REQUEST_TITLE
      =~ /^Hotfix:/ || $CI_MERGE_REQUEST_TITLE =~ /^hotfix:/)"
    when: always
    allow_failure: true
    changes:
    - configurations/**/localstack/**/*
    - deployment/**/localstack/**/*
    - src/**/*
    - package.json
    - Dockerfile
    - hooks/**/*
    - packages/**/*
    - Dockerfile.localstack
  - if: "$CI_PIPELINE_SOURCE == 'merge_request_event'"
    when: always
    allow_failure: false
    changes:
    - configurations/**/localstack/**/*
    - deployment/**/localstack/**/*
    - src/**/*
    - package.json
    - Dockerfile
    - hooks/**/*
    - packages/**/*
    - Dockerfile.localstack
  - if: $CI_COMMIT_BRANCH == "master" || $CI_COMMIT_BRANCH == "main"
    when: always
    allow_failure: false
    changes:
    - configurations/**/localstack/**/*
    - deployment/**/localstack/**/*
    - src/**/*
    - package.json
    - Dockerfile
    - hooks/**/*
    - packages/**/*
    - Dockerfile.localstack
  - when: never
    allow_failure: true
  environment:
    name: localstack
  timeout: 60 minutes
  script:
  - stepName="Integration_Tests"
  - - echo -e "\033[1;36mStep $stepName started at $(date)\033[0m"
    - startTime=$(date +%s)
    - sleep 1
  - cd $BUILD_ROOT/integration-tests
  - echo "Starting sanity integration tests"
  - su
  - yarn cache clean
  - - touch .npmrc
    - npm config set --location=user @fireblocks:registry https://gitlab.com/api/v4/packages/npm/
    - npm config set --location=user '//gitlab.com/api/v4/packages/npm/:_authToken'
      "${NPM_REG_TOKEN}"
    - npm config set --location=user '//gitlab.com/api/v4/projects/20565764/packages/npm/:_authToken'
      "${NPM_REG_TOKEN}"
    - echo "@fireblocks:registry=https://gitlab.com/api/v4/packages/npm/">>.npmrc
    - echo "//gitlab.com/api/v4/packages/npm/:_authToken=${NPM_REG_TOKEN}">>.npmrc
    - echo "//gitlab.com/api/v4/projects/20565764/packages/npm/:_authToken=${NPM_REG_TOKEN}">>.npmrc
    - yarn global add @fireblocks/fb-cli dot-json
  - "./buildAndTest.sh"
  - - duration="$(expr $(date +%s) - "$startTime")s"
    - echo "$stepName $duration" >> $CI_PROJECT_DIR/metrics.txt
    - echo -e "\033[1;36mStep $stepName finished at $(date) and took $duration\033[0m"
  extends: ".setup-remoteblocks"
remoteblocks:e2e-tests:
  image: registry.gitlab.com/fireblocks/shell/infra/images/node-infra-18:18.19-alpine3.19-fb1.4
  artifacts:
    name: "${CI_JOB_NAME}_${CI_COMMIT_REF_NAME}"
    paths:
    - report
    expire_in: 1 week
    when: always
    reports:
      metrics:
      - metrics.txt
  variables:
    MODE: local
    GITLAB_TOKEN: "$CI_JOB_TOKEN"
    BUILD_ROOT: "/cache/build"
    GI_VOLUMES_FOLDER: "/cache/rb_it_goldenimage"
    KUBECONFIG: "/root/.kube/config"
    ENABLE_CROSSPLANE: 'false'
    NOTIFY_ALREADY_EXISTS_RESOURCES: 'true'
    DEVTOOLS_NOTIFICATIONS_CHANNEL: C07AVQ0Q2G6
    SERVICES_LOGS_FOLDER: services_logs
    COVERAGE_DOCKER_SIGTERM_TIMEOUT: "$DEFAULT_COVERAGE_DOCKER_SIGTERM_TIMEOUT"
    COVERAGE_DOCKER_SIGTERM_SLEEP: "$DEFAULT_COVERAGE_DOCKER_SIGTERM_SLEEP"
    FB_COMPONENT_TYPE: service
    FB_COMPONENT_MAIN_LANG: typescript
    COVERAGE_SPECIFIC_FILES_PATH: "$CI_PROJECT_DIR/report/coverage/cobertura-coverage.xml"
    ENVIRONMENT: localstack
    E2E_DOCKER_NAME: e2e_${CI_COMMIT_SHORT_SHA}
    PIPELINE_SOURCE: e2e-tests
    E2E_CONTAINER_NAME: e2e_${CI_COMMIT_SHORT_SHA}
  before_script:
  - ls -la $CI_PROJECT_DIR/
  - apk add yq sudo openssl kubectl helm
  - ln -s /root /home/ubuntu
  - - touch .npmrc
    - npm config set --location=user @fireblocks:registry https://gitlab.com/api/v4/packages/npm/
    - npm config set --location=user '//gitlab.com/api/v4/packages/npm/:_authToken'
      "${NPM_REG_TOKEN}"
    - npm config set --location=user '//gitlab.com/api/v4/projects/20565764/packages/npm/:_authToken'
      "${NPM_REG_TOKEN}"
    - echo "@fireblocks:registry=https://gitlab.com/api/v4/packages/npm/">>.npmrc
    - echo "//gitlab.com/api/v4/packages/npm/:_authToken=${NPM_REG_TOKEN}">>.npmrc
    - echo "//gitlab.com/api/v4/projects/20565764/packages/npm/:_authToken=${NPM_REG_TOKEN}">>.npmrc
    - yarn global add @fireblocks/fb-cli dot-json
  - docker login -u gitlab-ci-token -p $CI_JOB_TOKEN $CI_REGISTRY
  - stepName="Init_Docker_Network"
  - - echo -e "\033[1;36mStep $stepName started at $(date)\033[0m"
    - startTime=$(date +%s)
    - sleep 1
  - docker network create -d bridge core_integration || /bin/true
  - CURR_CONTAINER_ID=$(docker ps | grep "$HOSTNAME" | awk '{print $1}')
  - docker network connect core_integration $CURR_CONTAINER_ID
  - docker network connect minikube $CURR_CONTAINER_ID || /bin/true
  - mkdir -p $BUILD_ROOT && cd $BUILD_ROOT
  - sleep 1
  - - duration="$(expr $(date +%s) - "$startTime")s"
    - echo "$stepName $duration" >> $CI_PROJECT_DIR/metrics.txt
    - echo -e "\033[1;36mStep $stepName finished at $(date) and took $duration\033[0m"
  - stepName="Cleanup_K8s_Resources"
  - - echo -e "\033[1;36mStep $stepName started at $(date)\033[0m"
    - startTime=$(date +%s)
    - sleep 1
  - kubectl get -n services-resources managed -o name | xargs -r -I % -P 20 kubectl
    patch % -p '{"metadata":{"finalizers":[]}}' --type=merge &>/dev/null || /bin/true
  - kubectl get -n services-resources claim -o name | xargs -r -I % -P 20 kubectl
    patch -n services-resources % -p '{"metadata":{"finalizers":[]}}' --type=merge
    &>/dev/null || /bin/true
  - helm ls --all --short -n services-resources | xargs -r -P 20 helm delete -n services-resources
    &>/dev/null || /bin/true
  - kubectl get -n services-resources managed -o name | xargs -r -P 20 kubectl delete
    -n services-resources &>/dev/null || /bin/true &
  - kubectl get -n services-resources claim -o name | xargs -r -P 20 kubectl delete
    -n services-resources &>/dev/null || /bin/true &
  - |
    if [ "$RB_CLEAN_CROSSPLANE" == "true" ]; then
      kubectl delete all --all -n default --ignore-not-found=true --grace-period=0 --force || /bin/true
      kubectl delete all --all -n crossplane-system --ignore-not-found=true --grace-period=0 --force || /bin/true
      kubectl get crds 2>/dev/null | grep -qE "crossplane.io|fireblocks|upbound" | awk '{print $1}' | xargs -r -P 10 kubectl delete crd || /bin/true
    fi
  - - duration="$(expr $(date +%s) - "$startTime")s"
    - echo "$stepName $duration" >> $CI_PROJECT_DIR/metrics.txt
    - echo -e "\033[1;36mStep $stepName finished at $(date) and took $duration\033[0m"
  - stepName="Cleanup_RB_Runners_Before"
  - - echo -e "\033[1;36mStep $stepName started at $(date)\033[0m"
    - startTime=$(date +%s)
    - sleep 1
  - - - touch .npmrc
      - echo "@fireblocks:registry=https://gitlab.com/api/v4/packages/npm/">>.npmrc
      - echo "//gitlab.com/api/v4/packages/npm/:_authToken=${NPM_REG_READ_TOKEN}">>.npmrc
      - echo "//gitlab.com/api/v4/projects/20565764/packages/npm/:_authToken=${NPM_REG_READ_TOKEN}">>.npmrc
      - docker login -u gitlab-ci-token -p $CI_JOB_TOKEN $CI_REGISTRY
      - cd /cache/build/remoteblocks || /bin/true && ./stop.sh --purge || /bin/true
      - docker image prune -f
      - docker images --format "{{.ID}} {{.Repository}}:{{.Tag}}" | grep "/fireblocks/\|e2e_.*"
        | grep -vE ':main|:latest|/remoteblocks/|/data-service:duplicate-master' |
        awk '{print $1}' | xargs -r -P 10 docker rmi -f || true
      - docker volume rm $(docker volume ls -qf dangling=true) || true
  - - duration="$(expr $(date +%s) - "$startTime")s"
    - echo "$stepName $duration" >> $CI_PROJECT_DIR/metrics.txt
    - echo -e "\033[1;36mStep $stepName finished at $(date) and took $duration\033[0m"
  - intTestsBranch="${INTEGRATION_TESTS_BRANCH:-master}"
  - cd $BUILD_ROOT
  - echo "Cloning Integration tests $intTestsBranch branch"
  - rm -fr integration-tests && git clone --depth 1 --recurse-submodules --shallow-submodules
    -b $intTestsBranch https://gitlab-ci-token:${CI_JOB_TOKEN}@gitlab.com/fireblocks/shell/infra/integration-tests
  - - touch .npmrc
    - npm config set --location=user @fireblocks:registry https://gitlab.com/api/v4/packages/npm/
    - npm config set --location=user '//gitlab.com/api/v4/packages/npm/:_authToken'
      "${NPM_REG_TOKEN}"
    - npm config set --location=user '//gitlab.com/api/v4/projects/20565764/packages/npm/:_authToken'
      "${NPM_REG_TOKEN}"
    - echo "@fireblocks:registry=https://gitlab.com/api/v4/packages/npm/">>.npmrc
    - echo "//gitlab.com/api/v4/packages/npm/:_authToken=${NPM_REG_TOKEN}">>.npmrc
    - echo "//gitlab.com/api/v4/projects/20565764/packages/npm/:_authToken=${NPM_REG_TOKEN}">>.npmrc
    - yarn global add @fireblocks/fb-cli dot-json
  - cd $BUILD_ROOT
  - rbBranch="${REMOTEBLOCKS_BRANCH:-main}"
  - echo "Cloning Remoteblocks's $rbBranch branch"
  - rm -fr remoteblocks && git clone --depth 1 --recurse-submodules --shallow-submodules
    -b $rbBranch https://gitlab-ci-token:${CI_JOB_TOKEN}@gitlab.com/fireblocks/shell/infra/tools/remoteblocks
  - |
    if [ "$RUN_ALL_MASTERS" != "true" ]; then
      cd $BUILD_ROOT/remoteblocks
      echo ${SERVICE_NAME}
      echo ${IMAGE_TAG}
      ./update_commit_by_repo.sh ${SERVICE_NAME} ${IMAGE_TAG}
    fi
  - stepName="Building_branch"
  - - echo -e "\033[1;36mStep $stepName started at $(date)\033[0m"
    - startTime=$(date +%s)
    - sleep 1
  - excludeFlag=""
  - |
    if [ "$IMAGE_ALREADY_BUILT" == "true" ]; then
      echo "$SERVICE_NAME was already built in other job"
      SKIP_CODE_COVERAGE=$(echo "true") # Skipping code coverage instrumentation check because we didn't compile image
    elif [ "$RUN_ALL_MASTERS" != "true" ]; then
      echo "Running ${SERVICE_NAME} on image tag: ${IMAGE_TAG}. Rest of the services will run on master"
      cd $CI_PROJECT_DIR/
      if [ "$SERVICE_NAME" == "console-app-v2" ]; then
        cp packages/platform/env/.env.localstack packages/platform/env/.env
        docker build --build-arg DELMAPS=${DELMAPS} --build-arg CI_COMMIT_SHORT_SHA=${CI_COMMIT_SHORT_SHA} -t ${IMAGE_PATH}:${IMAGE_TAG} -f Dockerfile.localstack .
      else
        /bin/bash -c $BUILD_ROOT/remoteblocks/coverage-config/coverage-setup.sh || /bin/true
        docker build -t ${IMAGE_PATH}:${IMAGE_TAG} .
      fi
      excludeFlag="--exclude $CI_PROJECT_NAME"
    else
      SKIP_CODE_COVERAGE=$(echo "true") # Skipping code coverage instrumentation check because we didn't compile image
      echo "Finished modifying running all Remoteblocks services on master"
    fi
  - sleep 1
  - - duration="$(expr $(date +%s) - "$startTime")s"
    - echo "$stepName $duration" >> $CI_PROJECT_DIR/metrics.txt
    - echo -e "\033[1;36mStep $stepName finished at $(date) and took $duration\033[0m"
  - stepName="Golden_image_download_and_extract"
  - - echo -e "\033[1;36mStep $stepName started at $(date)\033[0m"
    - startTime=$(date +%s)
    - sleep 1
  - cd $BUILD_ROOT/remoteblocks/remote/docker-volume-tool
  - mkdir -p docker-volumes && cd docker-volumes
  - |
    if [ -z "$GOLDEN_IMAGE_VERSION" ]; then
      GOLDEN_IMAGE_VERSION=$(curl --header "JOB-TOKEN:$CI_JOB_TOKEN" "$CI_API_V4_URL/projects/35096363/packages?sort=desc" | jq 'map(select(.name == "golden_image")) | sort_by(.version) | .[].version' | tail -1 | tr -d '"')
    fi
  - echo "Using latest golden image version:$GOLDEN_IMAGE_VERSION"
  - 'wget --header="JOB-TOKEN: $CI_JOB_TOKEN" ${CI_API_V4_URL}/projects/35096363/packages/generic/golden_image/${GOLDEN_IMAGE_VERSION}/rb_golden_image.tar.gz'
  - rm -rf $GI_VOLUMES_FOLDER || true
  - mkdir -p $GI_VOLUMES_FOLDER && tar -xzf rb_golden_image.tar.gz -C $GI_VOLUMES_FOLDER
    --strip-components=1 && find $GI_VOLUMES_FOLDER -type f -name '._*' -delete
  - - duration="$(expr $(date +%s) - "$startTime")s"
    - echo "$stepName $duration" >> $CI_PROJECT_DIR/metrics.txt
    - echo -e "\033[1;36mStep $stepName finished at $(date) and took $duration\033[0m"
  - stepName="Golden_image_population"
  - - echo -e "\033[1;36mStep $stepName started at $(date)\033[0m"
    - startTime=$(date +%s)
    - sleep 1
  - cd $BUILD_ROOT/remoteblocks
  - "./volume-tool.sh --import $GI_VOLUMES_FOLDER"
  - - duration="$(expr $(date +%s) - "$startTime")s"
    - echo "$stepName $duration" >> $CI_PROJECT_DIR/metrics.txt
    - echo -e "\033[1;36mStep $stepName finished at $(date) and took $duration\033[0m"
  - stepName="Pulling_images-init.sh"
  - - echo -e "\033[1;36mStep $stepName started at $(date)\033[0m"
    - startTime=$(date +%s)
    - sleep 1
  - cd $BUILD_ROOT/remoteblocks
  - "./init.sh $excludeFlag"
  - - duration="$(expr $(date +%s) - "$startTime")s"
    - echo "$stepName $duration" >> $CI_PROJECT_DIR/metrics.txt
    - echo -e "\033[1;36mStep $stepName finished at $(date) and took $duration\033[0m"
  - cd $BUILD_ROOT/remoteblocks
  - "./volume-tool.sh --edit-docker-compose $CI_JOB_ID $SERVICE_NAME"
  - stepName="Starting_remoteblocks-start.sh"
  - - echo -e "\033[1;36mStep $stepName started at $(date)\033[0m"
    - startTime=$(date +%s)
    - sleep 1
  - cd $BUILD_ROOT/remoteblocks
  - "./start.sh $excludeFlag --skip-provisioning"
  - cd $BUILD_ROOT/remoteblocks/remote
  - bash service-checker.sh
  - - duration="$(expr $(date +%s) - "$startTime")s"
    - echo "$stepName $duration" >> $CI_PROJECT_DIR/metrics.txt
    - echo -e "\033[1;36mStep $stepName finished at $(date) and took $duration\033[0m"
  after_script:
  - rm -rf $CI_PROJECT_DIR/report
  - COVERAGE_METRIC_NAME="remoteblocks_it_coverage"
  - COVERAGE_TYPE="it"
  - "if [ \"$PIPELINE_SOURCE\" == \"e2e-tests\" ]; then\n  cd $BUILD_ROOT/e2e\n  echo
    \"Uploading e2e-tests artifacts\"\n  COVERAGE_METRIC_NAME=\"remoteblocks_e2e_coverage\"\n
    \ COVERAGE_TYPE=\"e2e\"\n  docker cp $E2E_CONTAINER_NAME:e2e/results $CI_PROJECT_DIR/report
    || /bin/true\n  docker cp $E2E_CONTAINER_NAME:e2e/test-config.json $CI_PROJECT_DIR
    || /bin/true\n  echo \"Stopping $E2E_CONTAINER_NAME container\"\n  docker-compose
    -p $E2E_CONTAINER_NAME down -v --remove-orphans\t--rmi local || /bin/true\nfi\n"
  - |
    if [ "$PIPELINE_SOURCE" == "integration-tests" ]; then
      echo "Uploading integration-tests artifacts"
      cd $BUILD_ROOT/integration-tests
      cp -r output $CI_PROJECT_DIR/report
    fi
  - stepName="Uploading_services_logs"
  - - echo -e "\033[1;36mStep $stepName started at $(date)\033[0m"
    - startTime=$(date +%s)
    - sleep 1
  - cd $BUILD_ROOT/remoteblocks
  - "./coverage-config/coverage-collect.sh || /bin/true"
  - "./volume-tool.sh --export-logs $SERVICES_LOGS_FOLDER"
  - cd remote/docker-volume-tool
  - cp -r $SERVICES_LOGS_FOLDER $CI_PROJECT_DIR/report
  - - duration="$(expr $(date +%s) - "$startTime")s"
    - echo "$stepName $duration" >> $CI_PROJECT_DIR/metrics.txt
    - echo -e "\033[1;36mStep $stepName finished at $(date) and took $duration\033[0m"
  - stepName="Final_containers_stopping-stop.sh"
  - - echo -e "\033[1;36mStep $stepName started at $(date)\033[0m"
    - startTime=$(date +%s)
    - sleep 1
  - cd $BUILD_ROOT/remoteblocks
  - "./stop.sh --kill || /bin/true"
  - - duration="$(expr $(date +%s) - "$startTime")s"
    - echo "$stepName $duration" >> $CI_PROJECT_DIR/metrics.txt
    - echo -e "\033[1;36mStep $stepName finished at $(date) and took $duration\033[0m"
  - cp $CI_PROJECT_DIR/metrics.txt $CI_PROJECT_DIR/report || /bin/true
  - if [ "$RUN_ALL_MASTERS" != "true" ] && [ "$IMAGE_ALREADY_BUILT" != "true" ]; then
    docker rmi -f ${IMAGE_PATH}:${IMAGE_TAG} || /bin/true; fi
  - echo -e "\033[38;5;39mReport can be found here- $CI_PROJECT_URL/-/jobs/$CI_JOB_ID/artifacts/browse/report/\033[0m"
  - stepName="Cleanup_RB_Runners_After"
  - - echo -e "\033[1;36mStep $stepName started at $(date)\033[0m"
    - startTime=$(date +%s)
    - sleep 1
  - - - touch .npmrc
      - echo "@fireblocks:registry=https://gitlab.com/api/v4/packages/npm/">>.npmrc
      - echo "//gitlab.com/api/v4/packages/npm/:_authToken=${NPM_REG_READ_TOKEN}">>.npmrc
      - echo "//gitlab.com/api/v4/projects/20565764/packages/npm/:_authToken=${NPM_REG_READ_TOKEN}">>.npmrc
      - docker login -u gitlab-ci-token -p $CI_JOB_TOKEN $CI_REGISTRY
      - cd /cache/build/remoteblocks || /bin/true && ./stop.sh --purge || /bin/true
      - docker image prune -f
      - docker images --format "{{.ID}} {{.Repository}}:{{.Tag}}" | grep "/fireblocks/\|e2e_.*"
        | grep -vE ':main|:latest|/remoteblocks/|/data-service:duplicate-master' |
        awk '{print $1}' | xargs -r -P 10 docker rmi -f || true
      - docker volume rm $(docker volume ls -qf dangling=true) || true
  - - duration="$(expr $(date +%s) - "$startTime")s"
    - echo "$stepName $duration" >> $CI_PROJECT_DIR/metrics.txt
    - echo -e "\033[1;36mStep $stepName finished at $(date) and took $duration\033[0m"
  stage: test
  tags:
  - remoteblocks-autoscaled-e2e-runner
  rules:
  - if: $REQUIRE_E2E_TESTS != "true"
    when: never
  - if: $IS_MULTI_SERVICE_DEPLOYMENT == "true"
    when: never
  - if: $IS_PROD_SERVICE != "true"
    when: never
  - if: "$ENFORCE_RB_PIPELINE_1 == 'false'"
    when: never
  - if: "$CI_PIPELINE_SOURCE == 'merge_request_event' && $CI_MERGE_REQUEST_TITLE =~
      /^Draft:/"
    when: manual
    allow_failure: false
    changes:
    - configurations/**/localstack/**/*
    - deployment/**/localstack/**/*
    - src/**/*
    - package.json
    - Dockerfile
    - hooks/**/*
    - packages/**/*
    - Dockerfile.localstack
  - if: "$CI_PIPELINE_SOURCE == 'merge_request_event' && ($CI_MERGE_REQUEST_TITLE
      =~ /^Hotfix:/ || $CI_MERGE_REQUEST_TITLE =~ /^hotfix:/)"
    when: always
    allow_failure: true
    changes:
    - configurations/**/localstack/**/*
    - deployment/**/localstack/**/*
    - src/**/*
    - package.json
    - Dockerfile
    - hooks/**/*
    - packages/**/*
    - Dockerfile.localstack
  - if: "$CI_PIPELINE_SOURCE == 'merge_request_event'"
    when: always
    allow_failure: false
    changes:
    - configurations/**/localstack/**/*
    - deployment/**/localstack/**/*
    - src/**/*
    - package.json
    - Dockerfile
    - hooks/**/*
    - packages/**/*
    - Dockerfile.localstack
  - if: $CI_COMMIT_BRANCH == "master" || $CI_COMMIT_BRANCH == "main"
    when: always
    allow_failure: false
    changes:
    - configurations/**/localstack/**/*
    - deployment/**/localstack/**/*
    - src/**/*
    - package.json
    - Dockerfile
    - hooks/**/*
    - packages/**/*
    - Dockerfile.localstack
  - when: never
    allow_failure: true
  timeout: 60 minutes
  environment:
    name: localstack
  script:
  - cd $BUILD_ROOT
  - e2eBranch="${E2E_BRANCH:-master}"
  - echo "Cloning e2e automation tests $e2eBranch branch"
  - rm -fr e2e && git clone --depth 1 --recurse-submodules -b $e2eBranch --shallow-submodules
    https://gitlab-ci-token:${CI_JOB_TOKEN}@gitlab.com/fireblocks/tools/e2e
  - cd $BUILD_ROOT/e2e
  - - touch .npmrc
    - npm config set --location=user @fireblocks:registry https://gitlab.com/api/v4/packages/npm/
    - npm config set --location=user '//gitlab.com/api/v4/packages/npm/:_authToken'
      "${NPM_REG_TOKEN}"
    - npm config set --location=user '//gitlab.com/api/v4/projects/20565764/packages/npm/:_authToken'
      "${NPM_REG_TOKEN}"
    - echo "@fireblocks:registry=https://gitlab.com/api/v4/packages/npm/">>.npmrc
    - echo "//gitlab.com/api/v4/packages/npm/:_authToken=${NPM_REG_TOKEN}">>.npmrc
    - echo "//gitlab.com/api/v4/projects/20565764/packages/npm/:_authToken=${NPM_REG_TOKEN}">>.npmrc
    - yarn global add @fireblocks/fb-cli dot-json
  - stepName="E2E_Tests"
  - - echo -e "\033[1;36mStep $stepName started at $(date)\033[0m"
    - startTime=$(date +%s)
    - sleep 1
  - cd $BUILD_ROOT/e2e
  - echo "Building e2e automation tests"
  - docker build -t $E2E_CONTAINER_NAME:${CI_COMMIT_SHORT_SHA} .
  - echo "Checking for old e2e containers..."
  - containers=$(docker ps -a --format "{{.Names}}" | grep -E '^e2e(_[a-zA-Z0-9]+)?$'
    || true)
  - |
    if [ -z "$containers" ]; then
      echo "No containers of e2e were found, continuing...";
    else
      echo "$containers" | xargs -I {} sh -c 'echo "Stopping container: {}" && docker stop {} && echo "Removing container: {}" && docker rm {}';
    fi
  - echo "E2E_CONTAINER_NAME- $E2E_CONTAINER_NAME"
  - docker-compose -p $E2E_CONTAINER_NAME up -d
  - docker ps -a
  - docker ps --format "{{.ID}} {{.Names}}"
  - docker ps --format "{{.ID}} {{.Names}}" | grep $E2E_CONTAINER_NAME
  - docker ps --format "{{.ID}} {{.Names}}" | grep $E2E_CONTAINER_NAME | cut -d' '
    -f1
  - E2E_CONTAINER_ID=$(docker ps --format "{{.ID}} {{.Names}}" | grep $E2E_CONTAINER_NAME
    | cut -d' ' -f1)
  - echo "E2E_CONTAINER_ID- $E2E_CONTAINER_ID"
  - echo "Starting e2e automation tests"
  - docker exec -i $E2E_CONTAINER_ID ./scripts/bash/remoteBlocks.sh;
  - - duration="$(expr $(date +%s) - "$startTime")s"
    - echo "$stepName $duration" >> $CI_PROJECT_DIR/metrics.txt
    - echo -e "\033[1;36mStep $stepName finished at $(date) and took $duration\033[0m"
  extends: ".setup-remoteblocks"
variables:
  PACKAGE_NAME: "${SERVICE_NAME}-${CI_COMMIT_SHORT_SHA}.zip"
  GENERATED_DOCKERFILE_PATH: Dockerfile_generated
  SHELL_LIBS_PROJECT_ID: 20565764
  FORCE_COLOR: '1'
  SERVICE_NAME: "${CI_PROJECT_NAME}"
  CONTAINER_NAME: "${SERVICE_NAME}"
  IMAGE_TAG: "${CI_COMMIT_SHORT_SHA}"
  IMAGE_PATH: "${CI_REGISTRY_IMAGE}/ci_build/${SERVICE_NAME}"
  DEFAULT_DOCKER_STOP_TIMEOUT: '15'
  WIZ_POLICY: Default vulnerabilities policy
  DOCKER_COMPOSE_PATH_PROD_US: docker-compose-${SERVICE_NAME}.yml
  TEST_NODE_VERSION: node-18.12.1
  IS_PROD_SERVICE: 'false'
  IS_DEPLOYABLE_SERVICE: 'true'
  DATADOG_SERVICE: "${SERVICE_NAME}"
  DD_API_KEY: "${DATADOG_API_KEY}"
  DD_CIVISIBILITY_AGENTLESS_ENABLED: 'true'
  DEFAULT_COVERAGE_DOCKER_SIGTERM_SLEEP: '85'
  DEFAULT_COVERAGE_DOCKER_SIGTERM_TIMEOUT: '90'
  PULL_BEFORE_STOP: 'false'
  SKIP_IMAGE_BUILD: 'false'
  FORCE_IMAGE_BUILD_FROM_TEMPLATE: 'false'
  IS_MULTI_SERVICE_DEPLOYMENT: 'false'
  TF_IMAGE: registry.gitlab.com/fireblocks/devops/terraform/terraform-runner:v0.5.4
  STRATEGY: canary
  DEV_ENV_AUTO_ROLLOUT: "${DEV_ENV_AUTO_ROLLOUT}"
  RUN_MESSAGING_LIBRARY_COMPONENT_TESTS: 'true'
  RUN_COMPONENT_TESTS: 'false'
  CI_DEBUG_SERVICES: 'false'
  SKIP_UPDATE_REQUEST: 'false'
  SKIP_CHECK_YARN_PROBLEMS: 'false'
  SKIP_CHECK_DEPRECATED_PACKAGES: 'false'
  SKIP_CHECK_FORBIDDEN_PACKAGES: 'false'
  SKIP_TEST: 'false'
  IS_NITRO_SERVICE: 'false'
  TEMPLATE_REF: main
  CI_CONFIG_MANAGEMENT_ENABLED: 'true'
  GENERATE_SDK: 'false'
  ENGINE: argocd
  VERACODE_APPLICATION: Web3
  ENVIRONMENT: dev9
  AWS_DEFAULT_REGION: us-east-2
".veracode-pipeline-scan":
  tags:
  - shell-application-gitlab-runner
  retry: 2
  script:
  - |
    apk add zip curl openjdk11
    zip -r $PACKAGE_NAME . -x *test.ts -x wait -x test.js -x spec.ts -x *.pl -x *.sql
    curl -O https://downloads.veracode.com/securityscan/pipeline-scan-LATEST.zip
    unzip pipeline-scan-LATEST.zip pipeline-scan.jar
    java -jar pipeline-scan.jar \
        -vid $VERACODE_API_ID \
        -vkey $VERACODE_API_KEY \
        --file $PACKAGE_NAME \
        -fs 'Very High, High'
  rules:
  - if: $IS_PROD_SERVICE != "true"
    when: never
  - if: "$CI_PIPELINE_SOURCE == 'merge_request_event' && $CI_MERGE_REQUEST_TITLE =~
      /^Draft:/"
    when: manual
  - if: "$CI_COMMIT_TAG"
    when: never
  - if: ($CI_COMMIT_BRANCH == "master" || $CI_COMMIT_BRANCH == "main") && ($VERACODE_APPLICATION
      != null)
    when: always
".veracode-sandbox-scan":
  tags:
  - shell-application-gitlab-runner
  retry: 2
  script:
  - "apk add zip openjdk11\nzip -r $PACKAGE_NAME . -x *test.ts -x wait -x test.js
    -x spec.ts -x *.pl -x *.sql\nwget \"https://repo1.maven.org/maven2/com/veracode/vosp/api/wrappers/vosp-api-wrappers-java/19.2.5.6/vosp-api-wrappers-java-19.2.5.6.jar\"
    -O VeracodeJavaAPI.jar\njava -jar VeracodeJavaAPI.jar \\\n  -vid ${VERACODE_API_ID}
    \\\n  -vkey ${VERACODE_API_KEY} \\\n  -action uploadandscan \\\n  -appname $VERACODE_APPLICATION
    \\\n  -createprofile false \\\n  -version \"$VERACODE_APPLICATION-$RANDOM$RANDOM\"
    \\\n  -filepath $PACKAGE_NAME \\\n  -selected true \\\n  -sandboxname $CI_PROJECT_NAME
    \\\n  -createsandbox\ttrue \\\n  -scanallnonfataltoplevelmodules true \\\n"
  rules:
  - if: ($CI_COMMIT_BRANCH == "master" || $CI_COMMIT_BRANCH == "main") && ($VERACODE_APPLICATION
      != null)
    when: always
  - when: never
".rules_for_deploy_prod":
  rules:
  - if: $IS_DEPLOYABLE_SERVICE != "true"
    when: never
  - if: $IS_PROD_SERVICE != "true"
    when: never
  - if: "$CI_PIPELINE_SOURCE == 'merge_request_event'"
    when: never
  - if: ($CI_COMMIT_BRANCH == "master" || $CI_COMMIT_BRANCH == "main") && $STRATEGY
      == "classic"
    when: manual
".rules_for_deploy_prod_k8s":
  rules:
  - if: $IS_DEPLOYABLE_SERVICE != "true"
    when: never
  - if: $IS_PROD_SERVICE != "true"
    when: never
  - if: "$CI_PIPELINE_SOURCE == 'merge_request_event'"
    when: never
  - if: ($CI_COMMIT_BRANCH == "master" || $CI_COMMIT_BRANCH == "main") && $STRATEGY
      == "canary"
    when: manual
".rules_for_deploy_prod_k8s_in_place":
  rules:
  - if: $IS_DEPLOYABLE_SERVICE != "true"
    when: never
  - if: $IS_PROD_SERVICE != "true"
    when: never
  - if: "$CI_PIPELINE_SOURCE == 'merge_request_event'"
    when: never
  - if: ($CI_COMMIT_BRANCH == "master" || $CI_COMMIT_BRANCH == "main") && $STRATEGY
      == "in_place"
    when: manual
".rules_for_deploy":
  rules:
  - if: $IS_DEPLOYABLE_SERVICE != "true"
    when: never
  - if: "$CI_COMMIT_TAG"
    when: never
  - if: "$CI_PIPELINE_SOURCE == 'merge_request_event'"
    when: never
  - if: $STRATEGY == "classic"
    when: manual
    allow_failure: true
".rules_for_deploy_k8s":
  rules:
  - if: $IS_DEPLOYABLE_SERVICE != "true"
    when: never
  - if: "$CI_COMMIT_TAG"
    when: never
  - if: "$CI_PIPELINE_SOURCE == 'merge_request_event'"
    when: never
  - if: $STRATEGY == "canary"
    when: manual
    allow_failure: true
".rules_for_deploy_k8s_in_place":
  rules:
  - if: $IS_DEPLOYABLE_SERVICE != "true"
    when: never
  - if: "$CI_COMMIT_TAG"
    when: never
  - if: "$CI_PIPELINE_SOURCE == 'merge_request_event'"
    when: never
    allow_failure: true
  - if: $STRATEGY == "in_place"
    when: manual
    allow_failure: true
".rules_for_deploy_localstack":
  rules:
  - if: "$CI_COMMIT_TAG"
    when: never
  - if: "$CI_PIPELINE_SOURCE == 'merge_request_event'"
    when: never
  - if: $IS_MULTI_SERVICE_DEPLOYMENT == "true"
    when: never
  - if: $CI_COMMIT_BRANCH == "master" || $CI_COMMIT_BRANCH == "main"
    changes:
    - deployment/values.yaml
    - deployment/overrides/nonprod-tier.yaml
    - deployment/overrides/pre1.yaml
    - deployment/overrides/localstack.yaml
    when: always
    allow_failure: true
  - when: never
".verify-deployment-folder-script":
  before_script:
  - apk update
  - apk add curl jq yq py3-pip
  - pip3 install --upgrade pip
  - pip3 install yamllint
  - pip3 install yamale --break-system-packages
  - npm install -g ajv-cli
  - echo "Configuring Git"
  - echo "https://argocd-ci-push:${ARGOCD_GITLAB_ACCESS_TOKEN}@gitlab.com" > ~/.git-credentials
  - git remote set-url origin https://argocd-ci-push:${ARGOCD_GITLAB_ACCESS_TOKEN}@gitlab.com/fireblocks/devops/iac/argocd.git
  - git config --global user.email "devops@fireblocks.com"
  - git config --global user.name "argocd-ci-push"
  - git config --global credential.helper store
  - touch .npmrc
  - npm config set --location=user @fireblocks:registry https://gitlab.com/api/v4/packages/npm/
  - npm config set --location=user '//gitlab.com/api/v4/packages/npm/:_authToken'
    "${NPM_REG_TOKEN}"
  - npm config set --location=user '//gitlab.com/api/v4/projects/20565764/packages/npm/:_authToken'
    "${NPM_REG_TOKEN}"
  - echo "@fireblocks:registry=https://gitlab.com/api/v4/packages/npm/">>.npmrc
  - echo "//gitlab.com/api/v4/packages/npm/:_authToken=${NPM_REG_TOKEN}">>.npmrc
  - echo "//gitlab.com/api/v4/projects/20565764/packages/npm/:_authToken=${NPM_REG_TOKEN}">>.npmrc
  - yarn global add @fireblocks/fb-cli
  script:
  - echo "Self Service User Guide - https://fireblocks.atlassian.net/wiki/spaces/RD/pages/1413218873/Self+Service+User+Guide"
  - SVC_NAME=$([ "$SERVICE_NAME" ] && echo $SERVICE_NAME || echo $CI_PROJECT_NAME)
  - echo "Verifying deployment folder for ${SVC_NAME} service"
  - git clone ${DESTINATION_REPO} mono_repo
  - cd mono_repo
  - git fetch --all
  - git checkout ${STATE_BRANCH}
  - git pull origin ${STATE_BRANCH} --no-rebase
  - cd ../${SOURCE_PATH}
  - |
    # Define the paths
    values_file="values.yaml"

    # Check for values.yaml in the deployment folder
    if [ ! -f "$values_file" ]; then
        echo "Error: The values.yaml file is missing in the ${SOURCE_PATH} folder."
        exit 1
    fi

    echo "Success: All required files are present"
  - |
    # Directory to check
    DIR_TO_CHECK="overrides/"

    # List of allowed files
    ALLOWED_PATTERN=$(printf "|%s" "nonprod-tier.yaml" "prod-tier.yaml" "iac-dev.yaml" "localstack.yaml" "dev1.yaml" "dev2.yaml" "dev3.yaml" "dev4.yaml" "dev5.yaml" "dev6.yaml" "dev7.yaml" "dev8.yaml" "dev9.yaml" "dev10.yaml" "dev11.yaml" "dev11.yaml" "dev12.yaml" "dev13.yaml" "dev14.yaml" "dev15.yaml" "pre1.yaml" "stage.yaml" "sandbox.yaml" "eu-prod.yaml" "eu2-prod.yaml" "bnym-dev.yaml" "bnym-prod.yaml" "us-prod.yaml" | cut -c 2-)

    # Flag to track if there are disallowed files
    DISALLOWED_FOUND=false

    # Check for files in the directory that are not in the allowed list
    for file in "$DIR_TO_CHECK"/*; do
      # Get the base name of the file
      filename=$(basename "$file")

      # Check if the filename is in the allowed list
      if [[ ! $filename =~ ^($ALLOWED_PATTERN)$ ]]; then
        echo "Disallowed file found: $filename"
        DISALLOWED_FOUND=true
      fi
    done

    # Final output
    if $DISALLOWED_FOUND; then
      echo "Some files are not allowed."
      exit 1
    else
      echo "All files are allowed."
    fi
  - echo "Linting deployment yaml files"
  - cp ../mono_repo/services/schema/*.yaml .
  - cp ../mono_repo/services/schema/appconfig_schema.json .
  - cp ../mono_repo/services/schema/main_appconfig.json appconfig.json
  - cp ../mono_repo/services/schema/yamllint_rules.yaml yamllint_rules.yaml
  - yamllint --list-files **/*.yaml *.yaml
  - yamllint -s **/*.yaml *.yaml -c yamllint_rules.yaml
  - echo "Validating deployment yaml schema"
  - yamale -s base_values_schema.yaml values.yaml
  - yamale -s tier_values_schema.yaml overrides/prod-tier.yaml
  - yamale -s tier_values_schema.yaml overrides/nonprod-tier.yaml
  - |
    # Iterate over all yaml files in the overrides folder
    for file in overrides/*.yaml; do
        # Extract the filename from the path
        filename=$(basename -- "$file")

        # Check if the file is not prod-tier.yaml or nonprod-tier.yaml
        if [[ "$filename" != "prod-tier.yaml" ]] && [[ "$filename" != "nonprod-tier.yaml" ]]; then
            # Run yamale command on the file
            yamale -s env_values_schema.yaml "$file"
        fi
    done
  - "# Iterate over all yaml files in the overrides folder - validate_resources.sh\nif
    [[ -v ENGINE && \"$ENGINE\" == \"argocd\" ]]; then\n  export CD_INFRA_PROJECT_ID=61508954\n
    \ curl --header \"PRIVATE-TOKEN: $CD_CPU_RAM_REQUEST_LIMIT_READ_ONLY\"  \"https://gitlab.com/api/v4/projects/$CD_INFRA_PROJECT_ID/repository/files/ci-infra%2Fscripts%2Fvalidate_resources.sh/raw?ref=main\"
    -o \"$CI_PROJECT_DIR/validate_resources.sh\"\n  echo \"chmod +x $CI_PROJECT_DIR/validate_resources.sh\"
    \n  chmod +x \"$CI_PROJECT_DIR/validate_resources.sh\"\n  echo \"Searching for
    environments values files...\" \n  ENV_FILES_LIST=$(yamllint --list-files **/*.yaml
    *.yaml | grep -vE 'env_values_schema\\.yaml|tier_values_schema\\.yaml|base_values_schema\\.yaml|yamllint_rules\\.yaml|.*prod-tier\\.yaml|values.yaml'
    || true)\n  if [[ -n \"$ENV_FILES_LIST\" ]]; then\n    echo \"Found environments
    values files\"\n    while IFS= read -r file; do\n      filename=$(basename --
    \"$file\")\n      if [[ \"$filename\" =~ ^(dev[1-9]|dev10|stage|pre1).yaml$ ]];
    then\n        tier_file=\"overrides/nonprod-tier.yaml\"\n      else\n        tier_file=\"overrides/prod-tier.yaml\"
    \ \n      fi\n      echo \"values.yaml <-- $tier_file <-- $file\"\n      yq eval-all
    '. as $item ireduce ({}; . * $item)' values.yaml \"$tier_file\" \"$file\" | bash
    \"$CI_PROJECT_DIR/validate_resources.sh\" -\n    done <<< \"$ENV_FILES_LIST\"\n
    \ else\n    echo \"No environments values files were found. Continuing to the
    tier files.\"\n  fi\necho \"values.yaml <-- overrides/nonprod-tier.yaml\"\nyq
    eval-all '. as $item ireduce ({}; . * $item)' values.yaml overrides/nonprod-tier.yaml
    | bash \"$CI_PROJECT_DIR/validate_resources.sh\" -\necho \"values.yaml <-- overrides/prod-tier.yaml\"
    \nyq eval-all '. as $item ireduce ({}; . * $item)' values.yaml overrides/prod-tier.yaml
    | bash \"$CI_PROJECT_DIR/validate_resources.sh\" -\nelse\n  echo \"Skipping resource
    validation: ENGINE is not set to 'argocd'.\"\nfi\n"
  - ajv validate -s appconfig_schema.json -d appconfig.json
  - echo "Resources verified successfully"
  - echo "Validate filter_policy if exists - should be a valid JSON object"
  - fb deployment:validate . --filter-policy
".ld-code-refs":
  stage: test
  before_script:
  - echo "starting"
  image:
    name: launchdarkly/ld-find-code-refs:latest
    entrypoint:
    - ''
  script:
  - ld-find-code-refs --accessToken $LD_ACCESS_TOKEN --projKey $LD_PROJECT_KEY --dir
    $CI_PROJECT_DIR --repoName $CI_PROJECT_NAME --repoUrl $CI_PROJECT_URL --repoType
    gitlab --branch $CI_COMMIT_REF_NAME --updateSequenceId $CI_PIPELINE_IID --userAgent
    gitlab-pipeline
".test":
  image: registry.gitlab.com/fireblocks/shell/infra/images/node-infra-20:latest
  stage: test
  retry: 2
  tags:
  - builders-application-gitlab-runner
  variables:
    COVERAGE_THRESHOLD: '0.8'
    BUILD_ROOT: "/cache/build"
    COVERAGE_TYPE: ut
    FB_COMPONENT_TYPE: service
    FB_COMPONENT_MAIN_LANG: typescript
  script:
  - echo "Uploading gitlab metadata to datadog"
  - npx @datadog/datadog-ci git-metadata upload ;
  - yarn install --production=false --frozen-lockfile
  - yarn build
  - NODE_OPTIONS="-r dd-trace/ci/init" DD_ENV=ci DD_SERVICE=$SERVICE_NAME yarn test
  - export COVERAGE_FILE_PATH="coverage/coverage-summary.json"
  - if [ ! -f $COVERAGE_FILE_PATH ]; then COVERAGE_FILE_PATH=coverage/coverage-final.json;
    fi
  - fb report-coverage-comment $COVERAGE_FILE_PATH || /bin/true
  - UT_COVERAGE=$(egrep -o 'line-rate="[^"]+"' coverage/cobertura-coverage.xml)
  - UT_COVERAGE=$(echo $UT_COVERAGE | awk -F'"' 'NR==1 {print $2}')
  - |
    UT_COVERAGE=$(echo "$UT_COVERAGE" | tr '[:upper:]' '[:lower:]')
    if [[ "$UT_COVERAGE" == "nan" || "$UT_COVERAGE" == "undefined" ]]; then
      UT_COVERAGE=0
    fi
  - echo "unit tests coverage (lines) $UT_COVERAGE"
  - echo "Cloning Remoteblocks's $rbBranch branch"
  - mkdir -p $BUILD_ROOT && cd $BUILD_ROOT
  - rm -fr remoteblocks && git clone --depth 1 --recurse-submodules --shallow-submodules
    -b main https://gitlab-ci-token:${CI_JOB_TOKEN}@gitlab.com/fireblocks/shell/infra/tools/remoteblocks
  - cd $CI_PROJECT_DIR
  - |
    if [ "$IS_PROD_SERVICE" == "false" ] ; then
      echo "service: ${SERVICE_NAME} is in development mode, not reporting coverage"
    else
      echo "service: ${SERVICE_NAME} is in production mode, reporting coverage"
      dog --raw metric post ut_coverage $UT_COVERAGE  --no_host --tags "service:${SERVICE_NAME},env:ci,environment:ci,component:${COMPONENT},git.commit.sha:${CI_COMMIT_SHA},ci.branch:${CI_COMMIT_BRANCH},ci.job.id:${CI_JOB_ID},ci.coverage.type:ut" --type gauge || /bin/true
      npx @datadog/datadog-ci metric --level job --metrics "ut_coverage:${UT_COVERAGE}" || /bin/true
      npx @datadog/datadog-ci metric --level pipeline --metrics "ut_coverage:${UT_COVERAGE}" || /bin/true
      npx @datadog/datadog-ci tag --level job --tags "service:${SERVICE_NAME}" || /bin/true
      npx @datadog/datadog-ci tag --level pipeline --tags "service:${SERVICE_NAME}" || /bin/true
      fb report-coverage ${SERVICE_NAME} --branch=${CI_COMMIT_BRANCH} --ut=${UT_COVERAGE} --artifact="https://fireblocks.gitlab.io/-/shell/services/${CI_PROJECT_NAME}/-/jobs/${CI_JOB_ID}/artifacts/coverage/lcov-report/index.html"
    fi

    IS_OLD_SERVICE=$(jq --arg str $SERVICE_NAME 'contains([$str])' $BUILD_ROOT/remoteblocks/coverage-config/existing-services.json);
    if [ "$(echo "${UT_COVERAGE}<${COVERAGE_THRESHOLD}" | bc)" == "1" ] && [ "$IS_OLD_SERVICE" != "true" ] ; then
      echo "Service $SERVICE_NAME is new and measured test coverage is less than 80%, failing the job, as we require any new service or library to exceed 80% coverage"
      exit 1
    else
      echo "Service $SERVICE_NAME is either old or measured test coverage is greater than 80%, passing the job - good job!"
    fi
  coverage: "/All files[^|]*\\|[^|]*\\s+([\\d\\.]+)/"
  artifacts:
    when: always
    expire_in: 1 yr
    paths:
    - coverage/
    reports:
      metrics: metrics.txt
      junit:
      - "./**/junit.xml"
      - junit.xml
      coverage_report:
        coverage_format: cobertura
        path: coverage/cobertura-coverage.xml
".check-packages":
  stage: test
  variables:
    CONFIG_REPOSITORY_TOKEN: "$COMPONENT_REGISTRY_TOKEN"
  tags:
  - shell-application-gitlab-runner
".default-packages-rules":
  rules:
  - if: "$CI_PIPELINE_SOURCE == 'merge_request_event' && $CI_MERGE_REQUEST_TITLE =~
      /^Draft:/"
    when: manual
    allow_failure: true
  - if: "$CI_PIPELINE_SOURCE == 'merge_request_event' && ($CI_MERGE_REQUEST_TITLE
      =~ /^Hotfix:/ || $CI_MERGE_REQUEST_TITLE =~ /^hotfix:/)"
    when: always
    allow_failure: true
  - if: "$CI_PIPELINE_SOURCE != 'merge_request_event' && ($CI_COMMIT_BRANCH == 'master'
      || $CI_COMMIT_BRANCH == 'main')"
    when: always
    allow_failure: true
".merge-request-verify":
  stage: test
  allow_failure: false
  tags:
  - shell-application-gitlab-runner
  rules:
  - if: "$CI_PIPELINE_SOURCE == 'merge_request_event' && $CI_MERGE_REQUEST_TITLE =~
      /^Draft:/"
    when: manual
  - if: "$CI_PIPELINE_SOURCE == 'merge_request_event'"
    when: always
  - when: never
  retry: 2
  script:
  - fb verify-merge-request "${CI_MERGE_REQUEST_TITLE}"
".update-merge-request":
  stage: test
  allow_failure: true
  tags:
  - shell-application-gitlab-runner
  rules:
  - if: "$CI_PIPELINE_SOURCE == 'merge_request_event' && $SKIP_UPDATE_REQUEST == 'true'"
    when: manual
    allow_failure: true
  - if: "$CI_PIPELINE_SOURCE == 'merge_request_event'"
    when: always
  - when: never
  script:
  - fb update-service-mr ${CI_PROJECT_ID} ${CI_MERGE_REQUEST_IID} ${DEV_WRITE_TOKEN_FOR_MR_DESCRIPTION_UPDATE}
".verify-deployment-folder":
  stage: test
  allow_failure: false
  retry: 2
  tags:
  - shell-application-gitlab-runner
  rules:
  - if: "$CI_PIPELINE_SOURCE == 'merge_request_event' && $CI_MERGE_REQUEST_TITLE =~
      /^Draft:/"
    when: manual
  - if: "$CI_PIPELINE_SOURCE == 'merge_request_event'"
    when: always
  - when: never
  before_script:
  - printf "%s:%s\n" DESTINATION_REPO "$DESTINATION_REPO" DESTINATION_PROJECT_ID "$DESTINATION_PROJECT_ID"
    SOURCE_PATH "$SOURCE_PATH" DESTINATION_PATH "$DESTINATION_PATH" STATE_BRANCH "$STATE_BRANCH"
    GITLAB_API_URL "$GITLAB_API_URL"
  - |
    if [ ! -d "$SOURCE_PATH" ]; then
      echo "$SOURCE_PATH directory does not exist. Exiting job successfully."
      exit 0
    fi
    echo "$SOURCE_PATH directory exists. Continuing with deployment."
  - - apk update
    - apk add curl jq yq py3-pip
    - pip3 install --upgrade pip
    - pip3 install yamllint
    - pip3 install yamale --break-system-packages
    - npm install -g ajv-cli
    - echo "Configuring Git"
    - echo "https://argocd-ci-push:${ARGOCD_GITLAB_ACCESS_TOKEN}@gitlab.com" > ~/.git-credentials
    - git remote set-url origin https://argocd-ci-push:${ARGOCD_GITLAB_ACCESS_TOKEN}@gitlab.com/fireblocks/devops/iac/argocd.git
    - git config --global user.email "devops@fireblocks.com"
    - git config --global user.name "argocd-ci-push"
    - git config --global credential.helper store
    - touch .npmrc
    - npm config set --location=user @fireblocks:registry https://gitlab.com/api/v4/packages/npm/
    - npm config set --location=user '//gitlab.com/api/v4/packages/npm/:_authToken'
      "${NPM_REG_TOKEN}"
    - npm config set --location=user '//gitlab.com/api/v4/projects/20565764/packages/npm/:_authToken'
      "${NPM_REG_TOKEN}"
    - echo "@fireblocks:registry=https://gitlab.com/api/v4/packages/npm/">>.npmrc
    - echo "//gitlab.com/api/v4/packages/npm/:_authToken=${NPM_REG_TOKEN}">>.npmrc
    - echo "//gitlab.com/api/v4/projects/20565764/packages/npm/:_authToken=${NPM_REG_TOKEN}">>.npmrc
    - yarn global add @fireblocks/fb-cli
  script:
  - - echo "Self Service User Guide - https://fireblocks.atlassian.net/wiki/spaces/RD/pages/1413218873/Self+Service+User+Guide"
    - SVC_NAME=$([ "$SERVICE_NAME" ] && echo $SERVICE_NAME || echo $CI_PROJECT_NAME)
    - echo "Verifying deployment folder for ${SVC_NAME} service"
    - git clone ${DESTINATION_REPO} mono_repo
    - cd mono_repo
    - git fetch --all
    - git checkout ${STATE_BRANCH}
    - git pull origin ${STATE_BRANCH} --no-rebase
    - cd ../${SOURCE_PATH}
    - |
      # Define the paths
      values_file="values.yaml"

      # Check for values.yaml in the deployment folder
      if [ ! -f "$values_file" ]; then
          echo "Error: The values.yaml file is missing in the ${SOURCE_PATH} folder."
          exit 1
      fi

      echo "Success: All required files are present"
    - |
      # Directory to check
      DIR_TO_CHECK="overrides/"

      # List of allowed files
      ALLOWED_PATTERN=$(printf "|%s" "nonprod-tier.yaml" "prod-tier.yaml" "iac-dev.yaml" "localstack.yaml" "dev1.yaml" "dev2.yaml" "dev3.yaml" "dev4.yaml" "dev5.yaml" "dev6.yaml" "dev7.yaml" "dev8.yaml" "dev9.yaml" "dev10.yaml" "dev11.yaml" "dev11.yaml" "dev12.yaml" "dev13.yaml" "dev14.yaml" "dev15.yaml" "pre1.yaml" "stage.yaml" "sandbox.yaml" "eu-prod.yaml" "eu2-prod.yaml" "bnym-dev.yaml" "bnym-prod.yaml" "us-prod.yaml" | cut -c 2-)

      # Flag to track if there are disallowed files
      DISALLOWED_FOUND=false

      # Check for files in the directory that are not in the allowed list
      for file in "$DIR_TO_CHECK"/*; do
        # Get the base name of the file
        filename=$(basename "$file")

        # Check if the filename is in the allowed list
        if [[ ! $filename =~ ^($ALLOWED_PATTERN)$ ]]; then
          echo "Disallowed file found: $filename"
          DISALLOWED_FOUND=true
        fi
      done

      # Final output
      if $DISALLOWED_FOUND; then
        echo "Some files are not allowed."
        exit 1
      else
        echo "All files are allowed."
      fi
    - echo "Linting deployment yaml files"
    - cp ../mono_repo/services/schema/*.yaml .
    - cp ../mono_repo/services/schema/appconfig_schema.json .
    - cp ../mono_repo/services/schema/main_appconfig.json appconfig.json
    - cp ../mono_repo/services/schema/yamllint_rules.yaml yamllint_rules.yaml
    - yamllint --list-files **/*.yaml *.yaml
    - yamllint -s **/*.yaml *.yaml -c yamllint_rules.yaml
    - echo "Validating deployment yaml schema"
    - yamale -s base_values_schema.yaml values.yaml
    - yamale -s tier_values_schema.yaml overrides/prod-tier.yaml
    - yamale -s tier_values_schema.yaml overrides/nonprod-tier.yaml
    - |
      # Iterate over all yaml files in the overrides folder
      for file in overrides/*.yaml; do
          # Extract the filename from the path
          filename=$(basename -- "$file")

          # Check if the file is not prod-tier.yaml or nonprod-tier.yaml
          if [[ "$filename" != "prod-tier.yaml" ]] && [[ "$filename" != "nonprod-tier.yaml" ]]; then
              # Run yamale command on the file
              yamale -s env_values_schema.yaml "$file"
          fi
      done
    - "# Iterate over all yaml files in the overrides folder - validate_resources.sh\nif
      [[ -v ENGINE && \"$ENGINE\" == \"argocd\" ]]; then\n  export CD_INFRA_PROJECT_ID=61508954\n
      \ curl --header \"PRIVATE-TOKEN: $CD_CPU_RAM_REQUEST_LIMIT_READ_ONLY\"  \"https://gitlab.com/api/v4/projects/$CD_INFRA_PROJECT_ID/repository/files/ci-infra%2Fscripts%2Fvalidate_resources.sh/raw?ref=main\"
      -o \"$CI_PROJECT_DIR/validate_resources.sh\"\n  echo \"chmod +x $CI_PROJECT_DIR/validate_resources.sh\"
      \n  chmod +x \"$CI_PROJECT_DIR/validate_resources.sh\"\n  echo \"Searching for
      environments values files...\" \n  ENV_FILES_LIST=$(yamllint --list-files **/*.yaml
      *.yaml | grep -vE 'env_values_schema\\.yaml|tier_values_schema\\.yaml|base_values_schema\\.yaml|yamllint_rules\\.yaml|.*prod-tier\\.yaml|values.yaml'
      || true)\n  if [[ -n \"$ENV_FILES_LIST\" ]]; then\n    echo \"Found environments
      values files\"\n    while IFS= read -r file; do\n      filename=$(basename --
      \"$file\")\n      if [[ \"$filename\" =~ ^(dev[1-9]|dev10|stage|pre1).yaml$
      ]]; then\n        tier_file=\"overrides/nonprod-tier.yaml\"\n      else\n        tier_file=\"overrides/prod-tier.yaml\"
      \ \n      fi\n      echo \"values.yaml <-- $tier_file <-- $file\"\n      yq
      eval-all '. as $item ireduce ({}; . * $item)' values.yaml \"$tier_file\" \"$file\"
      | bash \"$CI_PROJECT_DIR/validate_resources.sh\" -\n    done <<< \"$ENV_FILES_LIST\"\n
      \ else\n    echo \"No environments values files were found. Continuing to the
      tier files.\"\n  fi\necho \"values.yaml <-- overrides/nonprod-tier.yaml\"\nyq
      eval-all '. as $item ireduce ({}; . * $item)' values.yaml overrides/nonprod-tier.yaml
      | bash \"$CI_PROJECT_DIR/validate_resources.sh\" -\necho \"values.yaml <-- overrides/prod-tier.yaml\"
      \nyq eval-all '. as $item ireduce ({}; . * $item)' values.yaml overrides/prod-tier.yaml
      | bash \"$CI_PROJECT_DIR/validate_resources.sh\" -\nelse\n  echo \"Skipping
      resource validation: ENGINE is not set to 'argocd'.\"\nfi\n"
    - ajv validate -s appconfig_schema.json -d appconfig.json
    - echo "Resources verified successfully"
    - echo "Validate filter_policy if exists - should be a valid JSON object"
    - fb deployment:validate . --filter-policy
  variables:
    DESTINATION_REPO: https://gitlab.com/fireblocks/devops/iac/argocd.git
    DESTINATION_PROJECT_ID: 50521873
    SOURCE_PATH: deployment
    DESTINATION_PATH: services/shell
    STATE_BRANCH: main
    GITLAB_API_URL: https://gitlab.com/api/v4/projects
".verify-parameters-configurations":
  stage: test
  allow_failure: false
  retry: 2
  tags:
  - shell-application-gitlab-runner
  rules:
  - if: "$CI_PIPELINE_SOURCE == 'merge_request_event' && $CI_MERGE_REQUEST_TITLE =~
      /^Draft:/"
    changes:
    - configurations/**/*.yaml
    when: manual
  - if: "$CI_PIPELINE_SOURCE == 'merge_request_event'"
    changes:
    - configurations/**/*.yaml
    when: always
  - when: never
  script:
  - |
    #!/bin/bash
    git fetch origin $CI_DEFAULT_BRANCH
    git symbolic-ref refs/remotes/origin/HEAD refs/remotes/origin/$CI_DEFAULT_BRANCH
    MODIFIED_FILES=$(git diff --name-only origin/$CI_DEFAULT_BRANCH -- 'configurations/*/parameters.yaml' || true)
    echo "Modified parameters.yaml files:"
    echo "$MODIFIED_FILES"
    # Loop through each found file to process it
    mkdir -v changes
    for FILE in $MODIFIED_FILES; do
      if [ "$FILE" == "configurations/common/parameters.yaml" ]; then
          echo "Skipping common folder"
          continue
      fi
      echo "Processing $FILE"

      # Using git diff to extract lines added to the file in the MR
      ADDED_LINES=$(git diff origin/$CI_DEFAULT_BRANCH -- "$FILE" | grep '^+' | grep -v '+++' | sed 's/^+//' || true)

      # Assuming a simple structure where keys are added at the beginning of the lines
      # This is a simplistic approach and may not accurately reflect complex YAML structures
      echo "Added lines (potential keys) in $FILE:"
      echo "$ADDED_LINES"

      # Extract and echo keys assuming they are at the start of the line followed by a colon
      # This regex looks for lines that start with a word character and followed by a colon,
      # which is a common pattern for keys in YAML files.
      echo "Extracted keys:"
      TRANSFORMED_PATH="${FILE//\//_}".changed_keys
      ADDED_KEYS=$(echo "$ADDED_LINES" | grep -o '^\w\+:' | sed 's/://' || true)
      echo "Added keys:"
      echo "$ADDED_KEYS"
      echo "$ADDED_KEYS" >> changes/$TRANSFORMED_PATH
      cat changes/$TRANSFORMED_PATH
    done
  - ls -R changes
  - echo "Configuring Git"
  - echo "https://argocd-ci-push:${ARGOCD_GITLAB_ACCESS_TOKEN}@gitlab.com" > ~/.git-credentials
  - git remote set-url origin https://argocd-ci-push:${ARGOCD_GITLAB_ACCESS_TOKEN}@gitlab.com/fireblocks/shell/infra/configuration.git
  - git config --global user.email "devops@fireblocks.com"
  - git config --global user.name "argocd-ci-push"
  - git config --global credential.helper store
  - git clone https://gitlab.com/fireblocks/shell/infra/configuration.git
  - fb verify-parameters-configurations ./configurations ./changes ./configuration/configurations
".datadog-apm-verification":
  stage: test
  allow_failure: true
  retry: 2
  tags:
  - shell-application-gitlab-runner
  rules:
  - if: "$CI_PIPELINE_SOURCE != 'merge_request_event' && ($CI_COMMIT_BRANCH == 'master'
      || $CI_COMMIT_BRANCH == 'main')"
    when: always
  - when: never
  script:
  - |
    if [ -z "${DATADOG_API_KEY}" ]; then
      echo "no datadog api key set" ;
    else
      fb verify-datadog-apm "${DATADOG_SERVICE}" "${DATADOG_ENV}" ;
    fi
  after_script:
  - "if [[ $CI_JOB_STATUS == 'failed' && $GITLAB_USER_EMAIL ]]; then\n  fb notify-user
    $SLACK_MESSENGER_ACCESS_TOKEN $GITLAB_USER_EMAIL \"You don't have datadog APM
    integration in your service $DATADOG_SERVICE. Please add datadog to your service
    in prod-us or validate with the SRE team https://fireblocks.atlassian.net/wiki/spaces/RD/pages/1165232166/Add+datadog+APM+to+your+service
    <$CI_JOB_URL|failure>\" \nelif [[ $GITLAB_USER_EMAIL ]]; then\n  echo \"ok\" \nfi\n"
".hotfix-verifications":
  stage: test
  allow_failure: false
  retry: 2
  tags:
  - shell-application-gitlab-runner
  rules:
  - if: "$CI_PIPELINE_SOURCE == 'merge_request_event' && ($CI_MERGE_REQUEST_TITLE
      =~ /^Hotfix:/ || $CI_MERGE_REQUEST_TITLE =~ /^hotfix:/)"
    when: always
  - when: never
  script:
  - fb verify-hotfix-mr
".npm-package-dependencies-scanner":
  image: socketdev/cli:0.0.95
  stage: test
  allow_failure: true
  retry: 2
  tags:
  - shell-application-gitlab-runner
  rules:
  - if: "$CI_PIPELINE_SOURCE == 'merge_request_event' && $CI_MERGE_REQUEST_TITLE =~
      /^Draft:/"
    changes:
    - package.json
    - package-lock.json
    - yarn.lock
    when: manual
  - if: "$CI_PIPELINE_SOURCE == 'merge_request_event'"
    changes:
    - package.json
    - package-lock.json
    - yarn.lock
    when: always
  - when: never
  script:
  - socketcli --repo $CI_PROJECT_NAME --branch $(if [ -z $CI_MERGE_REQUEST_SOURCE_BRANCH_NAME
    ]; then echo "$CI_COMMIT_BRANCH"; else echo "$CI_MERGE_REQUEST_SOURCE_BRANCH_NAME";
    fi) --target_path $CI_PROJECT_DIR --committer "$(echo $CI_COMMIT_AUTHOR | awk
    -F '<' '{print $2}' | head -c -2)" --commit_message "$CI_COMMIT_MESSAGE" --pr_number
    $(if [ -z $CI_MERGE_REQUEST_IID ]; then echo 0; else echo $CI_MERGE_REQUEST_IID
    ; fi) --scm gitlab $(if [ "$CI_DEFAULT_BRANCH" == "$CI_COMMIT_BRANCH" ] || [ "$CI_DEFAULT_BRANCH"
    == "$CI_COMMIT_REF_NAME" ]; then echo --default_branch; fi) --disable-overview
  variables:
    SOCKET_ORG_ID: 84943
    GITLAB_TOKEN: "${SOCKET_CI_INFRA_TOKEN}"
test:
  image: registry.gitlab.com/fireblocks/shell/infra/images/node-infra-20:latest
  stage: test
  retry: 2
  tags:
  - builders-application-gitlab-runner
  variables:
    COVERAGE_THRESHOLD: '0.8'
    BUILD_ROOT: "/cache/build"
    COVERAGE_TYPE: ut
    FB_COMPONENT_TYPE: service
    FB_COMPONENT_MAIN_LANG: typescript
  script:
  - echo "Uploading gitlab metadata to datadog"
  - npx @datadog/datadog-ci git-metadata upload ;
  - yarn install --production=false --frozen-lockfile
  - yarn build
  - NODE_OPTIONS="-r dd-trace/ci/init" DD_ENV=ci DD_SERVICE=$SERVICE_NAME yarn test
  - export COVERAGE_FILE_PATH="coverage/coverage-summary.json"
  - if [ ! -f $COVERAGE_FILE_PATH ]; then COVERAGE_FILE_PATH=coverage/coverage-final.json;
    fi
  - fb report-coverage-comment $COVERAGE_FILE_PATH || /bin/true
  - UT_COVERAGE=$(egrep -o 'line-rate="[^"]+"' coverage/cobertura-coverage.xml)
  - UT_COVERAGE=$(echo $UT_COVERAGE | awk -F'"' 'NR==1 {print $2}')
  - |
    UT_COVERAGE=$(echo "$UT_COVERAGE" | tr '[:upper:]' '[:lower:]')
    if [[ "$UT_COVERAGE" == "nan" || "$UT_COVERAGE" == "undefined" ]]; then
      UT_COVERAGE=0
    fi
  - echo "unit tests coverage (lines) $UT_COVERAGE"
  - echo "Cloning Remoteblocks's $rbBranch branch"
  - mkdir -p $BUILD_ROOT && cd $BUILD_ROOT
  - rm -fr remoteblocks && git clone --depth 1 --recurse-submodules --shallow-submodules
    -b main https://gitlab-ci-token:${CI_JOB_TOKEN}@gitlab.com/fireblocks/shell/infra/tools/remoteblocks
  - cd $CI_PROJECT_DIR
  - |
    if [ "$IS_PROD_SERVICE" == "false" ] ; then
      echo "service: ${SERVICE_NAME} is in development mode, not reporting coverage"
    else
      echo "service: ${SERVICE_NAME} is in production mode, reporting coverage"
      dog --raw metric post ut_coverage $UT_COVERAGE  --no_host --tags "service:${SERVICE_NAME},env:ci,environment:ci,component:${COMPONENT},git.commit.sha:${CI_COMMIT_SHA},ci.branch:${CI_COMMIT_BRANCH},ci.job.id:${CI_JOB_ID},ci.coverage.type:ut" --type gauge || /bin/true
      npx @datadog/datadog-ci metric --level job --metrics "ut_coverage:${UT_COVERAGE}" || /bin/true
      npx @datadog/datadog-ci metric --level pipeline --metrics "ut_coverage:${UT_COVERAGE}" || /bin/true
      npx @datadog/datadog-ci tag --level job --tags "service:${SERVICE_NAME}" || /bin/true
      npx @datadog/datadog-ci tag --level pipeline --tags "service:${SERVICE_NAME}" || /bin/true
      fb report-coverage ${SERVICE_NAME} --branch=${CI_COMMIT_BRANCH} --ut=${UT_COVERAGE} --artifact="https://fireblocks.gitlab.io/-/shell/services/${CI_PROJECT_NAME}/-/jobs/${CI_JOB_ID}/artifacts/coverage/lcov-report/index.html"
    fi

    IS_OLD_SERVICE=$(jq --arg str $SERVICE_NAME 'contains([$str])' $BUILD_ROOT/remoteblocks/coverage-config/existing-services.json);
    if [ "$(echo "${UT_COVERAGE}<${COVERAGE_THRESHOLD}" | bc)" == "1" ] && [ "$IS_OLD_SERVICE" != "true" ] ; then
      echo "Service $SERVICE_NAME is new and measured test coverage is less than 80%, failing the job, as we require any new service or library to exceed 80% coverage"
      exit 1
    else
      echo "Service $SERVICE_NAME is either old or measured test coverage is greater than 80%, passing the job - good job!"
    fi
  coverage: "/All files[^|]*\\|[^|]*\\s+([\\d\\.]+)/"
  artifacts:
    when: always
    expire_in: 1 yr
    paths:
    - coverage/
    reports:
      metrics:
      - metrics.txt
      junit:
      - "./**/junit.xml"
      - junit.xml
      coverage_report:
        coverage_format: cobertura
        path: coverage/cobertura-coverage.xml
  extends: ".test"
  rules:
  - if: "( $CI_PIPELINE_SOURCE == 'merge_request_event' && $CI_MERGE_REQUEST_TITLE
      =~ /^Draft:/ ) ||  ( $CI_PIPELINE_SOURCE == 'merge_request_event' && $SKIP_TEST
      == 'true' )"
    when: manual
    allow_failure: false
  - if: "$CI_PIPELINE_SOURCE == 'merge_request_event' && ($CI_MERGE_REQUEST_TITLE
      =~ /^Hotfix:/ || $CI_MERGE_REQUEST_TITLE =~ /^hotfix:/)"
    when: always
    allow_failure: true
  - if: "$CI_PIPELINE_SOURCE == 'merge_request_event'"
    when: always
    allow_failure: false
  - if: $CI_COMMIT_BRANCH == "master" || $CI_COMMIT_BRANCH == "main"
    when: always
    allow_failure: false
  - when: never
check-deprecated-packages:
  stage: test
  variables:
    CONFIG_REPOSITORY_TOKEN: "$COMPONENT_REGISTRY_TOKEN"
  tags:
  - shell-application-gitlab-runner
  extends: ".check-packages"
  script:
  - yarn install --production=false --frozen-lockfile
  - |
    if [ "$CI_COMMIT_BRANCH" = "master" ] || [ "$CI_COMMIT_BRANCH" = "main" ]; then
      fb validate-deprecated-packages --ci --gitlabToken=$CONFIG_REPOSITORY_TOKEN --service=$SERVICE_NAME --report --nested
    else
      fb validate-deprecated-packages --ci --gitlabToken=$CONFIG_REPOSITORY_TOKEN --service=$SERVICE_NAME --nested
    fi
  rules:
  - - if: "$CI_PIPELINE_SOURCE == 'merge_request_event' && $CI_MERGE_REQUEST_TITLE
        =~ /^Draft:/"
      when: manual
      allow_failure: true
    - if: "$CI_PIPELINE_SOURCE == 'merge_request_event' && ($CI_MERGE_REQUEST_TITLE
        =~ /^Hotfix:/ || $CI_MERGE_REQUEST_TITLE =~ /^hotfix:/)"
      when: always
      allow_failure: true
    - if: "$CI_PIPELINE_SOURCE != 'merge_request_event' && ($CI_COMMIT_BRANCH == 'master'
        || $CI_COMMIT_BRANCH == 'main')"
      when: always
      allow_failure: true
  - if: "$CI_PIPELINE_SOURCE == 'merge_request_event' && $SKIP_CHECK_DEPRECATED_PACKAGES
      == 'true'"
    when: manual
    allow_failure: true
  - if: "$CI_PIPELINE_SOURCE == 'merge_request_event'"
    when: always
    allow_failure: true
  - when: never
check-forbidden-packages:
  stage: test
  variables:
    CONFIG_REPOSITORY_TOKEN: "$COMPONENT_REGISTRY_TOKEN"
  tags:
  - shell-application-gitlab-runner
  extends: ".check-packages"
  script:
  - yarn install --production=false --frozen-lockfile
  - |
    if [ "$CI_COMMIT_BRANCH" = "master" ] || [ "$CI_COMMIT_BRANCH" = "main" ]; then
      fb validate-forbidden-packages --ci --gitlabToken=$CONFIG_REPOSITORY_TOKEN --service=$SERVICE_NAME --report --nested
    else
      fb validate-forbidden-packages --ci --gitlabToken=$CONFIG_REPOSITORY_TOKEN --service=$SERVICE_NAME --nested
    fi
  rules:
  - - if: "$CI_PIPELINE_SOURCE == 'merge_request_event' && $CI_MERGE_REQUEST_TITLE
        =~ /^Draft:/"
      when: manual
      allow_failure: true
    - if: "$CI_PIPELINE_SOURCE == 'merge_request_event' && ($CI_MERGE_REQUEST_TITLE
        =~ /^Hotfix:/ || $CI_MERGE_REQUEST_TITLE =~ /^hotfix:/)"
      when: always
      allow_failure: true
    - if: "$CI_PIPELINE_SOURCE != 'merge_request_event' && ($CI_COMMIT_BRANCH == 'master'
        || $CI_COMMIT_BRANCH == 'main')"
      when: always
      allow_failure: true
  - if: "$CI_PIPELINE_SOURCE == 'merge_request_event' && $SKIP_CHECK_FORBIDDEN_PACKAGES
      == 'true'"
    when: manual
    allow_failure: true
  - if: "$CI_PIPELINE_SOURCE == 'merge_request_event'"
    when: always
    allow_failure: false
  - when: never
check-yarn-problems:
  stage: test
  variables:
    CONFIG_REPOSITORY_TOKEN: "$COMPONENT_REGISTRY_TOKEN"
  tags:
  - shell-application-gitlab-runner
  extends: ".check-packages"
  script:
  - fb validate-yarn-lock
  rules:
  - - if: "$CI_PIPELINE_SOURCE == 'merge_request_event' && $CI_MERGE_REQUEST_TITLE
        =~ /^Draft:/"
      when: manual
      allow_failure: true
    - if: "$CI_PIPELINE_SOURCE == 'merge_request_event' && ($CI_MERGE_REQUEST_TITLE
        =~ /^Hotfix:/ || $CI_MERGE_REQUEST_TITLE =~ /^hotfix:/)"
      when: always
      allow_failure: true
    - if: "$CI_PIPELINE_SOURCE != 'merge_request_event' && ($CI_COMMIT_BRANCH == 'master'
        || $CI_COMMIT_BRANCH == 'main')"
      when: always
      allow_failure: true
  - if: "$CI_PIPELINE_SOURCE == 'merge_request_event' && $SKIP_CHECK_YARN_PROBLEMS
      == 'true'"
    when: manual
    allow_failure: true
  - if: "$CI_PIPELINE_SOURCE == 'merge_request_event'"
    when: always
    allow_failure: true
  - when: never
snyk:
  stage: test
  retry: 2
  tags:
  - shell-application-gitlab-runner
  rules:
  - if: "$CI_PIPELINE_SOURCE == 'merge_request_event' && $CI_MERGE_REQUEST_TITLE =~
      /^Draft:/"
    when: manual
    allow_failure: true
    changes:
    - package.json
    - yarn.lock
  - if: "$CI_PIPELINE_SOURCE == 'merge_request_event' && ($CI_MERGE_REQUEST_TITLE
      =~ /^Hotfix:/ || $CI_MERGE_REQUEST_TITLE =~ /^hotfix:/)"
    when: always
    allow_failure: true
    changes:
    - package.json
    - yarn.lock
  - if: $CI_PIPELINE_SOURCE == "merge_request_event"
    when: always
    allow_failure: true
    changes:
    - package.json
    - yarn.lock
  script:
  - yarn global add snyk@1.1044.0
  - snyk auth $SNYK_AUTH_TOKEN
  - snyk test --fail-on=all --severity-threshold=critical
apiiro:
  stage: test
  retry: 2
  allow_failure: true
  timeout: 7 minutes
  tags:
  - shell-application-gitlab-runner
  rules:
  - when: never
  script:
  - |
    REPO_URL=https://gitlab.com/$(echo $CI_PROJECT_DIR | sed 's|/builds/||')
    echo $REPO_URL
    echo $CI_COMMIT_SHA
    generate_data_payload()
    {
      cat <<EOF
    {
      "CommitSha": "$CI_COMMIT_SHA",
      "RepositoryUrl": "$REPO_URL"
    }
    EOF
    }
    curl -v https://app.apiiro.com/api/external/accessTokens/validate --header "Authorization: Bearer $APIIRO_API_TOKEN"
    return_string=`curl -vv --location --insecure --request POST 'https://app.apiiro.com/rest-api/v1/BuildScan/builds' \
          --data "$(generate_data_payload)" \
          -H "Authorization: Bearer $APIIRO_API_TOKEN" \
          -H "Content-Type: application/json" || exit 0`

    curl -vv --insecure --retry 15 --retry-max-time 900 --retry-delay 30 --location --request GET "https://app.apiiro.com/rest-api/v1/BuildScan/$return_string/results" \
    -H "Authorization: Bearer $APIIRO_API_TOKEN" \
    -H 'Content-Type: text/plain' || exit 0
ld-code-refs:
  stage: test
  before_script:
  - echo "starting"
  image:
    name: launchdarkly/ld-find-code-refs:latest
    entrypoint:
    - ''
  script:
  - ld-find-code-refs --accessToken $LD_ACCESS_TOKEN --projKey $LD_PROJECT_KEY --dir
    $CI_PROJECT_DIR --repoName $CI_PROJECT_NAME --repoUrl $CI_PROJECT_URL --repoType
    gitlab --branch $CI_COMMIT_REF_NAME --updateSequenceId $CI_PIPELINE_IID --userAgent
    gitlab-pipeline
  allow_failure: true
  retry: 2
  tags:
  - shell-application-gitlab-runner
  rules:
  - if: "$CI_PIPELINE_SOURCE != 'merge_request_event' && ($CI_COMMIT_BRANCH == 'master'
      || $CI_COMMIT_BRANCH == 'main')"
    when: always
  - when: never
  extends: ".ld-code-refs"
veracode-pipeline-scan:
  tags:
  - shell-application-gitlab-runner
  retry: 2
  script:
  - |
    apk add zip curl openjdk11
    zip -r $PACKAGE_NAME . -x *test.ts -x wait -x test.js -x spec.ts -x *.pl -x *.sql
    curl -O https://downloads.veracode.com/securityscan/pipeline-scan-LATEST.zip
    unzip pipeline-scan-LATEST.zip pipeline-scan.jar
    java -jar pipeline-scan.jar \
        -vid $VERACODE_API_ID \
        -vkey $VERACODE_API_KEY \
        --file $PACKAGE_NAME \
        -fs 'Very High, High'
  rules:
  - if: $IS_PROD_SERVICE != "true"
    when: never
  - if: "$CI_PIPELINE_SOURCE == 'merge_request_event' && $CI_MERGE_REQUEST_TITLE =~
      /^Draft:/"
    when: manual
  - if: "$CI_COMMIT_TAG"
    when: never
  - if: ($CI_COMMIT_BRANCH == "master" || $CI_COMMIT_BRANCH == "main") && ($VERACODE_APPLICATION
      != null)
    when: always
  extends: ".veracode-pipeline-scan"
  stage: test
  allow_failure: true
veracode-sandbox-scan:
  tags:
  - shell-application-gitlab-runner
  retry: 2
  script:
  - "apk add zip openjdk11\nzip -r $PACKAGE_NAME . -x *test.ts -x wait -x test.js
    -x spec.ts -x *.pl -x *.sql\nwget \"https://repo1.maven.org/maven2/com/veracode/vosp/api/wrappers/vosp-api-wrappers-java/19.2.5.6/vosp-api-wrappers-java-19.2.5.6.jar\"
    -O VeracodeJavaAPI.jar\njava -jar VeracodeJavaAPI.jar \\\n  -vid ${VERACODE_API_ID}
    \\\n  -vkey ${VERACODE_API_KEY} \\\n  -action uploadandscan \\\n  -appname $VERACODE_APPLICATION
    \\\n  -createprofile false \\\n  -version \"$VERACODE_APPLICATION-$RANDOM$RANDOM\"
    \\\n  -filepath $PACKAGE_NAME \\\n  -selected true \\\n  -sandboxname $CI_PROJECT_NAME
    \\\n  -createsandbox\ttrue \\\n  -scanallnonfataltoplevelmodules true \\\n"
  rules:
  - if: ($CI_COMMIT_BRANCH == "master" || $CI_COMMIT_BRANCH == "main") && ($VERACODE_APPLICATION
      != null)
    when: always
  - when: never
  extends: ".veracode-sandbox-scan"
  stage: test
  allow_failure: true
merge-request-verify:
  stage: test
  allow_failure: false
  tags:
  - shell-application-gitlab-runner
  rules:
  - if: "$CI_PIPELINE_SOURCE == 'merge_request_event' && $CI_MERGE_REQUEST_TITLE =~
      /^Draft:/"
    when: manual
  - if: "$CI_PIPELINE_SOURCE == 'merge_request_event'"
    when: always
  - when: never
  retry: 2
  script:
  - fb verify-merge-request "${CI_MERGE_REQUEST_TITLE}"
  extends: ".merge-request-verify"
verify-deployment-folder:
  stage: test
  allow_failure: false
  retry: 2
  tags:
  - shell-application-gitlab-runner
  rules:
  - if: "$CI_PIPELINE_SOURCE == 'merge_request_event' && $CI_MERGE_REQUEST_TITLE =~
      /^Draft:/"
    when: manual
  - if: "$CI_PIPELINE_SOURCE == 'merge_request_event'"
    when: always
  - when: never
  before_script:
  - printf "%s:%s\n" DESTINATION_REPO "$DESTINATION_REPO" DESTINATION_PROJECT_ID "$DESTINATION_PROJECT_ID"
    SOURCE_PATH "$SOURCE_PATH" DESTINATION_PATH "$DESTINATION_PATH" STATE_BRANCH "$STATE_BRANCH"
    GITLAB_API_URL "$GITLAB_API_URL"
  - |
    if [ ! -d "$SOURCE_PATH" ]; then
      echo "$SOURCE_PATH directory does not exist. Exiting job successfully."
      exit 0
    fi
    echo "$SOURCE_PATH directory exists. Continuing with deployment."
  - - apk update
    - apk add curl jq yq py3-pip
    - pip3 install --upgrade pip
    - pip3 install yamllint
    - pip3 install yamale --break-system-packages
    - npm install -g ajv-cli
    - echo "Configuring Git"
    - echo "https://argocd-ci-push:${ARGOCD_GITLAB_ACCESS_TOKEN}@gitlab.com" > ~/.git-credentials
    - git remote set-url origin https://argocd-ci-push:${ARGOCD_GITLAB_ACCESS_TOKEN}@gitlab.com/fireblocks/devops/iac/argocd.git
    - git config --global user.email "devops@fireblocks.com"
    - git config --global user.name "argocd-ci-push"
    - git config --global credential.helper store
    - touch .npmrc
    - npm config set --location=user @fireblocks:registry https://gitlab.com/api/v4/packages/npm/
    - npm config set --location=user '//gitlab.com/api/v4/packages/npm/:_authToken'
      "${NPM_REG_TOKEN}"
    - npm config set --location=user '//gitlab.com/api/v4/projects/20565764/packages/npm/:_authToken'
      "${NPM_REG_TOKEN}"
    - echo "@fireblocks:registry=https://gitlab.com/api/v4/packages/npm/">>.npmrc
    - echo "//gitlab.com/api/v4/packages/npm/:_authToken=${NPM_REG_TOKEN}">>.npmrc
    - echo "//gitlab.com/api/v4/projects/20565764/packages/npm/:_authToken=${NPM_REG_TOKEN}">>.npmrc
    - yarn global add @fireblocks/fb-cli
  script:
  - - echo "Self Service User Guide - https://fireblocks.atlassian.net/wiki/spaces/RD/pages/1413218873/Self+Service+User+Guide"
    - SVC_NAME=$([ "$SERVICE_NAME" ] && echo $SERVICE_NAME || echo $CI_PROJECT_NAME)
    - echo "Verifying deployment folder for ${SVC_NAME} service"
    - git clone ${DESTINATION_REPO} mono_repo
    - cd mono_repo
    - git fetch --all
    - git checkout ${STATE_BRANCH}
    - git pull origin ${STATE_BRANCH} --no-rebase
    - cd ../${SOURCE_PATH}
    - |
      # Define the paths
      values_file="values.yaml"

      # Check for values.yaml in the deployment folder
      if [ ! -f "$values_file" ]; then
          echo "Error: The values.yaml file is missing in the ${SOURCE_PATH} folder."
          exit 1
      fi

      echo "Success: All required files are present"
    - |
      # Directory to check
      DIR_TO_CHECK="overrides/"

      # List of allowed files
      ALLOWED_PATTERN=$(printf "|%s" "nonprod-tier.yaml" "prod-tier.yaml" "iac-dev.yaml" "localstack.yaml" "dev1.yaml" "dev2.yaml" "dev3.yaml" "dev4.yaml" "dev5.yaml" "dev6.yaml" "dev7.yaml" "dev8.yaml" "dev9.yaml" "dev10.yaml" "dev11.yaml" "dev11.yaml" "dev12.yaml" "dev13.yaml" "dev14.yaml" "dev15.yaml" "pre1.yaml" "stage.yaml" "sandbox.yaml" "eu-prod.yaml" "eu2-prod.yaml" "bnym-dev.yaml" "bnym-prod.yaml" "us-prod.yaml" | cut -c 2-)

      # Flag to track if there are disallowed files
      DISALLOWED_FOUND=false

      # Check for files in the directory that are not in the allowed list
      for file in "$DIR_TO_CHECK"/*; do
        # Get the base name of the file
        filename=$(basename "$file")

        # Check if the filename is in the allowed list
        if [[ ! $filename =~ ^($ALLOWED_PATTERN)$ ]]; then
          echo "Disallowed file found: $filename"
          DISALLOWED_FOUND=true
        fi
      done

      # Final output
      if $DISALLOWED_FOUND; then
        echo "Some files are not allowed."
        exit 1
      else
        echo "All files are allowed."
      fi
    - echo "Linting deployment yaml files"
    - cp ../mono_repo/services/schema/*.yaml .
    - cp ../mono_repo/services/schema/appconfig_schema.json .
    - cp ../mono_repo/services/schema/main_appconfig.json appconfig.json
    - cp ../mono_repo/services/schema/yamllint_rules.yaml yamllint_rules.yaml
    - yamllint --list-files **/*.yaml *.yaml
    - yamllint -s **/*.yaml *.yaml -c yamllint_rules.yaml
    - echo "Validating deployment yaml schema"
    - yamale -s base_values_schema.yaml values.yaml
    - yamale -s tier_values_schema.yaml overrides/prod-tier.yaml
    - yamale -s tier_values_schema.yaml overrides/nonprod-tier.yaml
    - |
      # Iterate over all yaml files in the overrides folder
      for file in overrides/*.yaml; do
          # Extract the filename from the path
          filename=$(basename -- "$file")

          # Check if the file is not prod-tier.yaml or nonprod-tier.yaml
          if [[ "$filename" != "prod-tier.yaml" ]] && [[ "$filename" != "nonprod-tier.yaml" ]]; then
              # Run yamale command on the file
              yamale -s env_values_schema.yaml "$file"
          fi
      done
    - "# Iterate over all yaml files in the overrides folder - validate_resources.sh\nif
      [[ -v ENGINE && \"$ENGINE\" == \"argocd\" ]]; then\n  export CD_INFRA_PROJECT_ID=61508954\n
      \ curl --header \"PRIVATE-TOKEN: $CD_CPU_RAM_REQUEST_LIMIT_READ_ONLY\"  \"https://gitlab.com/api/v4/projects/$CD_INFRA_PROJECT_ID/repository/files/ci-infra%2Fscripts%2Fvalidate_resources.sh/raw?ref=main\"
      -o \"$CI_PROJECT_DIR/validate_resources.sh\"\n  echo \"chmod +x $CI_PROJECT_DIR/validate_resources.sh\"
      \n  chmod +x \"$CI_PROJECT_DIR/validate_resources.sh\"\n  echo \"Searching for
      environments values files...\" \n  ENV_FILES_LIST=$(yamllint --list-files **/*.yaml
      *.yaml | grep -vE 'env_values_schema\\.yaml|tier_values_schema\\.yaml|base_values_schema\\.yaml|yamllint_rules\\.yaml|.*prod-tier\\.yaml|values.yaml'
      || true)\n  if [[ -n \"$ENV_FILES_LIST\" ]]; then\n    echo \"Found environments
      values files\"\n    while IFS= read -r file; do\n      filename=$(basename --
      \"$file\")\n      if [[ \"$filename\" =~ ^(dev[1-9]|dev10|stage|pre1).yaml$
      ]]; then\n        tier_file=\"overrides/nonprod-tier.yaml\"\n      else\n        tier_file=\"overrides/prod-tier.yaml\"
      \ \n      fi\n      echo \"values.yaml <-- $tier_file <-- $file\"\n      yq
      eval-all '. as $item ireduce ({}; . * $item)' values.yaml \"$tier_file\" \"$file\"
      | bash \"$CI_PROJECT_DIR/validate_resources.sh\" -\n    done <<< \"$ENV_FILES_LIST\"\n
      \ else\n    echo \"No environments values files were found. Continuing to the
      tier files.\"\n  fi\necho \"values.yaml <-- overrides/nonprod-tier.yaml\"\nyq
      eval-all '. as $item ireduce ({}; . * $item)' values.yaml overrides/nonprod-tier.yaml
      | bash \"$CI_PROJECT_DIR/validate_resources.sh\" -\necho \"values.yaml <-- overrides/prod-tier.yaml\"
      \nyq eval-all '. as $item ireduce ({}; . * $item)' values.yaml overrides/prod-tier.yaml
      | bash \"$CI_PROJECT_DIR/validate_resources.sh\" -\nelse\n  echo \"Skipping
      resource validation: ENGINE is not set to 'argocd'.\"\nfi\n"
    - ajv validate -s appconfig_schema.json -d appconfig.json
    - echo "Resources verified successfully"
    - echo "Validate filter_policy if exists - should be a valid JSON object"
    - fb deployment:validate . --filter-policy
  variables:
    DESTINATION_REPO: https://gitlab.com/fireblocks/devops/iac/argocd.git
    DESTINATION_PROJECT_ID: 50521873
    SOURCE_PATH: deployment
    DESTINATION_PATH: services/shell
    STATE_BRANCH: main
    GITLAB_API_URL: https://gitlab.com/api/v4/projects
  extends: ".verify-deployment-folder"
verify-parameters-configurations:
  stage: test
  allow_failure: false
  retry: 2
  tags:
  - shell-application-gitlab-runner
  rules:
  - if: "$CI_PIPELINE_SOURCE == 'merge_request_event' && $CI_MERGE_REQUEST_TITLE =~
      /^Draft:/"
    changes:
    - configurations/**/*.yaml
    when: manual
  - if: "$CI_PIPELINE_SOURCE == 'merge_request_event'"
    changes:
    - configurations/**/*.yaml
    when: always
  - when: never
  script:
  - |
    #!/bin/bash
    git fetch origin $CI_DEFAULT_BRANCH
    git symbolic-ref refs/remotes/origin/HEAD refs/remotes/origin/$CI_DEFAULT_BRANCH
    MODIFIED_FILES=$(git diff --name-only origin/$CI_DEFAULT_BRANCH -- 'configurations/*/parameters.yaml' || true)
    echo "Modified parameters.yaml files:"
    echo "$MODIFIED_FILES"
    # Loop through each found file to process it
    mkdir -v changes
    for FILE in $MODIFIED_FILES; do
      if [ "$FILE" == "configurations/common/parameters.yaml" ]; then
          echo "Skipping common folder"
          continue
      fi
      echo "Processing $FILE"

      # Using git diff to extract lines added to the file in the MR
      ADDED_LINES=$(git diff origin/$CI_DEFAULT_BRANCH -- "$FILE" | grep '^+' | grep -v '+++' | sed 's/^+//' || true)

      # Assuming a simple structure where keys are added at the beginning of the lines
      # This is a simplistic approach and may not accurately reflect complex YAML structures
      echo "Added lines (potential keys) in $FILE:"
      echo "$ADDED_LINES"

      # Extract and echo keys assuming they are at the start of the line followed by a colon
      # This regex looks for lines that start with a word character and followed by a colon,
      # which is a common pattern for keys in YAML files.
      echo "Extracted keys:"
      TRANSFORMED_PATH="${FILE//\//_}".changed_keys
      ADDED_KEYS=$(echo "$ADDED_LINES" | grep -o '^\w\+:' | sed 's/://' || true)
      echo "Added keys:"
      echo "$ADDED_KEYS"
      echo "$ADDED_KEYS" >> changes/$TRANSFORMED_PATH
      cat changes/$TRANSFORMED_PATH
    done
  - ls -R changes
  - echo "Configuring Git"
  - echo "https://argocd-ci-push:${ARGOCD_GITLAB_ACCESS_TOKEN}@gitlab.com" > ~/.git-credentials
  - git remote set-url origin https://argocd-ci-push:${ARGOCD_GITLAB_ACCESS_TOKEN}@gitlab.com/fireblocks/shell/infra/configuration.git
  - git config --global user.email "devops@fireblocks.com"
  - git config --global user.name "argocd-ci-push"
  - git config --global credential.helper store
  - git clone https://gitlab.com/fireblocks/shell/infra/configuration.git
  - fb verify-parameters-configurations ./configurations ./changes ./configuration/configurations
  extends: ".verify-parameters-configurations"
update-merge-request:
  stage: test
  allow_failure: true
  tags:
  - shell-application-gitlab-runner
  rules:
  - if: "$CI_PIPELINE_SOURCE == 'merge_request_event' && $SKIP_UPDATE_REQUEST == 'true'"
    when: manual
    allow_failure: true
  - if: "$CI_PIPELINE_SOURCE == 'merge_request_event'"
    when: always
  - when: never
  script:
  - fb update-service-mr ${CI_PROJECT_ID} ${CI_MERGE_REQUEST_IID} ${DEV_WRITE_TOKEN_FOR_MR_DESCRIPTION_UPDATE}
  extends: ".update-merge-request"
verify-checklist-items:
  stage: test
  allow_failure: false
  retry: 2
  tags:
  - shell-application-gitlab-runner
  rules:
  - if: "$CI_COMMIT_REF_NAME =~ /^renovate/"
    when: never
  - if: "$ENFORCE_CHECKLIST && $CI_PIPELINE_SOURCE == 'merge_request_event' && $CI_MERGE_REQUEST_TITLE
      =~ /^Draft:/"
    when: manual
  - if: "$ENFORCE_CHECKLIST && $CI_PIPELINE_SOURCE == 'merge_request_event'"
    when: always
  - when: never
  script:
  - fb verify-completed-tasks "${CI_PROJECT_ID}" "${CI_MERGE_REQUEST_IID}" "${CI_INFRA_READ_TOKEN}"
hotfix-verifications:
  stage: test
  allow_failure: false
  retry: 2
  tags:
  - shell-application-gitlab-runner
  rules:
  - if: "$CI_PIPELINE_SOURCE == 'merge_request_event' && ($CI_MERGE_REQUEST_TITLE
      =~ /^Hotfix:/ || $CI_MERGE_REQUEST_TITLE =~ /^hotfix:/)"
    when: always
  - when: never
  script:
  - fb verify-hotfix-mr
  extends: ".hotfix-verifications"
verify-component-registry:
  stage: test
  allow_failure: true
  retry: 2
  tags:
  - shell-application-gitlab-runner
  rules:
  - if: $IS_PROD_SERVICE != "true"
    when: never
  - if: $CI_PROJECT_ID == "27398709"
    when: never
  - if: "$CI_PIPELINE_SOURCE == 'merge_request_event' && $CI_MERGE_REQUEST_TITLE =~
      /^Draft:/"
    when: manual
  - if: "$CI_PIPELINE_SOURCE == 'merge_request_event'"
    when: always
  - if: $CI_COMMIT_BRANCH == "master" || $CI_COMMIT_BRANCH == "main"
    when: always
  - when: never
  script:
  - fb registry-verify $CI_JOB_TOKEN $CI_PROJECT_ID
npm-package-dependencies-scanner:
  image: socketdev/cli:0.0.95
  stage: test
  allow_failure: true
  retry: 2
  tags:
  - shell-application-gitlab-runner
  rules:
  - if: "$CI_PIPELINE_SOURCE == 'merge_request_event' && $CI_MERGE_REQUEST_TITLE =~
      /^Draft:/"
    changes:
    - package.json
    - package-lock.json
    - yarn.lock
    when: manual
  - if: "$CI_PIPELINE_SOURCE == 'merge_request_event'"
    changes:
    - package.json
    - package-lock.json
    - yarn.lock
    when: always
  - when: never
  script:
  - socketcli --repo $CI_PROJECT_NAME --branch $(if [ -z $CI_MERGE_REQUEST_SOURCE_BRANCH_NAME
    ]; then echo "$CI_COMMIT_BRANCH"; else echo "$CI_MERGE_REQUEST_SOURCE_BRANCH_NAME";
    fi) --target_path $CI_PROJECT_DIR --committer "$(echo $CI_COMMIT_AUTHOR | awk
    -F '<' '{print $2}' | head -c -2)" --commit_message "$CI_COMMIT_MESSAGE" --pr_number
    $(if [ -z $CI_MERGE_REQUEST_IID ]; then echo 0; else echo $CI_MERGE_REQUEST_IID
    ; fi) --scm gitlab $(if [ "$CI_DEFAULT_BRANCH" == "$CI_COMMIT_BRANCH" ] || [ "$CI_DEFAULT_BRANCH"
    == "$CI_COMMIT_REF_NAME" ]; then echo --default_branch; fi) --disable-overview
  variables:
    SOCKET_ORG_ID: 84943
    GITLAB_TOKEN: "${SOCKET_CI_INFRA_TOKEN}"
  extends: ".npm-package-dependencies-scanner"
validate_configuration_files:
  stage: lint
  needs: []
  tags:
  - shell-application-gitlab-runner
  allow_failure: false
  retry: 2
  script:
  - apk add --no-cache python3 py3-pip
  - pip3 install yamllint
  - 'yamllint -d "{extends: relaxed, rules: { new-line-at-end-of-file: {level: warning},
    trailing-spaces: {level: warning}}}"  $CONFIGURATION_FILES_PATH'
  rules:
  - if: $CI_CONFIG_MANAGEMENT_ENABLED != "true"
    when: never
  - if: $CI_PIPELINE_SOURCE == "merge_request_event"
    when: always
  - when: never
  variables:
    CONFIGURATION_FILES_PATH: configurations/*/*.yaml
lint:
  stage: lint
  allow_failure: true
  retry: 2
  needs: []
  rules:
  - if: $DISABLE_LINTING == "true"
    when: never
  - if: "$CI_PIPELINE_SOURCE == 'merge_request_event' && ($CI_MERGE_REQUEST_TITLE
      =~ /^Hotfix:/ || $CI_MERGE_REQUEST_TITLE =~ /^hotfix:/)"
    when: always
    allow_failure: true
  - if: $CI_PIPELINE_SOURCE == "merge_request_event"
    when: always
  tags:
  - shell-application-gitlab-runner
  script:
  - yarn install --production=false --frozen-lockfile
  - |
    if npm run | grep "lint" > /dev/null; then
      echo "Running project linter"
      yarn run lint
    else
      # install eslint
      echo "lint script is not defined in package.json, Running global linter"
      yarn add --dev @fireblocks/eslint-config-typescript
      yarn add --dev eslint

      # run eslint
      npx eslint@8.42.0 ./src -c node_modules/@fireblocks/eslint-config-typescript/index.js --ext .ts
    fi
format:
  stage: lint
  allow_failure: false
  retry: 2
  needs: []
  rules:
  - if: $DISABLE_CI_FORMATTING == "true"
    when: never
  - if: "$CI_PIPELINE_SOURCE == 'merge_request_event' && ($CI_MERGE_REQUEST_TITLE
      =~ /^Hotfix:/ || $CI_MERGE_REQUEST_TITLE =~ /^hotfix:/)"
    when: always
    allow_failure: true
  - if: $CI_PIPELINE_SOURCE == "merge_request_event"
  tags:
  - shell-application-gitlab-runner
  script:
  - |
    if npm run | grep "format:check" > /dev/null; then
      echo "Running project formatter"
      yarn install --production=false --frozen-lockfile
      yarn run format:check
    else
      echo "Running global formatter"
      yarn install --production=false --frozen-lockfile
      npx prettier --check ./src
    fi
".build-image-kaniko":
  retry: 2
  stage: build
  image:
    name: gcr.io/kaniko-project/executor:v1.23.0-debug
    entrypoint:
    - ''
  tags:
  - builders-application-gitlab-runner
  before_script: []
  needs: []
  variables:
    IMAGE_FQDN: "${IMAGE_PATH}:$IMAGE_TAG"
    IMAGE_FQDN_MAIN: "${IMAGE_PATH}:main"
    DOCKERFILE_PATH: Dockerfile
  script:
  - if [ "$SKIP_IMAGE_BUILD" == "true" ]; then echo "Skipping image build"; exit 0;
    fi
  - echo "@fireblocks:registry=https://gitlab.com/api/v4/packages/npm/" > .npmrc
  - echo "//gitlab.com/api/v4/packages/npm/:_authToken=${NPM_REG_TOKEN}" >> .npmrc
  - echo "//gitlab.com/api/v4/projects/20565764/packages/npm/:_authToken=${NPM_REG_TOKEN}"
    >> .npmrc
  - export IMAGE_FQDN=${IMAGE_PATH}:$IMAGE_TAG
  - export IMAGE_FQDN_MAIN=${IMAGE_PATH}:main
  - export KANIKO_CACHE_ARGS="--cache=true --cache-copy-layers=true --cache-ttl=730h
    --cache-repo=${IMAGE_PATH}"
  - echo "{\"auths\":{\"${CI_REGISTRY}\":{\"auth\":\"$(printf "%s:%s" "${CI_REGISTRY_USER}"
    "${CI_REGISTRY_PASSWORD}" | base64 | tr -d '\n')\"},\"$(echo -n $CI_DEPENDENCY_PROXY_SERVER
    | awk -F[:] '{print $1}')\":{\"auth\":\"$(printf "%s:%s" ${CI_DEPENDENCY_PROXY_USER}
    "${CI_DEPENDENCY_PROXY_PASSWORD}" | base64 | tr -d '\n')\"}}}" > /kaniko/.docker/config.json
  - |
    /kaniko/executor \
      --context $CI_PROJECT_DIR \
      --dockerfile $DOCKERFILE_PATH \
      --build-arg IMAGE_TAG=${IMAGE_TAG} \
      --build-arg SERVICE_NAME=${SERVICE_NAME} \
      --destination ${IMAGE_FQDN} \
      ${KANIKO_CACHE_ARGS} \
      --build-arg CACHE=~/.cache \
      --label org.opencontainers.image.revision=${CI_COMMIT_SHA} \
      --label org.opencontainers.image.source=${CI_PROJECT_URL}
  - |
    if [ "$CI_COMMIT_BRANCH" == "master" ] || [ "$CI_COMMIT_BRANCH" == "main" ]; then
      /kaniko/executor \
        --context $CI_PROJECT_DIR \
        --dockerfile $DOCKERFILE_PATH \
        --build-arg IMAGE_TAG=${IMAGE_TAG} \
        --build-arg SERVICE_NAME=${SERVICE_NAME} \
        --destination ${IMAGE_FQDN_MAIN} \
        ${KANIKO_CACHE_ARGS} \
        --build-arg CACHE=~/.cache \
        --label org.opencontainers.image.revision=${CI_COMMIT_SHA} \
        --label org.opencontainers.image.source=${CI_PROJECT_URL}
    fi
  rules:
  - if: "$CI_COMMIT_TAG"
    when: never
  - if: "$CI_PIPELINE_SOURCE == 'merge_request_event'"
    when: never
  - if: $CI_COMMIT_BRANCH == "master" || $CI_COMMIT_BRANCH == "main"
    when: on_success
    allow_failure: false
  - if: $CI_COMMIT_BRANCH != "master" && $CI_COMMIT_BRANCH != "main"
    when: always
    allow_failure: true
".build-image-docker":
  stage: build
  tags:
  - build-shell
  allow_failure: false
  needs: []
  variables:
    IMAGE_FQDN: "${IMAGE_PATH}:$IMAGE_TAG"
    IMAGE_FQDN_MAIN: "${IMAGE_PATH}:main"
    DOCKERFILE_PATH: Dockerfile
  script:
  - if [ "$SKIP_IMAGE_BUILD" == "true" ]; then echo "Skipping image build"; exit 0;
    fi
  - cp /root/.npmrc .npmrc
  - docker login -u gitlab-ci-token -p $CI_JOB_TOKEN $CI_REGISTRY
  - 'DOCKER_BUILDKIT=1 docker build -f ${DOCKERFILE_PATH} --secret id=npmrc,src=.npmrc
    \ --build-arg BUILDKIT_INLINE_CACHE=1 --build-arg IMAGE_TAG=${IMAGE_TAG} --build-arg
    SERVICE_NAME=${SERVICE_NAME} --cache-from ${IMAGE_FQDN} --cache-from ${IMAGE_FQDN_MAIN}
    -t ${IMAGE_FQDN} --label org.opencontainers.image.revision=${CI_COMMIT_SHA} --label
    org.opencontainers.image.source=${CI_PROJECT_URL} .

    '
  - docker push ${IMAGE_FQDN}
  - if [ "$CI_COMMIT_BRANCH" == "master" ] || [ "$CI_COMMIT_BRANCH" == "main" ]; then
    docker tag ${IMAGE_FQDN} ${IMAGE_FQDN_MAIN}; fi
  - if [ "$CI_COMMIT_BRANCH" == "master" ] || [ "$CI_COMMIT_BRANCH" == "main" ]; then
    docker push ${IMAGE_FQDN_MAIN}; fi
  rules:
  - if: "$CI_COMMIT_TAG"
    when: never
  - if: "$CI_PIPELINE_SOURCE == 'merge_request_event'"
    when: never
  - if: $CI_COMMIT_BRANCH == "master" || $CI_COMMIT_BRANCH == "main"
    when: on_success
  - if: $CI_COMMIT_BRANCH != "master" && $CI_COMMIT_BRANCH != "main"
    when: always
".build-image-podman":
  retry: 2
  stage: build
  image:
    name: registry.gitlab.com/fireblocks/shell/infra/images/podman-compose:latest
    entrypoint:
    - ''
  tags:
  - builders-application-gitlab-runner
  before_script: []
  needs: []
  variables:
    IMAGE_FQDN: "${IMAGE_PATH}:$IMAGE_TAG"
    IMAGE_FQDN_MAIN: "${IMAGE_PATH}:main"
    DOCKERFILE_PATH: Dockerfile
    CACHE_ARGS: "--layers --cache-from ${IMAGE_PATH} --cache-to ${IMAGE_PATH} --cache-ttl=240h\n"
    IMAGE_LABELS: "--label org.opencontainers.image.revision=${CI_COMMIT_SHA} --label
      org.opencontainers.image.source=${CI_PROJECT_URL} --label org.opencontainers.image.vendor=$CI_SERVER_URL/$GITLAB_USER_LOGIN
      --label org.opencontainers.image.authors=$CI_SERVER_URL/$GITLAB_USER_LOGIN --label
      org.opencontainers.image.documentation=$CI_PROJECT_URL --label org.opencontainers.image.licenses=$CI_PROJECT_URL
      --label org.opencontainers.image.url=$CI_PROJECT_URL --label vcs-url=$CI_PROJECT_URL
      --label com.gitlab.ci.user=$CI_SERVER_URL/$GITLAB_USER_LOGIN --label com.gitlab.ci.email=$GITLAB_USER_EMAIL
      --label com.gitlab.ci.tagorbranch=$CI_COMMIT_REF_NAME --label com.gitlab.ci.pipelineurl=$CI_PIPELINE_URL
      --label com.gitlab.ci.commiturl=$CI_PROJECT_URL/commit/$CI_COMMIT_SHA --label
      com.gitlab.ci.cijoburl=$CI_JOB_URL --label com.gitlab.ci.mrurl=$CI_PROJECT_URL/-/merge_requests/$CI_MERGE_REQUEST_ID\n"
  script:
  - if [ "$SKIP_IMAGE_BUILD" == "true" ]; then echo "Skipping image build"; exit 0;
    fi
  - echo "@fireblocks:registry=https://gitlab.com/api/v4/packages/npm/" > .npmrc
  - echo "//gitlab.com/api/v4/packages/npm/:_authToken=${NPM_REG_TOKEN}" >> .npmrc
  - echo "//gitlab.com/api/v4/projects/20565764/packages/npm/:_authToken=${NPM_REG_TOKEN}"
    >> .npmrc
  - podman login --username $CI_REGISTRY_USER --password $CI_REGISTRY_PASSWORD $CI_REGISTRY
  - if [ "$IS_NITRO_SERVICE" == "true" ]; then IMAGE_FQDN=${IMAGE_PATH}-non-nitro:$IMAGE_TAG;
    fi
  - |
    if [ "$NITRO_HOST_UNTRUSTED_MODEL_ENABLED" == "true" ] && [ "$IS_NITRO_SERVICE" == "true" ]; then
      # Keeping service-launcher setup here for now since it's still changing often.
      # Once it stabilizes, we can move it into the podman-compose base image.
      npm install @fireblocks/trusted-fabric-service-launcher@^1.0.2 --no-save  --prefix ./service-launcher --userconfig ./.npmrc
      ./service-launcher/node_modules/@fireblocks/trusted-fabric-service-launcher/bin/launcher.sh build
    else
      podman build --format docker \
        -f ${DOCKERFILE_PATH} \
        ${CACHE_ARGS} \
        --secret id=npmrc,src=.npmrc \
        --build-arg IMAGE_TAG=${IMAGE_TAG} \
        --build-arg SERVICE_NAME=${SERVICE_NAME} \
        ${IMAGE_LABELS} \
        -t ${IMAGE_FQDN} $CI_PROJECT_DIR
    fi
  - podman push ${IMAGE_FQDN}
  - |
    if [ "$CI_COMMIT_BRANCH" == "master" ] || [ "$CI_COMMIT_BRANCH" == "main" ]; then
      if [ "$IS_NITRO_SERVICE" == "true" ]; then IMAGE_FQDN_MAIN=${IMAGE_PATH}-non-nitro:main; fi
      podman tag ${IMAGE_FQDN} ${IMAGE_FQDN_MAIN}
      podman push ${IMAGE_FQDN_MAIN}
    fi
  rules:
  - if: "$CI_COMMIT_TAG"
    when: never
  - if: "$CI_PIPELINE_SOURCE == 'merge_request_event'"
    when: never
  - if: $CI_COMMIT_BRANCH == "master" || $CI_COMMIT_BRANCH == "main"
    when: on_success
    allow_failure: false
  - if: $CI_COMMIT_BRANCH != "master" && $CI_COMMIT_BRANCH != "main"
    when: always
    allow_failure: false
build-image:
  retry: 2
  stage: build
  image:
    name: registry.gitlab.com/fireblocks/shell/infra/images/podman-compose:latest
    entrypoint:
    - ''
  tags:
  - builders-application-gitlab-runner
  before_script: []
  needs: []
  variables:
    IMAGE_FQDN: "${IMAGE_PATH}:$IMAGE_TAG"
    IMAGE_FQDN_MAIN: "${IMAGE_PATH}:main"
    DOCKERFILE_PATH: Dockerfile
    CACHE_ARGS: "--layers --cache-from ${IMAGE_PATH} --cache-to ${IMAGE_PATH} --cache-ttl=240h\n"
    IMAGE_LABELS: "--label org.opencontainers.image.revision=${CI_COMMIT_SHA} --label
      org.opencontainers.image.source=${CI_PROJECT_URL} --label org.opencontainers.image.vendor=$CI_SERVER_URL/$GITLAB_USER_LOGIN
      --label org.opencontainers.image.authors=$CI_SERVER_URL/$GITLAB_USER_LOGIN --label
      org.opencontainers.image.documentation=$CI_PROJECT_URL --label org.opencontainers.image.licenses=$CI_PROJECT_URL
      --label org.opencontainers.image.url=$CI_PROJECT_URL --label vcs-url=$CI_PROJECT_URL
      --label com.gitlab.ci.user=$CI_SERVER_URL/$GITLAB_USER_LOGIN --label com.gitlab.ci.email=$GITLAB_USER_EMAIL
      --label com.gitlab.ci.tagorbranch=$CI_COMMIT_REF_NAME --label com.gitlab.ci.pipelineurl=$CI_PIPELINE_URL
      --label com.gitlab.ci.commiturl=$CI_PROJECT_URL/commit/$CI_COMMIT_SHA --label
      com.gitlab.ci.cijoburl=$CI_JOB_URL --label com.gitlab.ci.mrurl=$CI_PROJECT_URL/-/merge_requests/$CI_MERGE_REQUEST_ID\n"
  script:
  - if [ "$SKIP_IMAGE_BUILD" == "true" ]; then echo "Skipping image build"; exit 0;
    fi
  - echo "@fireblocks:registry=https://gitlab.com/api/v4/packages/npm/" > .npmrc
  - echo "//gitlab.com/api/v4/packages/npm/:_authToken=${NPM_REG_TOKEN}" >> .npmrc
  - echo "//gitlab.com/api/v4/projects/20565764/packages/npm/:_authToken=${NPM_REG_TOKEN}"
    >> .npmrc
  - podman login --username $CI_REGISTRY_USER --password $CI_REGISTRY_PASSWORD $CI_REGISTRY
  - if [ "$IS_NITRO_SERVICE" == "true" ]; then IMAGE_FQDN=${IMAGE_PATH}-non-nitro:$IMAGE_TAG;
    fi
  - |
    if [ "$NITRO_HOST_UNTRUSTED_MODEL_ENABLED" == "true" ] && [ "$IS_NITRO_SERVICE" == "true" ]; then
      # Keeping service-launcher setup here for now since it's still changing often.
      # Once it stabilizes, we can move it into the podman-compose base image.
      npm install @fireblocks/trusted-fabric-service-launcher@^1.0.2 --no-save  --prefix ./service-launcher --userconfig ./.npmrc
      ./service-launcher/node_modules/@fireblocks/trusted-fabric-service-launcher/bin/launcher.sh build
    else
      podman build --format docker \
        -f ${DOCKERFILE_PATH} \
        ${CACHE_ARGS} \
        --secret id=npmrc,src=.npmrc \
        --build-arg IMAGE_TAG=${IMAGE_TAG} \
        --build-arg SERVICE_NAME=${SERVICE_NAME} \
        ${IMAGE_LABELS} \
        -t ${IMAGE_FQDN} $CI_PROJECT_DIR
    fi
  - podman push ${IMAGE_FQDN}
  - |
    if [ "$CI_COMMIT_BRANCH" == "master" ] || [ "$CI_COMMIT_BRANCH" == "main" ]; then
      if [ "$IS_NITRO_SERVICE" == "true" ]; then IMAGE_FQDN_MAIN=${IMAGE_PATH}-non-nitro:main; fi
      podman tag ${IMAGE_FQDN} ${IMAGE_FQDN_MAIN}
      podman push ${IMAGE_FQDN_MAIN}
    fi
  rules:
  - if: "$CI_COMMIT_TAG"
    when: never
  - if: "$CI_PIPELINE_SOURCE == 'merge_request_event'"
    when: never
  - if: $CI_COMMIT_BRANCH == "master" || $CI_COMMIT_BRANCH == "main"
    when: on_success
    allow_failure: false
  - if: $CI_COMMIT_BRANCH != "master" && $CI_COMMIT_BRANCH != "main"
    when: always
    allow_failure: false
  extends: ".build-image-podman"
build-image-from-template:
  retry: 2
  stage: build
  image:
    name: registry.gitlab.com/fireblocks/shell/infra/images/podman-compose:latest
    entrypoint:
    - ''
  tags:
  - builders-application-gitlab-runner
  before_script: []
  needs: []
  variables:
    IMAGE_FQDN: "${IMAGE_PATH}:${IMAGE_TAG}-optimized"
    IMAGE_FQDN_MAIN: "${IMAGE_PATH}:main-optimized"
    DOCKERFILE_PATH: Dockerfile
    CACHE_ARGS: "--layers --cache-from ${IMAGE_PATH} --cache-to ${IMAGE_PATH} --cache-ttl=240h\n"
    IMAGE_LABELS: "--label org.opencontainers.image.revision=${CI_COMMIT_SHA} --label
      org.opencontainers.image.source=${CI_PROJECT_URL} --label org.opencontainers.image.vendor=$CI_SERVER_URL/$GITLAB_USER_LOGIN
      --label org.opencontainers.image.authors=$CI_SERVER_URL/$GITLAB_USER_LOGIN --label
      org.opencontainers.image.documentation=$CI_PROJECT_URL --label org.opencontainers.image.licenses=$CI_PROJECT_URL
      --label org.opencontainers.image.url=$CI_PROJECT_URL --label vcs-url=$CI_PROJECT_URL
      --label com.gitlab.ci.user=$CI_SERVER_URL/$GITLAB_USER_LOGIN --label com.gitlab.ci.email=$GITLAB_USER_EMAIL
      --label com.gitlab.ci.tagorbranch=$CI_COMMIT_REF_NAME --label com.gitlab.ci.pipelineurl=$CI_PIPELINE_URL
      --label com.gitlab.ci.commiturl=$CI_PROJECT_URL/commit/$CI_COMMIT_SHA --label
      com.gitlab.ci.cijoburl=$CI_JOB_URL --label com.gitlab.ci.mrurl=$CI_PROJECT_URL/-/merge_requests/$CI_MERGE_REQUEST_ID\n"
    GITLAB_TOKEN: "$CI_INFRA_READ_TOKEN"
  script:
  - if [ "$SKIP_IMAGE_BUILD" == "true" && "$FORCE_IMAGE_BUILD_FROM_TEMPLATE" != "true"
    ]; then echo "Skipping image build"; exit 0; fi
  - cp /root/.npmrc .npmrc
  - docker login -u gitlab-ci-token -p $CI_JOB_TOKEN $CI_REGISTRY
  - |
    fb deployment:build-image \
      --common-dockerfile-type "node-service" \
      --image-path $IMAGE_PATH \
      --service-name $SERVICE_NAME \
      -t "${IMAGE_TAG}-optimized" \
      .
  - docker push ${IMAGE_FQDN}
  - if [ "$CI_COMMIT_BRANCH" == "master" ] || [ "$CI_COMMIT_BRANCH" == "main" ]; then
    docker tag ${IMAGE_FQDN} ${IMAGE_FQDN_MAIN}; fi
  - if [ "$CI_COMMIT_BRANCH" == "master" ] || [ "$CI_COMMIT_BRANCH" == "main" ]; then
    docker push ${IMAGE_FQDN_MAIN}; fi
  rules:
  - if: $FORCE_IMAGE_BUILD_FROM_TEMPLATE == "true"
    when: always
  - when: never
  extends: build-image
  allow_failure: true
build-image-nitro:
  stage: build
  needs:
  - job: build-image
    artifacts: true
  image:
    name: registry.gitlab.com/fireblocks/devops/fb-nitro-eks/build/fb-nitro-eks:ed1a14c2
    entrypoint:
    - ''
  tags:
  - shared-devx
  variables:
    IMAGE_FQDN: "${IMAGE_PATH}-non-nitro:$IMAGE_TAG"
    NITRO_IMAGE_TAG: "$CI_COMMIT_SHORT_SHA"
    IMAGE_FQDN_NITRO: "${IMAGE_PATH}:$NITRO_IMAGE_TAG"
    IMAGE_FQDN_MAIN_NITRO: "${IMAGE_PATH}:main"
  script:
  - docker kill tmp_nitro_builder || /bin/true
  - docker rm tmp_nitro_builder || /bin/true
  - docker login -u gitlab-ci-token -p $CI_JOB_TOKEN $CI_REGISTRY
  - if [ "$SKIP_IMAGE_BUILD" == "true" ]; then echo "Skipping image build"; exit 0;
    fi
  - cd /nitro-builder
  - docker pull ${IMAGE_FQDN}
  - ./scripts/build_nitro.sh -s "${SERVICE_NAME}" -i ${IMAGE_FQDN} -p ${IMAGE_FQDN_NITRO}
  - docker push ${IMAGE_FQDN_NITRO}
  - if [ "$CI_COMMIT_BRANCH" == "master" ] || [ "$CI_COMMIT_BRANCH" == "main" ]; then
    docker tag ${IMAGE_FQDN_NITRO} ${IMAGE_FQDN_MAIN_NITRO}; fi
  - if [ "$CI_COMMIT_BRANCH" == "master" ] || [ "$CI_COMMIT_BRANCH" == "main" ]; then
    docker push ${IMAGE_FQDN_MAIN_NITRO}; fi
  - docker rmi ${IMAGE_FQDN_NITRO}
  rules:
  - if: "$CI_COMMIT_TAG"
    when: never
  - if: "$CI_PIPELINE_SOURCE == 'merge_request_event'"
    when: never
  - if: ($CI_COMMIT_BRANCH == "master" || $CI_COMMIT_BRANCH == "main") && $IS_NITRO_SERVICE
      == "true"
    when: on_success
    allow_failure: false
  - if: $CI_COMMIT_BRANCH != "master" && $CI_COMMIT_BRANCH != "main" && $IS_NITRO_SERVICE
      == "true"
    when: always
    allow_failure: false
wiz-image-scan:
  stage: image-scan
  allow_failure: true
  needs:
  - build-image
  tags:
  - build-shell
  script:
  - if [ "$SKIP_IMAGE_BUILD" == "true" ]; then echo "Skipped image build, skipping
    image scan"; exit 0; fi
  - docker login -u gitlab-ci-token -p $CI_JOB_TOKEN $CI_REGISTRY
  - docker pull ${CI_REGISTRY_IMAGE}/ci_build/${SERVICE_NAME}:$IMAGE_TAG
  - curl --silent -o wizcli https://wizcli.app.wiz.io/wizcli && chmod +x wizcli
  - ./wizcli auth --id "$WIZ_CLIENT_ID" --secret "$WIZ_CLIENT_SECRET"
  - ./wizcli docker scan --image ${CI_REGISTRY_IMAGE}/ci_build/${SERVICE_NAME}:$IMAGE_TAG
    --policy "$WIZ_POLICY"
  rules:
  - if: $IS_PROD_SERVICE != "true"
    when: never
  - if: "$CI_COMMIT_TAG"
    when: never
  - if: "$CI_PIPELINE_SOURCE == 'merge_request_event'"
    when: never
  - if: $CI_COMMIT_BRANCH == "master" || $CI_COMMIT_BRANCH == "main"
    when: on_success
    allow_failure: true
  - if: $CI_COMMIT_BRANCH != "master" && $CI_COMMIT_BRANCH != "main"
    when: manual
    allow_failure: true
".env-status-check":
  image: registry.gitlab.com/fireblocks/shell/infra/images/node-infra-20
  stage: env-status-check
  allow_failure: true
  when: manual
  needs: []
  retry: 2
  tags:
  - shell-application-gitlab-runner
  before_script:
  - touch .npmrc
  - npm config set --location=user @fireblocks:registry https://gitlab.com/api/v4/packages/npm/
  - npm config set --location=user '//gitlab.com/api/v4/packages/npm/:_authToken'
    "${NPM_REG_TOKEN}"
  - npm config set --location=user '//gitlab.com/api/v4/projects/20565764/packages/npm/:_authToken'
    "${NPM_REG_TOKEN}"
  - echo "@fireblocks:registry=https://gitlab.com/api/v4/packages/npm/">>.npmrc
  - echo "//gitlab.com/api/v4/packages/npm/:_authToken=${NPM_REG_TOKEN}">>.npmrc
  - echo "//gitlab.com/api/v4/projects/20565764/packages/npm/:_authToken=${NPM_REG_TOKEN}">>.npmrc
  - yarn global add @fireblocks/fb-cli
  script:
  - echo "Checking last integration tests and e2e jobs status in ${env}"
  - fb check-env-status --env=${env} --crashOnFail=true
  - echo "The environment ${env} is stable and ready for deployment"
  rules:
  - if: "$CI_COMMIT_BRANCH"
    when: manual
  - when: never
dev1-status-check:
  image: registry.gitlab.com/fireblocks/shell/infra/images/node-infra-20
  stage: env-status-check
  allow_failure: true
  when: manual
  needs: []
  retry: 2
  tags:
  - shell-application-gitlab-runner
  before_script:
  - touch .npmrc
  - npm config set --location=user @fireblocks:registry https://gitlab.com/api/v4/packages/npm/
  - npm config set --location=user '//gitlab.com/api/v4/packages/npm/:_authToken'
    "${NPM_REG_TOKEN}"
  - npm config set --location=user '//gitlab.com/api/v4/projects/20565764/packages/npm/:_authToken'
    "${NPM_REG_TOKEN}"
  - echo "@fireblocks:registry=https://gitlab.com/api/v4/packages/npm/">>.npmrc
  - echo "//gitlab.com/api/v4/packages/npm/:_authToken=${NPM_REG_TOKEN}">>.npmrc
  - echo "//gitlab.com/api/v4/projects/20565764/packages/npm/:_authToken=${NPM_REG_TOKEN}">>.npmrc
  - yarn global add @fireblocks/fb-cli
  script:
  - echo "Checking last integration tests and e2e jobs status in ${env}"
  - fb check-env-status --env=${env} --crashOnFail=true
  - echo "The environment ${env} is stable and ready for deployment"
  rules:
  - if: "$CI_COMMIT_BRANCH"
    when: manual
  - when: never
  variables:
    env: dev1
  extends: ".env-status-check"
dev2-status-check:
  image: registry.gitlab.com/fireblocks/shell/infra/images/node-infra-20
  stage: env-status-check
  allow_failure: true
  when: manual
  needs: []
  retry: 2
  tags:
  - shell-application-gitlab-runner
  before_script:
  - touch .npmrc
  - npm config set --location=user @fireblocks:registry https://gitlab.com/api/v4/packages/npm/
  - npm config set --location=user '//gitlab.com/api/v4/packages/npm/:_authToken'
    "${NPM_REG_TOKEN}"
  - npm config set --location=user '//gitlab.com/api/v4/projects/20565764/packages/npm/:_authToken'
    "${NPM_REG_TOKEN}"
  - echo "@fireblocks:registry=https://gitlab.com/api/v4/packages/npm/">>.npmrc
  - echo "//gitlab.com/api/v4/packages/npm/:_authToken=${NPM_REG_TOKEN}">>.npmrc
  - echo "//gitlab.com/api/v4/projects/20565764/packages/npm/:_authToken=${NPM_REG_TOKEN}">>.npmrc
  - yarn global add @fireblocks/fb-cli
  script:
  - echo "Checking last integration tests and e2e jobs status in ${env}"
  - fb check-env-status --env=${env} --crashOnFail=true
  - echo "The environment ${env} is stable and ready for deployment"
  rules:
  - if: "$CI_COMMIT_BRANCH"
    when: manual
  - when: never
  variables:
    env: dev2
  extends: ".env-status-check"
dev3-status-check:
  image: registry.gitlab.com/fireblocks/shell/infra/images/node-infra-20
  stage: env-status-check
  allow_failure: true
  when: manual
  needs: []
  retry: 2
  tags:
  - shell-application-gitlab-runner
  before_script:
  - touch .npmrc
  - npm config set --location=user @fireblocks:registry https://gitlab.com/api/v4/packages/npm/
  - npm config set --location=user '//gitlab.com/api/v4/packages/npm/:_authToken'
    "${NPM_REG_TOKEN}"
  - npm config set --location=user '//gitlab.com/api/v4/projects/20565764/packages/npm/:_authToken'
    "${NPM_REG_TOKEN}"
  - echo "@fireblocks:registry=https://gitlab.com/api/v4/packages/npm/">>.npmrc
  - echo "//gitlab.com/api/v4/packages/npm/:_authToken=${NPM_REG_TOKEN}">>.npmrc
  - echo "//gitlab.com/api/v4/projects/20565764/packages/npm/:_authToken=${NPM_REG_TOKEN}">>.npmrc
  - yarn global add @fireblocks/fb-cli
  script:
  - echo "Checking last integration tests and e2e jobs status in ${env}"
  - fb check-env-status --env=${env} --crashOnFail=true
  - echo "The environment ${env} is stable and ready for deployment"
  rules:
  - if: "$CI_COMMIT_BRANCH"
    when: manual
  - when: never
  variables:
    env: dev3
  extends: ".env-status-check"
dev4-status-check:
  image: registry.gitlab.com/fireblocks/shell/infra/images/node-infra-20
  stage: env-status-check
  allow_failure: true
  when: manual
  needs: []
  retry: 2
  tags:
  - shell-application-gitlab-runner
  before_script:
  - touch .npmrc
  - npm config set --location=user @fireblocks:registry https://gitlab.com/api/v4/packages/npm/
  - npm config set --location=user '//gitlab.com/api/v4/packages/npm/:_authToken'
    "${NPM_REG_TOKEN}"
  - npm config set --location=user '//gitlab.com/api/v4/projects/20565764/packages/npm/:_authToken'
    "${NPM_REG_TOKEN}"
  - echo "@fireblocks:registry=https://gitlab.com/api/v4/packages/npm/">>.npmrc
  - echo "//gitlab.com/api/v4/packages/npm/:_authToken=${NPM_REG_TOKEN}">>.npmrc
  - echo "//gitlab.com/api/v4/projects/20565764/packages/npm/:_authToken=${NPM_REG_TOKEN}">>.npmrc
  - yarn global add @fireblocks/fb-cli
  script:
  - echo "Checking last integration tests and e2e jobs status in ${env}"
  - fb check-env-status --env=${env} --crashOnFail=true
  - echo "The environment ${env} is stable and ready for deployment"
  rules:
  - if: "$CI_COMMIT_BRANCH"
    when: manual
  - when: never
  variables:
    env: dev4
  extends: ".env-status-check"
dev5-status-check:
  image: registry.gitlab.com/fireblocks/shell/infra/images/node-infra-20
  stage: env-status-check
  allow_failure: true
  when: manual
  needs: []
  retry: 2
  tags:
  - shell-application-gitlab-runner
  before_script:
  - touch .npmrc
  - npm config set --location=user @fireblocks:registry https://gitlab.com/api/v4/packages/npm/
  - npm config set --location=user '//gitlab.com/api/v4/packages/npm/:_authToken'
    "${NPM_REG_TOKEN}"
  - npm config set --location=user '//gitlab.com/api/v4/projects/20565764/packages/npm/:_authToken'
    "${NPM_REG_TOKEN}"
  - echo "@fireblocks:registry=https://gitlab.com/api/v4/packages/npm/">>.npmrc
  - echo "//gitlab.com/api/v4/packages/npm/:_authToken=${NPM_REG_TOKEN}">>.npmrc
  - echo "//gitlab.com/api/v4/projects/20565764/packages/npm/:_authToken=${NPM_REG_TOKEN}">>.npmrc
  - yarn global add @fireblocks/fb-cli
  script:
  - echo "Checking last integration tests and e2e jobs status in ${env}"
  - fb check-env-status --env=${env} --crashOnFail=true
  - echo "The environment ${env} is stable and ready for deployment"
  rules:
  - if: "$CI_COMMIT_BRANCH"
    when: manual
  - when: never
  variables:
    env: dev5
  extends: ".env-status-check"
dev6-status-check:
  image: registry.gitlab.com/fireblocks/shell/infra/images/node-infra-20
  stage: env-status-check
  allow_failure: true
  when: manual
  needs: []
  retry: 2
  tags:
  - shell-application-gitlab-runner
  before_script:
  - touch .npmrc
  - npm config set --location=user @fireblocks:registry https://gitlab.com/api/v4/packages/npm/
  - npm config set --location=user '//gitlab.com/api/v4/packages/npm/:_authToken'
    "${NPM_REG_TOKEN}"
  - npm config set --location=user '//gitlab.com/api/v4/projects/20565764/packages/npm/:_authToken'
    "${NPM_REG_TOKEN}"
  - echo "@fireblocks:registry=https://gitlab.com/api/v4/packages/npm/">>.npmrc
  - echo "//gitlab.com/api/v4/packages/npm/:_authToken=${NPM_REG_TOKEN}">>.npmrc
  - echo "//gitlab.com/api/v4/projects/20565764/packages/npm/:_authToken=${NPM_REG_TOKEN}">>.npmrc
  - yarn global add @fireblocks/fb-cli
  script:
  - echo "Checking last integration tests and e2e jobs status in ${env}"
  - fb check-env-status --env=${env} --crashOnFail=true
  - echo "The environment ${env} is stable and ready for deployment"
  rules:
  - if: "$CI_COMMIT_BRANCH"
    when: manual
  - when: never
  variables:
    env: dev6
  extends: ".env-status-check"
dev7-status-check:
  image: registry.gitlab.com/fireblocks/shell/infra/images/node-infra-20
  stage: env-status-check
  allow_failure: true
  when: manual
  needs: []
  retry: 2
  tags:
  - shell-application-gitlab-runner
  before_script:
  - touch .npmrc
  - npm config set --location=user @fireblocks:registry https://gitlab.com/api/v4/packages/npm/
  - npm config set --location=user '//gitlab.com/api/v4/packages/npm/:_authToken'
    "${NPM_REG_TOKEN}"
  - npm config set --location=user '//gitlab.com/api/v4/projects/20565764/packages/npm/:_authToken'
    "${NPM_REG_TOKEN}"
  - echo "@fireblocks:registry=https://gitlab.com/api/v4/packages/npm/">>.npmrc
  - echo "//gitlab.com/api/v4/packages/npm/:_authToken=${NPM_REG_TOKEN}">>.npmrc
  - echo "//gitlab.com/api/v4/projects/20565764/packages/npm/:_authToken=${NPM_REG_TOKEN}">>.npmrc
  - yarn global add @fireblocks/fb-cli
  script:
  - echo "Checking last integration tests and e2e jobs status in ${env}"
  - fb check-env-status --env=${env} --crashOnFail=true
  - echo "The environment ${env} is stable and ready for deployment"
  rules:
  - if: "$CI_COMMIT_BRANCH"
    when: manual
  - when: never
  variables:
    env: dev7
  extends: ".env-status-check"
dev8-status-check:
  image: registry.gitlab.com/fireblocks/shell/infra/images/node-infra-20
  stage: env-status-check
  allow_failure: true
  when: manual
  needs: []
  retry: 2
  tags:
  - shell-application-gitlab-runner
  before_script:
  - touch .npmrc
  - npm config set --location=user @fireblocks:registry https://gitlab.com/api/v4/packages/npm/
  - npm config set --location=user '//gitlab.com/api/v4/packages/npm/:_authToken'
    "${NPM_REG_TOKEN}"
  - npm config set --location=user '//gitlab.com/api/v4/projects/20565764/packages/npm/:_authToken'
    "${NPM_REG_TOKEN}"
  - echo "@fireblocks:registry=https://gitlab.com/api/v4/packages/npm/">>.npmrc
  - echo "//gitlab.com/api/v4/packages/npm/:_authToken=${NPM_REG_TOKEN}">>.npmrc
  - echo "//gitlab.com/api/v4/projects/20565764/packages/npm/:_authToken=${NPM_REG_TOKEN}">>.npmrc
  - yarn global add @fireblocks/fb-cli
  script:
  - echo "Checking last integration tests and e2e jobs status in ${env}"
  - fb check-env-status --env=${env} --crashOnFail=true
  - echo "The environment ${env} is stable and ready for deployment"
  rules:
  - if: "$CI_COMMIT_BRANCH"
    when: manual
  - when: never
  variables:
    env: dev8
  extends: ".env-status-check"
dev9-status-check:
  image: registry.gitlab.com/fireblocks/shell/infra/images/node-infra-20
  stage: env-status-check
  allow_failure: true
  when: manual
  needs: []
  retry: 2
  tags:
  - shell-application-gitlab-runner
  before_script:
  - touch .npmrc
  - npm config set --location=user @fireblocks:registry https://gitlab.com/api/v4/packages/npm/
  - npm config set --location=user '//gitlab.com/api/v4/packages/npm/:_authToken'
    "${NPM_REG_TOKEN}"
  - npm config set --location=user '//gitlab.com/api/v4/projects/20565764/packages/npm/:_authToken'
    "${NPM_REG_TOKEN}"
  - echo "@fireblocks:registry=https://gitlab.com/api/v4/packages/npm/">>.npmrc
  - echo "//gitlab.com/api/v4/packages/npm/:_authToken=${NPM_REG_TOKEN}">>.npmrc
  - echo "//gitlab.com/api/v4/projects/20565764/packages/npm/:_authToken=${NPM_REG_TOKEN}">>.npmrc
  - yarn global add @fireblocks/fb-cli
  script:
  - echo "Checking last integration tests and e2e jobs status in ${env}"
  - fb check-env-status --env=${env} --crashOnFail=true
  - echo "The environment ${env} is stable and ready for deployment"
  rules:
  - if: "$CI_COMMIT_BRANCH"
    when: manual
  - when: never
  variables:
    env: dev9
  extends: ".env-status-check"
dev10-status-check:
  image: registry.gitlab.com/fireblocks/shell/infra/images/node-infra-20
  stage: env-status-check
  allow_failure: true
  when: manual
  needs: []
  retry: 2
  tags:
  - shell-application-gitlab-runner
  before_script:
  - touch .npmrc
  - npm config set --location=user @fireblocks:registry https://gitlab.com/api/v4/packages/npm/
  - npm config set --location=user '//gitlab.com/api/v4/packages/npm/:_authToken'
    "${NPM_REG_TOKEN}"
  - npm config set --location=user '//gitlab.com/api/v4/projects/20565764/packages/npm/:_authToken'
    "${NPM_REG_TOKEN}"
  - echo "@fireblocks:registry=https://gitlab.com/api/v4/packages/npm/">>.npmrc
  - echo "//gitlab.com/api/v4/packages/npm/:_authToken=${NPM_REG_TOKEN}">>.npmrc
  - echo "//gitlab.com/api/v4/projects/20565764/packages/npm/:_authToken=${NPM_REG_TOKEN}">>.npmrc
  - yarn global add @fireblocks/fb-cli
  script:
  - echo "Checking last integration tests and e2e jobs status in ${env}"
  - fb check-env-status --env=${env} --crashOnFail=true
  - echo "The environment ${env} is stable and ready for deployment"
  rules:
  - if: "$CI_COMMIT_BRANCH"
    when: manual
  - when: never
  variables:
    env: dev10
  extends: ".env-status-check"
dev11-status-check:
  image: registry.gitlab.com/fireblocks/shell/infra/images/node-infra-20
  stage: env-status-check
  allow_failure: true
  when: manual
  needs: []
  retry: 2
  tags:
  - shell-application-gitlab-runner
  before_script:
  - touch .npmrc
  - npm config set --location=user @fireblocks:registry https://gitlab.com/api/v4/packages/npm/
  - npm config set --location=user '//gitlab.com/api/v4/packages/npm/:_authToken'
    "${NPM_REG_TOKEN}"
  - npm config set --location=user '//gitlab.com/api/v4/projects/20565764/packages/npm/:_authToken'
    "${NPM_REG_TOKEN}"
  - echo "@fireblocks:registry=https://gitlab.com/api/v4/packages/npm/">>.npmrc
  - echo "//gitlab.com/api/v4/packages/npm/:_authToken=${NPM_REG_TOKEN}">>.npmrc
  - echo "//gitlab.com/api/v4/projects/20565764/packages/npm/:_authToken=${NPM_REG_TOKEN}">>.npmrc
  - yarn global add @fireblocks/fb-cli
  script:
  - echo "Checking last integration tests and e2e jobs status in ${env}"
  - fb check-env-status --env=${env} --crashOnFail=true
  - echo "The environment ${env} is stable and ready for deployment"
  rules:
  - if: "$CI_COMMIT_BRANCH"
    when: manual
  - when: never
  variables:
    env: dev11
  extends: ".env-status-check"
stage-status-check:
  image: registry.gitlab.com/fireblocks/shell/infra/images/node-infra-20
  stage: env-status-check
  allow_failure: true
  when: manual
  needs: []
  retry: 2
  tags:
  - shell-application-gitlab-runner
  before_script:
  - touch .npmrc
  - npm config set --location=user @fireblocks:registry https://gitlab.com/api/v4/packages/npm/
  - npm config set --location=user '//gitlab.com/api/v4/packages/npm/:_authToken'
    "${NPM_REG_TOKEN}"
  - npm config set --location=user '//gitlab.com/api/v4/projects/20565764/packages/npm/:_authToken'
    "${NPM_REG_TOKEN}"
  - echo "@fireblocks:registry=https://gitlab.com/api/v4/packages/npm/">>.npmrc
  - echo "//gitlab.com/api/v4/packages/npm/:_authToken=${NPM_REG_TOKEN}">>.npmrc
  - echo "//gitlab.com/api/v4/projects/20565764/packages/npm/:_authToken=${NPM_REG_TOKEN}">>.npmrc
  - yarn global add @fireblocks/fb-cli
  script:
  - echo "Checking last integration tests and e2e jobs status in ${env}"
  - fb check-env-status --env=${env} --crashOnFail=true
  - echo "The environment ${env} is stable and ready for deployment"
  rules:
  - if: "$CI_COMMIT_BRANCH"
    when: manual
  - when: never
  variables:
    env: staging
  extends: ".env-status-check"
".deploy_job":
  stage: deploy
  allow_failure: true
  needs:
  - job: build-image
  - job: build-image-nitro
    optional: true
  trigger:
    forward:
      pipeline_variables: true
    strategy: depend
    include:
    - project: fireblocks/shell/common/templates/ci-infra
      ref: main
      file:
      - "${DEPLOYMENT_FILE_PATH}"
  variables:
    FORCE_DEPLOYMENT_FLAG: false
    PRE1_CONTINUOUS_DEPLOYMENT_FLAG: true
  rules:
  - - if: $IS_DEPLOYABLE_SERVICE != "true"
      when: never
    - if: "$CI_COMMIT_TAG"
      when: never
    - if: "$CI_PIPELINE_SOURCE == 'merge_request_event'"
      when: never
    - if: $STRATEGY == "classic"
      when: manual
      allow_failure: true
".deploy_job_k8s":
  stage: deploy
  allow_failure: true
  needs:
  - job: build-image
  - job: build-image-nitro
    optional: true
  trigger:
    forward:
      pipeline_variables: true
    strategy: depend
    include:
    - project: fireblocks/shell/common/templates/ci-infra
      ref: "$TEMPLATE_REF"
      file:
      - "${DEPLOYMENT_FILE_PATH}"
  variables:
    FORCE_DEPLOYMENT_FLAG: false
    PRE1_CONTINUOUS_DEPLOYMENT_FLAG: true
  rules:
  - - if: $IS_DEPLOYABLE_SERVICE != "true"
      when: never
    - if: "$CI_COMMIT_TAG"
      when: never
    - if: "$CI_PIPELINE_SOURCE == 'merge_request_event'"
      when: never
    - if: $STRATEGY == "canary"
      when: manual
      allow_failure: true
".deploy_job_k8s_in_place":
  stage: deploy
  allow_failure: true
  trigger:
    forward:
      pipeline_variables: true
    strategy: depend
    include:
    - project: fireblocks/shell/common/templates/ci-infra
      ref: "$TEMPLATE_REF"
      file:
      - "${DEPLOYMENT_FILE_PATH}"
  variables:
    FORCE_DEPLOYMENT_FLAG: false
    PRE1_CONTINUOUS_DEPLOYMENT_FLAG: true
  rules:
  - - if: $IS_DEPLOYABLE_SERVICE != "true"
      when: never
    - if: "$CI_COMMIT_TAG"
      when: never
    - if: "$CI_PIPELINE_SOURCE == 'merge_request_event'"
      when: never
      allow_failure: true
    - if: $STRATEGY == "in_place"
      when: manual
      allow_failure: true
deploy_localstack:
  stage: deploy
  allow_failure: true
  needs:
  - job: build-image
  - job: build-image-nitro
    optional: true
  trigger:
    forward:
      pipeline_variables: true
    strategy: depend
    include:
    - project: fireblocks/shell/common/templates/ci-infra
      ref: main
      file:
      - "${DEPLOYMENT_FILE_PATH}"
  variables:
    FORCE_DEPLOYMENT_FLAG: false
    PRE1_CONTINUOUS_DEPLOYMENT_FLAG: true
    DEPLOYMENT_FILE_PATH: backend-ci/stages/deployments/deploy-localstack.yml
  rules:
  - - if: "$CI_COMMIT_TAG"
      when: never
    - if: "$CI_PIPELINE_SOURCE == 'merge_request_event'"
      when: never
    - if: $IS_MULTI_SERVICE_DEPLOYMENT == "true"
      when: never
    - if: $CI_COMMIT_BRANCH == "master" || $CI_COMMIT_BRANCH == "main"
      changes:
      - deployment/values.yaml
      - deployment/overrides/nonprod-tier.yaml
      - deployment/overrides/pre1.yaml
      - deployment/overrides/localstack.yaml
      when: always
      allow_failure: true
    - when: never
  extends: ".deploy_job"
deploy_dev1:
  stage: deploy
  allow_failure: true
  needs:
  - job: build-image
  - job: build-image-nitro
    optional: true
  trigger:
    forward:
      pipeline_variables: true
    strategy: depend
    include:
    - project: fireblocks/shell/common/templates/ci-infra
      ref: main
      file:
      - "${DEPLOYMENT_FILE_PATH}"
  variables:
    FORCE_DEPLOYMENT_FLAG: false
    PRE1_CONTINUOUS_DEPLOYMENT_FLAG: true
    DEPLOYMENT_FILE_PATH: backend-ci/stages/deployments/deploy-dev1.yml
  rules:
  - - if: $IS_DEPLOYABLE_SERVICE != "true"
      when: never
    - if: "$CI_COMMIT_TAG"
      when: never
    - if: "$CI_PIPELINE_SOURCE == 'merge_request_event'"
      when: never
    - if: $STRATEGY == "classic"
      when: manual
      allow_failure: true
  extends: ".deploy_job"
deploy_dev1_k8s:
  stage: deploy
  allow_failure: true
  needs:
  - job: build-image
  - job: build-image-nitro
    optional: true
  trigger:
    forward:
      pipeline_variables: true
    strategy: depend
    include:
    - project: fireblocks/shell/common/templates/ci-infra
      ref: "$TEMPLATE_REF"
      file:
      - "${DEPLOYMENT_FILE_PATH}"
  variables:
    FORCE_DEPLOYMENT_FLAG: false
    PRE1_CONTINUOUS_DEPLOYMENT_FLAG: true
    DEPLOYMENT_FILE_PATH: backend-ci/stages/deployments/deploy-dev1-k8s.yml
    K8S_CLUSTER_NAME: devx-k8s
    AWS_REGION: us-east-2
    IAM_ROLE_APPLICATION: arn:aws:iam::318128524537:role/devx-application-CICD-role
  rules:
  - - if: $IS_DEPLOYABLE_SERVICE != "true"
      when: never
    - if: "$CI_COMMIT_TAG"
      when: never
    - if: "$CI_PIPELINE_SOURCE == 'merge_request_event'"
      when: never
    - if: $STRATEGY == "canary"
      when: manual
      allow_failure: true
  extends: ".deploy_job_k8s"
deploy_dev1_k8s_in_place:
  stage: deploy
  allow_failure: true
  trigger:
    forward:
      pipeline_variables: true
    strategy: depend
    include:
    - project: fireblocks/shell/common/templates/ci-infra
      ref: "$TEMPLATE_REF"
      file:
      - "${DEPLOYMENT_FILE_PATH}"
  variables:
    FORCE_DEPLOYMENT_FLAG: false
    PRE1_CONTINUOUS_DEPLOYMENT_FLAG: true
    DEPLOYMENT_FILE_PATH: backend-ci/stages/deployments/deploy-dev1-k8s-in-place.yml
    K8S_CLUSTER_NAME: devx-k8s
    AWS_REGION: us-east-2
    IAM_ROLE_APPLICATION: arn:aws:iam::318128524537:role/devx-application-CICD-role
  rules:
  - - if: $IS_DEPLOYABLE_SERVICE != "true"
      when: never
    - if: "$CI_COMMIT_TAG"
      when: never
    - if: "$CI_PIPELINE_SOURCE == 'merge_request_event'"
      when: never
      allow_failure: true
    - if: $STRATEGY == "in_place"
      when: manual
      allow_failure: true
  extends: ".deploy_job_k8s_in_place"
deploy_dev2:
  stage: deploy
  allow_failure: true
  needs:
  - job: build-image
  - job: build-image-nitro
    optional: true
  trigger:
    forward:
      pipeline_variables: true
    strategy: depend
    include:
    - project: fireblocks/shell/common/templates/ci-infra
      ref: main
      file:
      - "${DEPLOYMENT_FILE_PATH}"
  variables:
    FORCE_DEPLOYMENT_FLAG: false
    PRE1_CONTINUOUS_DEPLOYMENT_FLAG: true
    DEPLOYMENT_FILE_PATH: backend-ci/stages/deployments/deploy-dev2.yml
  rules:
  - - if: $IS_DEPLOYABLE_SERVICE != "true"
      when: never
    - if: "$CI_COMMIT_TAG"
      when: never
    - if: "$CI_PIPELINE_SOURCE == 'merge_request_event'"
      when: never
    - if: $STRATEGY == "classic"
      when: manual
      allow_failure: true
  extends: ".deploy_job"
deploy_dev2_k8s:
  stage: deploy
  allow_failure: true
  needs:
  - job: build-image
  - job: build-image-nitro
    optional: true
  trigger:
    forward:
      pipeline_variables: true
    strategy: depend
    include:
    - project: fireblocks/shell/common/templates/ci-infra
      ref: "$TEMPLATE_REF"
      file:
      - "${DEPLOYMENT_FILE_PATH}"
  variables:
    FORCE_DEPLOYMENT_FLAG: false
    PRE1_CONTINUOUS_DEPLOYMENT_FLAG: true
    DEPLOYMENT_FILE_PATH: backend-ci/stages/deployments/deploy-dev2-k8s.yml
    K8S_CLUSTER_NAME: devx-k8s
    AWS_REGION: us-east-2
    IAM_ROLE_APPLICATION: arn:aws:iam::318128524537:role/devx-application-CICD-role
  rules:
  - - if: $IS_DEPLOYABLE_SERVICE != "true"
      when: never
    - if: "$CI_COMMIT_TAG"
      when: never
    - if: "$CI_PIPELINE_SOURCE == 'merge_request_event'"
      when: never
    - if: $STRATEGY == "canary"
      when: manual
      allow_failure: true
  extends: ".deploy_job_k8s"
deploy_dev2_k8s_in_place:
  stage: deploy
  allow_failure: true
  trigger:
    forward:
      pipeline_variables: true
    strategy: depend
    include:
    - project: fireblocks/shell/common/templates/ci-infra
      ref: "$TEMPLATE_REF"
      file:
      - "${DEPLOYMENT_FILE_PATH}"
  variables:
    FORCE_DEPLOYMENT_FLAG: false
    PRE1_CONTINUOUS_DEPLOYMENT_FLAG: true
    DEPLOYMENT_FILE_PATH: backend-ci/stages/deployments/deploy-dev2-k8s-in-place.yml
    K8S_CLUSTER_NAME: devx-k8s
    AWS_REGION: us-east-2
    IAM_ROLE_APPLICATION: arn:aws:iam::318128524537:role/devx-application-CICD-role
  rules:
  - - if: $IS_DEPLOYABLE_SERVICE != "true"
      when: never
    - if: "$CI_COMMIT_TAG"
      when: never
    - if: "$CI_PIPELINE_SOURCE == 'merge_request_event'"
      when: never
      allow_failure: true
    - if: $STRATEGY == "in_place"
      when: manual
      allow_failure: true
  extends: ".deploy_job_k8s_in_place"
deploy_dev3:
  stage: deploy
  allow_failure: true
  needs:
  - job: build-image
  - job: build-image-nitro
    optional: true
  trigger:
    forward:
      pipeline_variables: true
    strategy: depend
    include:
    - project: fireblocks/shell/common/templates/ci-infra
      ref: main
      file:
      - "${DEPLOYMENT_FILE_PATH}"
  variables:
    FORCE_DEPLOYMENT_FLAG: false
    PRE1_CONTINUOUS_DEPLOYMENT_FLAG: true
    DEPLOYMENT_FILE_PATH: backend-ci/stages/deployments/deploy-dev3.yml
  rules:
  - - if: $IS_DEPLOYABLE_SERVICE != "true"
      when: never
    - if: "$CI_COMMIT_TAG"
      when: never
    - if: "$CI_PIPELINE_SOURCE == 'merge_request_event'"
      when: never
    - if: $STRATEGY == "classic"
      when: manual
      allow_failure: true
  extends: ".deploy_job"
deploy_dev3_k8s:
  stage: deploy
  allow_failure: true
  needs:
  - job: build-image
  - job: build-image-nitro
    optional: true
  trigger:
    forward:
      pipeline_variables: true
    strategy: depend
    include:
    - project: fireblocks/shell/common/templates/ci-infra
      ref: "$TEMPLATE_REF"
      file:
      - "${DEPLOYMENT_FILE_PATH}"
  variables:
    FORCE_DEPLOYMENT_FLAG: false
    PRE1_CONTINUOUS_DEPLOYMENT_FLAG: true
    DEPLOYMENT_FILE_PATH: backend-ci/stages/deployments/deploy-dev3-k8s.yml
    K8S_CLUSTER_NAME: devx-k8s
    AWS_REGION: us-east-2
    IAM_ROLE_APPLICATION: arn:aws:iam::318128524537:role/devx-application-CICD-role
  rules:
  - - if: $IS_DEPLOYABLE_SERVICE != "true"
      when: never
    - if: "$CI_COMMIT_TAG"
      when: never
    - if: "$CI_PIPELINE_SOURCE == 'merge_request_event'"
      when: never
    - if: $STRATEGY == "canary"
      when: manual
      allow_failure: true
  extends: ".deploy_job_k8s"
deploy_dev3_k8s_in_place:
  stage: deploy
  allow_failure: true
  trigger:
    forward:
      pipeline_variables: true
    strategy: depend
    include:
    - project: fireblocks/shell/common/templates/ci-infra
      ref: "$TEMPLATE_REF"
      file:
      - "${DEPLOYMENT_FILE_PATH}"
  variables:
    FORCE_DEPLOYMENT_FLAG: false
    PRE1_CONTINUOUS_DEPLOYMENT_FLAG: true
    DEPLOYMENT_FILE_PATH: backend-ci/stages/deployments/deploy-dev3-k8s-in-place.yml
    K8S_CLUSTER_NAME: devx-k8s
    AWS_REGION: us-east-2
    IAM_ROLE_APPLICATION: arn:aws:iam::318128524537:role/devx-application-CICD-role
  rules:
  - - if: $IS_DEPLOYABLE_SERVICE != "true"
      when: never
    - if: "$CI_COMMIT_TAG"
      when: never
    - if: "$CI_PIPELINE_SOURCE == 'merge_request_event'"
      when: never
      allow_failure: true
    - if: $STRATEGY == "in_place"
      when: manual
      allow_failure: true
  extends: ".deploy_job_k8s_in_place"
deploy_dev4:
  stage: deploy
  allow_failure: true
  needs:
  - job: build-image
  - job: build-image-nitro
    optional: true
  trigger:
    forward:
      pipeline_variables: true
    strategy: depend
    include:
    - project: fireblocks/shell/common/templates/ci-infra
      ref: main
      file:
      - "${DEPLOYMENT_FILE_PATH}"
  variables:
    FORCE_DEPLOYMENT_FLAG: false
    PRE1_CONTINUOUS_DEPLOYMENT_FLAG: true
    DEPLOYMENT_FILE_PATH: backend-ci/stages/deployments/deploy-dev4.yml
  rules:
  - - if: $IS_DEPLOYABLE_SERVICE != "true"
      when: never
    - if: "$CI_COMMIT_TAG"
      when: never
    - if: "$CI_PIPELINE_SOURCE == 'merge_request_event'"
      when: never
    - if: $STRATEGY == "classic"
      when: manual
      allow_failure: true
  extends: ".deploy_job"
deploy_dev4_k8s:
  stage: deploy
  allow_failure: true
  needs:
  - job: build-image
  - job: build-image-nitro
    optional: true
  trigger:
    forward:
      pipeline_variables: true
    strategy: depend
    include:
    - project: fireblocks/shell/common/templates/ci-infra
      ref: "$TEMPLATE_REF"
      file:
      - "${DEPLOYMENT_FILE_PATH}"
  variables:
    FORCE_DEPLOYMENT_FLAG: false
    PRE1_CONTINUOUS_DEPLOYMENT_FLAG: true
    DEPLOYMENT_FILE_PATH: backend-ci/stages/deployments/deploy-dev4-k8s.yml
    K8S_CLUSTER_NAME: devx-k8s
    AWS_REGION: us-east-2
    IAM_ROLE_APPLICATION: arn:aws:iam::318128524537:role/devx-application-CICD-role
  rules:
  - - if: $IS_DEPLOYABLE_SERVICE != "true"
      when: never
    - if: "$CI_COMMIT_TAG"
      when: never
    - if: "$CI_PIPELINE_SOURCE == 'merge_request_event'"
      when: never
    - if: $STRATEGY == "canary"
      when: manual
      allow_failure: true
  extends: ".deploy_job_k8s"
deploy_dev4_k8s_in_place:
  stage: deploy
  allow_failure: true
  trigger:
    forward:
      pipeline_variables: true
    strategy: depend
    include:
    - project: fireblocks/shell/common/templates/ci-infra
      ref: "$TEMPLATE_REF"
      file:
      - "${DEPLOYMENT_FILE_PATH}"
  variables:
    FORCE_DEPLOYMENT_FLAG: false
    PRE1_CONTINUOUS_DEPLOYMENT_FLAG: true
    DEPLOYMENT_FILE_PATH: backend-ci/stages/deployments/deploy-dev4-k8s-in-place.yml
    K8S_CLUSTER_NAME: devx-k8s
    AWS_REGION: us-east-2
    IAM_ROLE_APPLICATION: arn:aws:iam::318128524537:role/devx-application-CICD-role
  rules:
  - - if: $IS_DEPLOYABLE_SERVICE != "true"
      when: never
    - if: "$CI_COMMIT_TAG"
      when: never
    - if: "$CI_PIPELINE_SOURCE == 'merge_request_event'"
      when: never
      allow_failure: true
    - if: $STRATEGY == "in_place"
      when: manual
      allow_failure: true
  extends: ".deploy_job_k8s_in_place"
deploy_dev5:
  stage: deploy
  allow_failure: true
  needs:
  - job: build-image
  - job: build-image-nitro
    optional: true
  trigger:
    forward:
      pipeline_variables: true
    strategy: depend
    include:
    - project: fireblocks/shell/common/templates/ci-infra
      ref: main
      file:
      - "${DEPLOYMENT_FILE_PATH}"
  variables:
    FORCE_DEPLOYMENT_FLAG: false
    PRE1_CONTINUOUS_DEPLOYMENT_FLAG: true
    DEPLOYMENT_FILE_PATH: backend-ci/stages/deployments/deploy-dev5.yml
  rules:
  - - if: $IS_DEPLOYABLE_SERVICE != "true"
      when: never
    - if: "$CI_COMMIT_TAG"
      when: never
    - if: "$CI_PIPELINE_SOURCE == 'merge_request_event'"
      when: never
    - if: $STRATEGY == "classic"
      when: manual
      allow_failure: true
  extends: ".deploy_job"
deploy_dev5_k8s:
  stage: deploy
  allow_failure: true
  needs:
  - job: build-image
  - job: build-image-nitro
    optional: true
  trigger:
    forward:
      pipeline_variables: true
    strategy: depend
    include:
    - project: fireblocks/shell/common/templates/ci-infra
      ref: "$TEMPLATE_REF"
      file:
      - "${DEPLOYMENT_FILE_PATH}"
  variables:
    FORCE_DEPLOYMENT_FLAG: false
    PRE1_CONTINUOUS_DEPLOYMENT_FLAG: true
    DEPLOYMENT_FILE_PATH: backend-ci/stages/deployments/deploy-dev5-k8s.yml
    K8S_CLUSTER_NAME: devx-k8s
    AWS_REGION: us-east-2
    IAM_ROLE_APPLICATION: arn:aws:iam::318128524537:role/devx-application-CICD-role
  rules:
  - - if: $IS_DEPLOYABLE_SERVICE != "true"
      when: never
    - if: "$CI_COMMIT_TAG"
      when: never
    - if: "$CI_PIPELINE_SOURCE == 'merge_request_event'"
      when: never
    - if: $STRATEGY == "canary"
      when: manual
      allow_failure: true
  extends: ".deploy_job_k8s"
deploy_dev5_k8s_in_place:
  stage: deploy
  allow_failure: true
  trigger:
    forward:
      pipeline_variables: true
    strategy: depend
    include:
    - project: fireblocks/shell/common/templates/ci-infra
      ref: "$TEMPLATE_REF"
      file:
      - "${DEPLOYMENT_FILE_PATH}"
  variables:
    FORCE_DEPLOYMENT_FLAG: false
    PRE1_CONTINUOUS_DEPLOYMENT_FLAG: true
    DEPLOYMENT_FILE_PATH: backend-ci/stages/deployments/deploy-dev5-k8s-in-place.yml
    K8S_CLUSTER_NAME: devx-k8s
    AWS_REGION: us-east-2
    IAM_ROLE_APPLICATION: arn:aws:iam::318128524537:role/devx-application-CICD-role
  rules:
  - - if: $IS_DEPLOYABLE_SERVICE != "true"
      when: never
    - if: "$CI_COMMIT_TAG"
      when: never
    - if: "$CI_PIPELINE_SOURCE == 'merge_request_event'"
      when: never
      allow_failure: true
    - if: $STRATEGY == "in_place"
      when: manual
      allow_failure: true
  extends: ".deploy_job_k8s_in_place"
deploy_dev6:
  stage: deploy
  allow_failure: true
  needs:
  - job: build-image
  - job: build-image-nitro
    optional: true
  trigger:
    forward:
      pipeline_variables: true
    strategy: depend
    include:
    - project: fireblocks/shell/common/templates/ci-infra
      ref: main
      file:
      - "${DEPLOYMENT_FILE_PATH}"
  variables:
    FORCE_DEPLOYMENT_FLAG: false
    PRE1_CONTINUOUS_DEPLOYMENT_FLAG: true
    DEPLOYMENT_FILE_PATH: backend-ci/stages/deployments/deploy-dev6.yml
  rules:
  - - if: $IS_DEPLOYABLE_SERVICE != "true"
      when: never
    - if: "$CI_COMMIT_TAG"
      when: never
    - if: "$CI_PIPELINE_SOURCE == 'merge_request_event'"
      when: never
    - if: $STRATEGY == "classic"
      when: manual
      allow_failure: true
  extends: ".deploy_job"
deploy_dev6_k8s:
  stage: deploy
  allow_failure: true
  needs:
  - job: build-image
  - job: build-image-nitro
    optional: true
  trigger:
    forward:
      pipeline_variables: true
    strategy: depend
    include:
    - project: fireblocks/shell/common/templates/ci-infra
      ref: "$TEMPLATE_REF"
      file:
      - "${DEPLOYMENT_FILE_PATH}"
  variables:
    FORCE_DEPLOYMENT_FLAG: false
    PRE1_CONTINUOUS_DEPLOYMENT_FLAG: true
    DEPLOYMENT_FILE_PATH: backend-ci/stages/deployments/deploy-dev6-k8s.yml
    K8S_CLUSTER_NAME: devx-k8s
    AWS_REGION: us-east-2
    IAM_ROLE_APPLICATION: arn:aws:iam::318128524537:role/devx-application-CICD-role
  rules:
  - - if: $IS_DEPLOYABLE_SERVICE != "true"
      when: never
    - if: "$CI_COMMIT_TAG"
      when: never
    - if: "$CI_PIPELINE_SOURCE == 'merge_request_event'"
      when: never
    - if: $STRATEGY == "canary"
      when: manual
      allow_failure: true
  extends: ".deploy_job_k8s"
deploy_dev6_k8s_in_place:
  stage: deploy
  allow_failure: true
  trigger:
    forward:
      pipeline_variables: true
    strategy: depend
    include:
    - project: fireblocks/shell/common/templates/ci-infra
      ref: "$TEMPLATE_REF"
      file:
      - "${DEPLOYMENT_FILE_PATH}"
  variables:
    FORCE_DEPLOYMENT_FLAG: false
    PRE1_CONTINUOUS_DEPLOYMENT_FLAG: true
    DEPLOYMENT_FILE_PATH: backend-ci/stages/deployments/deploy-dev6-k8s-in-place.yml
    K8S_CLUSTER_NAME: devx-k8s
    AWS_REGION: us-east-2
    IAM_ROLE_APPLICATION: arn:aws:iam::318128524537:role/devx-application-CICD-role
  rules:
  - - if: $IS_DEPLOYABLE_SERVICE != "true"
      when: never
    - if: "$CI_COMMIT_TAG"
      when: never
    - if: "$CI_PIPELINE_SOURCE == 'merge_request_event'"
      when: never
      allow_failure: true
    - if: $STRATEGY == "in_place"
      when: manual
      allow_failure: true
  extends: ".deploy_job_k8s_in_place"
deploy_dev7:
  stage: deploy
  allow_failure: true
  needs:
  - job: build-image
  - job: build-image-nitro
    optional: true
  trigger:
    forward:
      pipeline_variables: true
    strategy: depend
    include:
    - project: fireblocks/shell/common/templates/ci-infra
      ref: main
      file:
      - "${DEPLOYMENT_FILE_PATH}"
  variables:
    FORCE_DEPLOYMENT_FLAG: false
    PRE1_CONTINUOUS_DEPLOYMENT_FLAG: true
    DEPLOYMENT_FILE_PATH: backend-ci/stages/deployments/deploy-dev7.yml
  rules:
  - - if: $IS_DEPLOYABLE_SERVICE != "true"
      when: never
    - if: "$CI_COMMIT_TAG"
      when: never
    - if: "$CI_PIPELINE_SOURCE == 'merge_request_event'"
      when: never
    - if: $STRATEGY == "classic"
      when: manual
      allow_failure: true
  extends: ".deploy_job"
deploy_dev7_k8s:
  stage: deploy
  allow_failure: true
  needs:
  - job: build-image
  - job: build-image-nitro
    optional: true
  trigger:
    forward:
      pipeline_variables: true
    strategy: depend
    include:
    - project: fireblocks/shell/common/templates/ci-infra
      ref: "$TEMPLATE_REF"
      file:
      - "${DEPLOYMENT_FILE_PATH}"
  variables:
    FORCE_DEPLOYMENT_FLAG: false
    PRE1_CONTINUOUS_DEPLOYMENT_FLAG: true
    DEPLOYMENT_FILE_PATH: backend-ci/stages/deployments/deploy-dev7-k8s.yml
    K8S_CLUSTER_NAME: devx-k8s
    AWS_REGION: us-east-2
    IAM_ROLE_APPLICATION: arn:aws:iam::318128524537:role/devx-application-CICD-role
  rules:
  - - if: $IS_DEPLOYABLE_SERVICE != "true"
      when: never
    - if: "$CI_COMMIT_TAG"
      when: never
    - if: "$CI_PIPELINE_SOURCE == 'merge_request_event'"
      when: never
    - if: $STRATEGY == "canary"
      when: manual
      allow_failure: true
  extends: ".deploy_job_k8s"
deploy_dev7_k8s_in_place:
  stage: deploy
  allow_failure: true
  trigger:
    forward:
      pipeline_variables: true
    strategy: depend
    include:
    - project: fireblocks/shell/common/templates/ci-infra
      ref: "$TEMPLATE_REF"
      file:
      - "${DEPLOYMENT_FILE_PATH}"
  variables:
    FORCE_DEPLOYMENT_FLAG: false
    PRE1_CONTINUOUS_DEPLOYMENT_FLAG: true
    DEPLOYMENT_FILE_PATH: backend-ci/stages/deployments/deploy-dev7-k8s-in-place.yml
    K8S_CLUSTER_NAME: devx-k8s
    AWS_REGION: us-east-2
    IAM_ROLE_APPLICATION: arn:aws:iam::318128524537:role/devx-application-CICD-role
  rules:
  - - if: $IS_DEPLOYABLE_SERVICE != "true"
      when: never
    - if: "$CI_COMMIT_TAG"
      when: never
    - if: "$CI_PIPELINE_SOURCE == 'merge_request_event'"
      when: never
      allow_failure: true
    - if: $STRATEGY == "in_place"
      when: manual
      allow_failure: true
  extends: ".deploy_job_k8s_in_place"
deploy_dev8:
  stage: deploy
  allow_failure: true
  needs:
  - job: build-image
  - job: build-image-nitro
    optional: true
  trigger:
    forward:
      pipeline_variables: true
    strategy: depend
    include:
    - project: fireblocks/shell/common/templates/ci-infra
      ref: main
      file:
      - "${DEPLOYMENT_FILE_PATH}"
  variables:
    FORCE_DEPLOYMENT_FLAG: false
    PRE1_CONTINUOUS_DEPLOYMENT_FLAG: true
    DEPLOYMENT_FILE_PATH: backend-ci/stages/deployments/deploy-dev8.yml
  rules:
  - - if: $IS_DEPLOYABLE_SERVICE != "true"
      when: never
    - if: "$CI_COMMIT_TAG"
      when: never
    - if: "$CI_PIPELINE_SOURCE == 'merge_request_event'"
      when: never
    - if: $STRATEGY == "classic"
      when: manual
      allow_failure: true
  extends: ".deploy_job"
deploy_dev8_k8s:
  stage: deploy
  allow_failure: true
  needs:
  - job: build-image
  - job: build-image-nitro
    optional: true
  trigger:
    forward:
      pipeline_variables: true
    strategy: depend
    include:
    - project: fireblocks/shell/common/templates/ci-infra
      ref: "$TEMPLATE_REF"
      file:
      - "${DEPLOYMENT_FILE_PATH}"
  variables:
    FORCE_DEPLOYMENT_FLAG: false
    PRE1_CONTINUOUS_DEPLOYMENT_FLAG: true
    DEPLOYMENT_FILE_PATH: backend-ci/stages/deployments/deploy-dev8-k8s.yml
    K8S_CLUSTER_NAME: devx-k8s
    AWS_REGION: us-east-2
    IAM_ROLE_APPLICATION: arn:aws:iam::318128524537:role/devx-application-CICD-role
  rules:
  - - if: $IS_DEPLOYABLE_SERVICE != "true"
      when: never
    - if: "$CI_COMMIT_TAG"
      when: never
    - if: "$CI_PIPELINE_SOURCE == 'merge_request_event'"
      when: never
    - if: $STRATEGY == "canary"
      when: manual
      allow_failure: true
  extends: ".deploy_job_k8s"
deploy_dev8_k8s_in_place:
  stage: deploy
  allow_failure: true
  trigger:
    forward:
      pipeline_variables: true
    strategy: depend
    include:
    - project: fireblocks/shell/common/templates/ci-infra
      ref: "$TEMPLATE_REF"
      file:
      - "${DEPLOYMENT_FILE_PATH}"
  variables:
    FORCE_DEPLOYMENT_FLAG: false
    PRE1_CONTINUOUS_DEPLOYMENT_FLAG: true
    DEPLOYMENT_FILE_PATH: backend-ci/stages/deployments/deploy-dev8-k8s-in-place.yml
    K8S_CLUSTER_NAME: devx-k8s
    AWS_REGION: us-east-2
    IAM_ROLE_APPLICATION: arn:aws:iam::318128524537:role/devx-application-CICD-role
  rules:
  - - if: $IS_DEPLOYABLE_SERVICE != "true"
      when: never
    - if: "$CI_COMMIT_TAG"
      when: never
    - if: "$CI_PIPELINE_SOURCE == 'merge_request_event'"
      when: never
      allow_failure: true
    - if: $STRATEGY == "in_place"
      when: manual
      allow_failure: true
  extends: ".deploy_job_k8s_in_place"
deploy_dev9:
  stage: deploy
  allow_failure: true
  needs:
  - job: build-image
  - job: build-image-nitro
    optional: true
  trigger:
    forward:
      pipeline_variables: true
    strategy: depend
    include:
    - project: fireblocks/shell/common/templates/ci-infra
      ref: main
      file:
      - "${DEPLOYMENT_FILE_PATH}"
  variables:
    FORCE_DEPLOYMENT_FLAG: false
    PRE1_CONTINUOUS_DEPLOYMENT_FLAG: true
    DEPLOYMENT_FILE_PATH: backend-ci/stages/deployments/deploy-dev9.yml
  rules:
  - - if: $IS_DEPLOYABLE_SERVICE != "true"
      when: never
    - if: "$CI_COMMIT_TAG"
      when: never
    - if: "$CI_PIPELINE_SOURCE == 'merge_request_event'"
      when: never
    - if: $STRATEGY == "classic"
      when: manual
      allow_failure: true
  extends: ".deploy_job"
deploy_dev9_k8s:
  stage: deploy
  allow_failure: true
  needs:
  - job: build-image
  - job: build-image-nitro
    optional: true
  trigger:
    forward:
      pipeline_variables: true
    strategy: depend
    include:
    - project: fireblocks/shell/common/templates/ci-infra
      ref: "$TEMPLATE_REF"
      file:
      - "${DEPLOYMENT_FILE_PATH}"
  variables:
    FORCE_DEPLOYMENT_FLAG: false
    PRE1_CONTINUOUS_DEPLOYMENT_FLAG: true
    DEPLOYMENT_FILE_PATH: backend-ci/stages/deployments/deploy-dev9-k8s.yml
    K8S_CLUSTER_NAME: devx-k8s
    AWS_REGION: us-east-2
    IAM_ROLE_APPLICATION: arn:aws:iam::318128524537:role/devx-application-CICD-role
  rules:
  - - if: $IS_DEPLOYABLE_SERVICE != "true"
      when: never
    - if: "$CI_COMMIT_TAG"
      when: never
    - if: "$CI_PIPELINE_SOURCE == 'merge_request_event'"
      when: never
    - if: $STRATEGY == "canary"
      when: manual
      allow_failure: true
  extends: ".deploy_job_k8s"
deploy_dev9_k8s_in_place:
  stage: deploy
  allow_failure: true
  trigger:
    forward:
      pipeline_variables: true
    strategy: depend
    include:
    - project: fireblocks/shell/common/templates/ci-infra
      ref: "$TEMPLATE_REF"
      file:
      - "${DEPLOYMENT_FILE_PATH}"
  variables:
    FORCE_DEPLOYMENT_FLAG: false
    PRE1_CONTINUOUS_DEPLOYMENT_FLAG: true
    DEPLOYMENT_FILE_PATH: backend-ci/stages/deployments/deploy-dev9-k8s-in-place.yml
    K8S_CLUSTER_NAME: devx-k8s
    AWS_REGION: us-east-2
    IAM_ROLE_APPLICATION: arn:aws:iam::318128524537:role/devx-application-CICD-role
  rules:
  - - if: $IS_DEPLOYABLE_SERVICE != "true"
      when: never
    - if: "$CI_COMMIT_TAG"
      when: never
    - if: "$CI_PIPELINE_SOURCE == 'merge_request_event'"
      when: never
      allow_failure: true
    - if: $STRATEGY == "in_place"
      when: manual
      allow_failure: true
  extends: ".deploy_job_k8s_in_place"
deploy_dev10:
  stage: deploy
  allow_failure: true
  needs:
  - job: build-image
  - job: build-image-nitro
    optional: true
  trigger:
    forward:
      pipeline_variables: true
    strategy: depend
    include:
    - project: fireblocks/shell/common/templates/ci-infra
      ref: main
      file:
      - "${DEPLOYMENT_FILE_PATH}"
  variables:
    FORCE_DEPLOYMENT_FLAG: false
    PRE1_CONTINUOUS_DEPLOYMENT_FLAG: true
    DEPLOYMENT_FILE_PATH: backend-ci/stages/deployments/deploy-dev10.yml
  rules:
  - - if: $IS_DEPLOYABLE_SERVICE != "true"
      when: never
    - if: "$CI_COMMIT_TAG"
      when: never
    - if: "$CI_PIPELINE_SOURCE == 'merge_request_event'"
      when: never
    - if: $STRATEGY == "classic"
      when: manual
      allow_failure: true
  extends: ".deploy_job"
deploy_dev10_k8s:
  stage: deploy
  allow_failure: true
  needs:
  - job: build-image
  - job: build-image-nitro
    optional: true
  trigger:
    forward:
      pipeline_variables: true
    strategy: depend
    include:
    - project: fireblocks/shell/common/templates/ci-infra
      ref: "$TEMPLATE_REF"
      file:
      - "${DEPLOYMENT_FILE_PATH}"
  variables:
    FORCE_DEPLOYMENT_FLAG: false
    PRE1_CONTINUOUS_DEPLOYMENT_FLAG: true
    DEPLOYMENT_FILE_PATH: backend-ci/stages/deployments/deploy-dev10-k8s.yml
    K8S_CLUSTER_NAME: devx-k8s
    AWS_REGION: us-east-2
    IAM_ROLE_APPLICATION: arn:aws:iam::318128524537:role/devx-application-CICD-role
  rules:
  - - if: $IS_DEPLOYABLE_SERVICE != "true"
      when: never
    - if: "$CI_COMMIT_TAG"
      when: never
    - if: "$CI_PIPELINE_SOURCE == 'merge_request_event'"
      when: never
    - if: $STRATEGY == "canary"
      when: manual
      allow_failure: true
  extends: ".deploy_job_k8s"
deploy_dev10_k8s_in_place:
  stage: deploy
  allow_failure: true
  trigger:
    forward:
      pipeline_variables: true
    strategy: depend
    include:
    - project: fireblocks/shell/common/templates/ci-infra
      ref: "$TEMPLATE_REF"
      file:
      - "${DEPLOYMENT_FILE_PATH}"
  variables:
    FORCE_DEPLOYMENT_FLAG: false
    PRE1_CONTINUOUS_DEPLOYMENT_FLAG: true
    DEPLOYMENT_FILE_PATH: backend-ci/stages/deployments/deploy-dev10-k8s-in-place.yml
    K8S_CLUSTER_NAME: devx-k8s
    AWS_REGION: us-east-2
    IAM_ROLE_APPLICATION: arn:aws:iam::318128524537:role/devx-application-CICD-role
  rules:
  - - if: $IS_DEPLOYABLE_SERVICE != "true"
      when: never
    - if: "$CI_COMMIT_TAG"
      when: never
    - if: "$CI_PIPELINE_SOURCE == 'merge_request_event'"
      when: never
      allow_failure: true
    - if: $STRATEGY == "in_place"
      when: manual
      allow_failure: true
  extends: ".deploy_job_k8s_in_place"
deploy_stage:
  stage: deploy
  allow_failure: true
  needs:
  - job: build-image
  - job: build-image-nitro
    optional: true
  trigger:
    forward:
      pipeline_variables: true
    strategy: depend
    include:
    - project: fireblocks/shell/common/templates/ci-infra
      ref: main
      file:
      - "${DEPLOYMENT_FILE_PATH}"
  variables:
    FORCE_DEPLOYMENT_FLAG: false
    PRE1_CONTINUOUS_DEPLOYMENT_FLAG: true
    DEPLOYMENT_FILE_PATH: backend-ci/stages/deployments/deploy-stage.yml
  rules:
  - - if: $IS_DEPLOYABLE_SERVICE != "true"
      when: never
    - if: "$CI_COMMIT_TAG"
      when: never
    - if: "$CI_PIPELINE_SOURCE == 'merge_request_event'"
      when: never
    - if: $STRATEGY == "classic"
      when: manual
      allow_failure: true
  extends: ".deploy_job"
deploy_stage_k8s:
  stage: deploy
  allow_failure: true
  needs:
  - job: build-image
  - job: build-image-nitro
    optional: true
  trigger:
    forward:
      pipeline_variables: true
    strategy: depend
    include:
    - project: fireblocks/shell/common/templates/ci-infra
      ref: "$TEMPLATE_REF"
      file:
      - "${DEPLOYMENT_FILE_PATH}"
  variables:
    FORCE_DEPLOYMENT_FLAG: false
    PRE1_CONTINUOUS_DEPLOYMENT_FLAG: true
    DEPLOYMENT_FILE_PATH: backend-ci/stages/deployments/deploy-stage-k8s.yml
    K8S_CLUSTER_NAME: stage-k8s
    AWS_REGION: us-east-2
    IAM_ROLE_APPLICATION: arn:aws:iam::508935315618:role/stage-application-CICD-role
  rules:
  - - if: $IS_DEPLOYABLE_SERVICE != "true"
      when: never
    - if: "$CI_COMMIT_TAG"
      when: never
    - if: "$CI_PIPELINE_SOURCE == 'merge_request_event'"
      when: never
    - if: $STRATEGY == "canary"
      when: manual
      allow_failure: true
  extends: ".deploy_job_k8s"
deploy_stage_k8s_in_place:
  stage: deploy
  allow_failure: true
  trigger:
    forward:
      pipeline_variables: true
    strategy: depend
    include:
    - project: fireblocks/shell/common/templates/ci-infra
      ref: "$TEMPLATE_REF"
      file:
      - "${DEPLOYMENT_FILE_PATH}"
  variables:
    FORCE_DEPLOYMENT_FLAG: false
    PRE1_CONTINUOUS_DEPLOYMENT_FLAG: true
    DEPLOYMENT_FILE_PATH: backend-ci/stages/deployments/deploy-stage-k8s-in-place.yml
    K8S_CLUSTER_NAME: stage-k8s
    AWS_REGION: us-east-2
    IAM_ROLE_APPLICATION: arn:aws:iam::508935315618:role/stage-application-CICD-role
  rules:
  - - if: $IS_DEPLOYABLE_SERVICE != "true"
      when: never
    - if: "$CI_COMMIT_TAG"
      when: never
    - if: "$CI_PIPELINE_SOURCE == 'merge_request_event'"
      when: never
      allow_failure: true
    - if: $STRATEGY == "in_place"
      when: manual
      allow_failure: true
  extends: ".deploy_job_k8s_in_place"
deploy_pre1:
  stage: deploy
  allow_failure: true
  needs:
  - job: build-image
  - job: build-image-nitro
    optional: true
  trigger:
    forward:
      pipeline_variables: true
    strategy: depend
    include:
    - project: fireblocks/shell/common/templates/ci-infra
      ref: main
      file:
      - "${DEPLOYMENT_FILE_PATH}"
  variables:
    FORCE_DEPLOYMENT_FLAG: false
    PRE1_CONTINUOUS_DEPLOYMENT_FLAG: true
    DEPLOYMENT_FILE_PATH: backend-ci/stages/deployments/deploy-pre1.yml
  rules:
  - if: $IS_DEPLOYABLE_SERVICE != "true"
    when: never
  - if: "$CI_PIPELINE_SOURCE == 'merge_request_event'"
    when: never
  - if: ($CI_COMMIT_BRANCH == "master" || $CI_COMMIT_BRANCH == "main") && $PRE1_CONTINUOUS_DEPLOYMENT_FLAG
      == "true" && $STRATEGY == "classic"
    when: on_success
  extends: ".deploy_job"
deploy_pre1_k8s:
  stage: deploy
  allow_failure: true
  needs:
  - job: build-image
  - job: build-image-nitro
    optional: true
  trigger:
    forward:
      pipeline_variables: true
    strategy: depend
    include:
    - project: fireblocks/shell/common/templates/ci-infra
      ref: "$TEMPLATE_REF"
      file:
      - "${DEPLOYMENT_FILE_PATH}"
  variables:
    FORCE_DEPLOYMENT_FLAG: false
    PRE1_CONTINUOUS_DEPLOYMENT_FLAG: true
    DEPLOYMENT_FILE_PATH: backend-ci/stages/deployments/deploy-pre1-k8s.yml
    K8S_CLUSTER_NAME: pre1-k8s
    AWS_REGION: us-east-2
    IAM_ROLE_APPLICATION: arn:aws:iam::579897745075:role/pre1-application-CICD-role
  rules:
  - if: $IS_DEPLOYABLE_SERVICE != "true"
    when: never
  - if: "$CI_PIPELINE_SOURCE == 'merge_request_event'"
    when: never
  - if: ($CI_COMMIT_BRANCH == "master" || $CI_COMMIT_BRANCH == "main") && $PRE1_CONTINUOUS_DEPLOYMENT_FLAG
      == "true" && $STRATEGY == "canary"
    when: on_success
  extends: ".deploy_job_k8s"
deploy_pre1_k8s_in_place:
  stage: deploy
  allow_failure: true
  trigger:
    forward:
      pipeline_variables: true
    strategy: depend
    include:
    - project: fireblocks/shell/common/templates/ci-infra
      ref: "$TEMPLATE_REF"
      file:
      - "${DEPLOYMENT_FILE_PATH}"
  variables:
    FORCE_DEPLOYMENT_FLAG: false
    PRE1_CONTINUOUS_DEPLOYMENT_FLAG: true
    DEPLOYMENT_FILE_PATH: backend-ci/stages/deployments/deploy-pre1-k8s-in-place.yml
    K8S_CLUSTER_NAME: pre1-k8s
    AWS_REGION: us-east-2
    IAM_ROLE_APPLICATION: arn:aws:iam::579897745075:role/pre1-application-CICD-role
  rules:
  - if: $IS_DEPLOYABLE_SERVICE != "true"
    when: never
  - if: "$CI_PIPELINE_SOURCE == 'merge_request_event'"
    when: never
  - if: ($CI_COMMIT_BRANCH == "master" || $CI_COMMIT_BRANCH == "main") && $PRE1_CONTINUOUS_DEPLOYMENT_FLAG
      == "true" && $STRATEGY == "in_place"
    when: on_success
  extends: ".deploy_job_k8s_in_place"
".stop_deployment":
  stage: deploy
  allow_failure: true
  needs: []
  rules:
  - if: "$CI_COMMIT_TAG"
    when: never
  - if: "$CI_PIPELINE_SOURCE == 'merge_request_event'"
    when: never
  - when: manual
    allow_failure: true
".deploy_prod-trigger":
  stage: deploy-prod
  allow_failure: true
  rules:
  - - if: $IS_DEPLOYABLE_SERVICE != "true"
      when: never
    - if: $IS_PROD_SERVICE != "true"
      when: never
    - if: "$CI_PIPELINE_SOURCE == 'merge_request_event'"
      when: never
    - if: ($CI_COMMIT_BRANCH == "master" || $CI_COMMIT_BRANCH == "main") && $STRATEGY
        == "classic"
      when: manual
  needs:
  - build-image
  trigger:
    forward:
      pipeline_variables: true
    strategy: depend
    include:
    - project: fireblocks/shell/common/templates/ci-infra
      ref: main
      file:
      - "${DEPLOYMENT_FILE_PATH}"
  variables:
    FORCE_DEPLOYMENT_FLAG: false
".deploy_prod_trigger_k8s":
  stage: deploy-prod
  allow_failure: true
  rules:
  - - if: $IS_DEPLOYABLE_SERVICE != "true"
      when: never
    - if: $IS_PROD_SERVICE != "true"
      when: never
    - if: "$CI_PIPELINE_SOURCE == 'merge_request_event'"
      when: never
    - if: ($CI_COMMIT_BRANCH == "master" || $CI_COMMIT_BRANCH == "main") && $STRATEGY
        == "canary"
      when: manual
  needs:
  - build-image
  trigger:
    forward:
      pipeline_variables: true
    strategy: depend
    include:
    - project: fireblocks/shell/common/templates/ci-infra
      ref: "$TEMPLATE_REF"
      file:
      - "${DEPLOYMENT_FILE_PATH}"
  variables:
    FORCE_DEPLOYMENT_FLAG: false
".deploy_prod_trigger_k8s_in_place":
  stage: deploy-prod-in-place
  allow_failure: true
  rules:
  - - if: $IS_DEPLOYABLE_SERVICE != "true"
      when: never
    - if: $IS_PROD_SERVICE != "true"
      when: never
    - if: "$CI_PIPELINE_SOURCE == 'merge_request_event'"
      when: never
    - if: ($CI_COMMIT_BRANCH == "master" || $CI_COMMIT_BRANCH == "main") && $STRATEGY
        == "in_place"
      when: manual
  needs:
  - build-image
  trigger:
    forward:
      pipeline_variables: true
    strategy: depend
    include:
    - project: fireblocks/shell/common/templates/ci-infra
      ref: "$TEMPLATE_REF"
      file:
      - "${DEPLOYMENT_FILE_PATH}"
  variables:
    FORCE_DEPLOYMENT_FLAG: false
deploy_prod-us:
  stage: deploy-prod
  allow_failure: false
  rules:
  - - if: $IS_DEPLOYABLE_SERVICE != "true"
      when: never
    - if: $IS_PROD_SERVICE != "true"
      when: never
    - if: "$CI_PIPELINE_SOURCE == 'merge_request_event'"
      when: never
    - if: ($CI_COMMIT_BRANCH == "master" || $CI_COMMIT_BRANCH == "main") && $STRATEGY
        == "classic"
      when: manual
  needs:
  - build-image
  trigger:
    forward:
      pipeline_variables: true
    strategy: depend
    include:
    - project: fireblocks/shell/common/templates/ci-infra
      ref: main
      file:
      - "${DEPLOYMENT_FILE_PATH}"
  variables:
    FORCE_DEPLOYMENT_FLAG: false
    DEPLOYMENT_FILE_PATH: backend-ci/stages/deployments/deployments-prod/deploy-prod-us.yml
  extends: ".deploy_prod-trigger"
deploy_us_prod_k8s:
  stage: deploy-prod
  allow_failure: false
  rules:
  - - if: $IS_DEPLOYABLE_SERVICE != "true"
      when: never
    - if: $IS_PROD_SERVICE != "true"
      when: never
    - if: "$CI_PIPELINE_SOURCE == 'merge_request_event'"
      when: never
    - if: ($CI_COMMIT_BRANCH == "master" || $CI_COMMIT_BRANCH == "main") && $STRATEGY
        == "canary"
      when: manual
  needs:
  - build-image
  trigger:
    forward:
      pipeline_variables: true
    strategy: depend
    include:
    - project: fireblocks/shell/common/templates/ci-infra
      ref: "$TEMPLATE_REF"
      file:
      - "${DEPLOYMENT_FILE_PATH}"
  variables:
    FORCE_DEPLOYMENT_FLAG: false
    DEPLOYMENT_FILE_PATH: backend-ci/stages/deployments/deployments-prod/deploy-prod-us-prod-k8s.yml
    K8S_CLUSTER_NAME: us-prod-k8s
    AWS_REGION: us-east-2
    IAM_ROLE_APPLICATION: arn:aws:iam::808451231866:role/us-prod-application-CICD-role
  extends: ".deploy_prod_trigger_k8s"
deploy_us_prod_k8s_in_place:
  stage: deploy-prod-in-place
  allow_failure: false
  rules:
  - - if: $IS_DEPLOYABLE_SERVICE != "true"
      when: never
    - if: $IS_PROD_SERVICE != "true"
      when: never
    - if: "$CI_PIPELINE_SOURCE == 'merge_request_event'"
      when: never
    - if: ($CI_COMMIT_BRANCH == "master" || $CI_COMMIT_BRANCH == "main") && $STRATEGY
        == "in_place"
      when: manual
  needs:
  - build-image
  trigger:
    forward:
      pipeline_variables: true
    strategy: depend
    include:
    - project: fireblocks/shell/common/templates/ci-infra
      ref: "$TEMPLATE_REF"
      file:
      - "${DEPLOYMENT_FILE_PATH}"
  variables:
    FORCE_DEPLOYMENT_FLAG: false
    DEPLOYMENT_FILE_PATH: backend-ci/stages/deployments/deployments-prod/deploy-prod-us-prod-k8s-in-place.yml
    K8S_CLUSTER_NAME: us-prod-k8s
    AWS_REGION: us-east-2
    IAM_ROLE_APPLICATION: arn:aws:iam::808451231866:role/us-prod-application-CICD-role
  extends: ".deploy_prod_trigger_k8s_in_place"
deploy_prod-sandbox:
  stage: deploy-prod
  allow_failure: true
  rules:
  - - if: $IS_DEPLOYABLE_SERVICE != "true"
      when: never
    - if: $IS_PROD_SERVICE != "true"
      when: never
    - if: "$CI_PIPELINE_SOURCE == 'merge_request_event'"
      when: never
    - if: ($CI_COMMIT_BRANCH == "master" || $CI_COMMIT_BRANCH == "main") && $STRATEGY
        == "classic"
      when: manual
  needs:
  - build-image
  trigger:
    forward:
      pipeline_variables: true
    strategy: depend
    include:
    - project: fireblocks/shell/common/templates/ci-infra
      ref: main
      file:
      - "${DEPLOYMENT_FILE_PATH}"
  variables:
    FORCE_DEPLOYMENT_FLAG: false
    DEPLOYMENT_FILE_PATH: backend-ci/stages/deployments/deployments-prod/deploy-prod-sandbox.yml
  extends: ".deploy_prod-trigger"
deploy_prod_sandbox_k8s:
  stage: deploy-prod
  allow_failure: true
  rules:
  - - if: $IS_DEPLOYABLE_SERVICE != "true"
      when: never
    - if: $IS_PROD_SERVICE != "true"
      when: never
    - if: "$CI_PIPELINE_SOURCE == 'merge_request_event'"
      when: never
    - if: ($CI_COMMIT_BRANCH == "master" || $CI_COMMIT_BRANCH == "main") && $STRATEGY
        == "canary"
      when: manual
  needs:
  - build-image
  trigger:
    forward:
      pipeline_variables: true
    strategy: depend
    include:
    - project: fireblocks/shell/common/templates/ci-infra
      ref: "$TEMPLATE_REF"
      file:
      - "${DEPLOYMENT_FILE_PATH}"
  variables:
    FORCE_DEPLOYMENT_FLAG: false
    DEPLOYMENT_FILE_PATH: backend-ci/stages/deployments/deployments-prod/deploy-prod-sandbox-k8s.yml
    K8S_CLUSTER_NAME: dlg-sandbox-k8s
    AWS_REGION: us-east-2
    IAM_ROLE_APPLICATION: arn:aws:iam::751886943440:role/sandbox-application-CICD-role
  extends: ".deploy_prod_trigger_k8s"
deploy_prod_sandbox_k8s_in_place:
  stage: deploy-prod-in-place
  allow_failure: true
  rules:
  - - if: $IS_DEPLOYABLE_SERVICE != "true"
      when: never
    - if: $IS_PROD_SERVICE != "true"
      when: never
    - if: "$CI_PIPELINE_SOURCE == 'merge_request_event'"
      when: never
    - if: ($CI_COMMIT_BRANCH == "master" || $CI_COMMIT_BRANCH == "main") && $STRATEGY
        == "in_place"
      when: manual
  needs:
  - build-image
  trigger:
    forward:
      pipeline_variables: true
    strategy: depend
    include:
    - project: fireblocks/shell/common/templates/ci-infra
      ref: "$TEMPLATE_REF"
      file:
      - "${DEPLOYMENT_FILE_PATH}"
  variables:
    FORCE_DEPLOYMENT_FLAG: false
    DEPLOYMENT_FILE_PATH: backend-ci/stages/deployments/deployments-prod/deploy-prod-sandbox-k8s-in-place.yml
    K8S_CLUSTER_NAME: dlg-sandbox-k8s
    AWS_REGION: us-east-2
    IAM_ROLE_APPLICATION: arn:aws:iam::751886943440:role/sandbox-application-CICD-role
  extends: ".deploy_prod_trigger_k8s_in_place"
deploy_eu-prod-fr:
  stage: deploy-prod
  allow_failure: true
  rules:
  - - if: $IS_DEPLOYABLE_SERVICE != "true"
      when: never
    - if: $IS_PROD_SERVICE != "true"
      when: never
    - if: "$CI_PIPELINE_SOURCE == 'merge_request_event'"
      when: never
    - if: ($CI_COMMIT_BRANCH == "master" || $CI_COMMIT_BRANCH == "main") && $STRATEGY
        == "classic"
      when: manual
  needs:
  - build-image
  trigger:
    forward:
      pipeline_variables: true
    strategy: depend
    include:
    - project: fireblocks/shell/common/templates/ci-infra
      ref: main
      file:
      - "${DEPLOYMENT_FILE_PATH}"
  variables:
    FORCE_DEPLOYMENT_FLAG: false
    DEPLOYMENT_FILE_PATH: backend-ci/stages/deployments/deployments-prod/deploy-prod-eu.yml
  extends: ".deploy_prod-trigger"
deploy_eu_prod_k8s:
  stage: deploy-prod
  allow_failure: true
  rules:
  - - if: $IS_DEPLOYABLE_SERVICE != "true"
      when: never
    - if: $IS_PROD_SERVICE != "true"
      when: never
    - if: "$CI_PIPELINE_SOURCE == 'merge_request_event'"
      when: never
    - if: ($CI_COMMIT_BRANCH == "master" || $CI_COMMIT_BRANCH == "main") && $STRATEGY
        == "canary"
      when: manual
  needs:
  - build-image
  trigger:
    forward:
      pipeline_variables: true
    strategy: depend
    include:
    - project: fireblocks/shell/common/templates/ci-infra
      ref: "$TEMPLATE_REF"
      file:
      - "${DEPLOYMENT_FILE_PATH}"
  variables:
    FORCE_DEPLOYMENT_FLAG: false
    DEPLOYMENT_FILE_PATH: backend-ci/stages/deployments/deployments-prod/deploy-prod-eu-prod-k8s.yml
    K8S_CLUSTER_NAME: eu-prod-fr-shell
    AWS_REGION: eu-central-1
    IAM_ROLE_APPLICATION: arn:aws:iam::455399297295:role/eu-prod-fr-application-CICD-role
  extends: ".deploy_prod_trigger_k8s"
deploy_eu_prod_k8s_in_place:
  stage: deploy-prod-in-place
  allow_failure: true
  rules:
  - - if: $IS_DEPLOYABLE_SERVICE != "true"
      when: never
    - if: $IS_PROD_SERVICE != "true"
      when: never
    - if: "$CI_PIPELINE_SOURCE == 'merge_request_event'"
      when: never
    - if: ($CI_COMMIT_BRANCH == "master" || $CI_COMMIT_BRANCH == "main") && $STRATEGY
        == "in_place"
      when: manual
  needs:
  - build-image
  trigger:
    forward:
      pipeline_variables: true
    strategy: depend
    include:
    - project: fireblocks/shell/common/templates/ci-infra
      ref: "$TEMPLATE_REF"
      file:
      - "${DEPLOYMENT_FILE_PATH}"
  variables:
    FORCE_DEPLOYMENT_FLAG: false
    DEPLOYMENT_FILE_PATH: backend-ci/stages/deployments/deployments-prod/deploy-prod-eu-prod-k8s-in-place.yml
    K8S_CLUSTER_NAME: eu-prod-fr-shell
    AWS_REGION: eu-central-1
    IAM_ROLE_APPLICATION: arn:aws:iam::455399297295:role/eu-prod-fr-application-CICD-role
  extends: ".deploy_prod_trigger_k8s_in_place"
deploy_eu2-prod-fr:
  stage: deploy-prod
  allow_failure: true
  rules:
  - - if: $IS_DEPLOYABLE_SERVICE != "true"
      when: never
    - if: $IS_PROD_SERVICE != "true"
      when: never
    - if: "$CI_PIPELINE_SOURCE == 'merge_request_event'"
      when: never
    - if: ($CI_COMMIT_BRANCH == "master" || $CI_COMMIT_BRANCH == "main") && $STRATEGY
        == "classic"
      when: manual
  needs:
  - build-image
  trigger:
    forward:
      pipeline_variables: true
    strategy: depend
    include:
    - project: fireblocks/shell/common/templates/ci-infra
      ref: main
      file:
      - "${DEPLOYMENT_FILE_PATH}"
  variables:
    FORCE_DEPLOYMENT_FLAG: false
    DEPLOYMENT_FILE_PATH: backend-ci/stages/deployments/deployments-prod/deploy-prod-eu2.yml
  extends: ".deploy_prod-trigger"
deploy_eu2_prod_k8s:
  stage: deploy-prod
  allow_failure: true
  rules:
  - - if: $IS_DEPLOYABLE_SERVICE != "true"
      when: never
    - if: $IS_PROD_SERVICE != "true"
      when: never
    - if: "$CI_PIPELINE_SOURCE == 'merge_request_event'"
      when: never
    - if: ($CI_COMMIT_BRANCH == "master" || $CI_COMMIT_BRANCH == "main") && $STRATEGY
        == "canary"
      when: manual
  needs:
  - build-image
  trigger:
    forward:
      pipeline_variables: true
    strategy: depend
    include:
    - project: fireblocks/shell/common/templates/ci-infra
      ref: "$TEMPLATE_REF"
      file:
      - "${DEPLOYMENT_FILE_PATH}"
  variables:
    FORCE_DEPLOYMENT_FLAG: false
    DEPLOYMENT_FILE_PATH: backend-ci/stages/deployments/deployments-prod/deploy-prod-eu2-prod-k8s.yml
    K8S_CLUSTER_NAME: eu2-prod-fr-shell
    AWS_REGION: eu-central-1
    IAM_ROLE_APPLICATION: arn:aws:iam::803035224331:role/eu2-prod-fr-application-CICD-role
  extends: ".deploy_prod_trigger_k8s"
deploy_eu2_prod_k8s_in_place:
  stage: deploy-prod-in-place
  allow_failure: true
  rules:
  - - if: $IS_DEPLOYABLE_SERVICE != "true"
      when: never
    - if: $IS_PROD_SERVICE != "true"
      when: never
    - if: "$CI_PIPELINE_SOURCE == 'merge_request_event'"
      when: never
    - if: ($CI_COMMIT_BRANCH == "master" || $CI_COMMIT_BRANCH == "main") && $STRATEGY
        == "in_place"
      when: manual
  needs:
  - build-image
  trigger:
    forward:
      pipeline_variables: true
    strategy: depend
    include:
    - project: fireblocks/shell/common/templates/ci-infra
      ref: "$TEMPLATE_REF"
      file:
      - "${DEPLOYMENT_FILE_PATH}"
  variables:
    FORCE_DEPLOYMENT_FLAG: false
    DEPLOYMENT_FILE_PATH: backend-ci/stages/deployments/deployments-prod/deploy-prod-eu2-prod-k8s-in-place.yml
    K8S_CLUSTER_NAME: eu2-prod-fr-shell
    AWS_REGION: eu-central-1
    IAM_ROLE_APPLICATION: arn:aws:iam::803035224331:role/eu2-prod-fr-application-CICD-role
  extends: ".deploy_prod_trigger_k8s_in_place"
deploy_bnym-dev:
  stage: deploy-prod
  allow_failure: true
  rules:
  - - if: $IS_DEPLOYABLE_SERVICE != "true"
      when: never
    - if: $IS_PROD_SERVICE != "true"
      when: never
    - if: "$CI_PIPELINE_SOURCE == 'merge_request_event'"
      when: never
    - if: ($CI_COMMIT_BRANCH == "master" || $CI_COMMIT_BRANCH == "main") && $STRATEGY
        == "classic"
      when: manual
  needs:
  - build-image
  trigger:
    forward:
      pipeline_variables: true
    strategy: depend
    include:
    - project: fireblocks/shell/common/templates/ci-infra
      ref: main
      file:
      - "${DEPLOYMENT_FILE_PATH}"
  variables:
    FORCE_DEPLOYMENT_FLAG: false
    DEPLOYMENT_FILE_PATH: backend-ci/stages/deployments/deployments-prod/deploy-prod-bnym-dev.yml
  extends: ".deploy_prod-trigger"
deploy_bnym_dev_k8s:
  stage: deploy-prod
  allow_failure: true
  rules:
  - - if: $IS_DEPLOYABLE_SERVICE != "true"
      when: never
    - if: $IS_PROD_SERVICE != "true"
      when: never
    - if: "$CI_PIPELINE_SOURCE == 'merge_request_event'"
      when: never
    - if: ($CI_COMMIT_BRANCH == "master" || $CI_COMMIT_BRANCH == "main") && $STRATEGY
        == "canary"
      when: manual
  needs:
  - build-image
  trigger:
    forward:
      pipeline_variables: true
    strategy: depend
    include:
    - project: fireblocks/shell/common/templates/ci-infra
      ref: "$TEMPLATE_REF"
      file:
      - "${DEPLOYMENT_FILE_PATH}"
  variables:
    FORCE_DEPLOYMENT_FLAG: false
    DEPLOYMENT_FILE_PATH: backend-ci/stages/deployments/deployments-prod/deploy-prod-bnym-dev-k8s.yml
    K8S_CLUSTER_NAME: useast2-bnym-dev-sh-k8s
    AWS_REGION: us-east-2
    IAM_ROLE_APPLICATION: arn:aws:iam::414623400063:role/bnym-dev-application-CICD-role
  extends: ".deploy_prod_trigger_k8s"
deploy_bnym_dev_k8s_in_place:
  stage: deploy-prod-in-place
  allow_failure: true
  rules:
  - - if: $IS_DEPLOYABLE_SERVICE != "true"
      when: never
    - if: $IS_PROD_SERVICE != "true"
      when: never
    - if: "$CI_PIPELINE_SOURCE == 'merge_request_event'"
      when: never
    - if: ($CI_COMMIT_BRANCH == "master" || $CI_COMMIT_BRANCH == "main") && $STRATEGY
        == "in_place"
      when: manual
  needs:
  - build-image
  trigger:
    forward:
      pipeline_variables: true
    strategy: depend
    include:
    - project: fireblocks/shell/common/templates/ci-infra
      ref: "$TEMPLATE_REF"
      file:
      - "${DEPLOYMENT_FILE_PATH}"
  variables:
    FORCE_DEPLOYMENT_FLAG: false
    DEPLOYMENT_FILE_PATH: backend-ci/stages/deployments/deployments-prod/deploy-prod-bnym-dev-k8s-in-place.yml
    K8S_CLUSTER_NAME: useast2-bnym-dev-sh-k8s
    AWS_REGION: us-east-2
    IAM_ROLE_APPLICATION: arn:aws:iam::414623400063:role/bnym-dev-application-CICD-role
  extends: ".deploy_prod_trigger_k8s_in_place"
deploy_bnym-prod:
  stage: deploy-prod
  allow_failure: true
  rules:
  - - if: $IS_DEPLOYABLE_SERVICE != "true"
      when: never
    - if: $IS_PROD_SERVICE != "true"
      when: never
    - if: "$CI_PIPELINE_SOURCE == 'merge_request_event'"
      when: never
    - if: ($CI_COMMIT_BRANCH == "master" || $CI_COMMIT_BRANCH == "main") && $STRATEGY
        == "classic"
      when: manual
  needs:
  - build-image
  trigger:
    forward:
      pipeline_variables: true
    strategy: depend
    include:
    - project: fireblocks/shell/common/templates/ci-infra
      ref: main
      file:
      - "${DEPLOYMENT_FILE_PATH}"
  variables:
    FORCE_DEPLOYMENT_FLAG: false
    DEPLOYMENT_FILE_PATH: backend-ci/stages/deployments/deployments-prod/deploy-prod-bnym-prod.yml
  extends: ".deploy_prod-trigger"
deploy_bnym_prod_k8s:
  stage: deploy-prod
  allow_failure: true
  rules:
  - - if: $IS_DEPLOYABLE_SERVICE != "true"
      when: never
    - if: $IS_PROD_SERVICE != "true"
      when: never
    - if: "$CI_PIPELINE_SOURCE == 'merge_request_event'"
      when: never
    - if: ($CI_COMMIT_BRANCH == "master" || $CI_COMMIT_BRANCH == "main") && $STRATEGY
        == "canary"
      when: manual
  needs:
  - build-image
  trigger:
    forward:
      pipeline_variables: true
    strategy: depend
    include:
    - project: fireblocks/shell/common/templates/ci-infra
      ref: "$TEMPLATE_REF"
      file:
      - "${DEPLOYMENT_FILE_PATH}"
  variables:
    FORCE_DEPLOYMENT_FLAG: false
    DEPLOYMENT_FILE_PATH: backend-ci/stages/deployments/deployments-prod/deploy-prod-bnym-prod-k8s.yml
    K8S_CLUSTER_NAME: prod-bnym-shell
    AWS_REGION: us-east-2
    IAM_ROLE_APPLICATION: arn:aws:iam::296106167418:role/bnym-prod-application-CICD-role
  extends: ".deploy_prod_trigger_k8s"
deploy_bnym_prod_k8s_in_place:
  stage: deploy-prod-in-place
  allow_failure: true
  rules:
  - - if: $IS_DEPLOYABLE_SERVICE != "true"
      when: never
    - if: $IS_PROD_SERVICE != "true"
      when: never
    - if: "$CI_PIPELINE_SOURCE == 'merge_request_event'"
      when: never
    - if: ($CI_COMMIT_BRANCH == "master" || $CI_COMMIT_BRANCH == "main") && $STRATEGY
        == "in_place"
      when: manual
  needs:
  - build-image
  trigger:
    forward:
      pipeline_variables: true
    strategy: depend
    include:
    - project: fireblocks/shell/common/templates/ci-infra
      ref: "$TEMPLATE_REF"
      file:
      - "${DEPLOYMENT_FILE_PATH}"
  variables:
    FORCE_DEPLOYMENT_FLAG: false
    DEPLOYMENT_FILE_PATH: backend-ci/stages/deployments/deployments-prod/deploy-prod-bnym-prod-k8s-in-place.yml
    K8S_CLUSTER_NAME: prod-bnym-shell
    AWS_REGION: us-east-2
    IAM_ROLE_APPLICATION: arn:aws:iam::296106167418:role/bnym-prod-application-CICD-role
  extends: ".deploy_prod_trigger_k8s_in_place"
".validate-service-health": "apk update\napk add --no-cache jq\napk add grep\necho
  checking ${SERVICE_NAME} container\necho trying to resolve container health port\nSERVICE_HEALTH_PORT=${HEALTH_PORT:-$(docker
  inspect \"${SERVICE_NAME}\" | \\\n  jq -r '.[0].Config.Labels[\"com.datadoghq.ad.checks\"]
  // null' | \\\n  jq -r 'if . == null then \"\" else .http_check.instances[0].url
  // \"\" end' | \\\n  grep -oP ':\\K[0-9]+' || echo \"\")}\nif [ -z \"${SERVICE_HEALTH_PORT}\"
  ]; then\n   echo \"**************************************************************************\"\n
  \  echo \"Health port for your service is not configured in component-registry repo\"\n
  \  echo \"Please configure it in https://gitlab.com/fireblocks/shell/infra/prod-services.\"\n
  \  echo \"**************************************************************************\"\n
  \  exit 1\nfi\necho checking service health in port $SERVICE_HEALTH_PORT\nfor i
  in {1..6}; do\n   if docker run --rm --network net curlimages/curl curl -s http://${SERVICE_NAME}:${SERVICE_HEALTH_PORT}/health
  | jq -r '.status'; then\n      echo \"Service is healthy\";\n      docker run --rm
  --network net curlimages/curl curl -s http://${SERVICE_NAME}:${SERVICE_HEALTH_PORT}/health
  | jq;            \n      exit 0\n   else\n      echo \"Service not available yet.
  Retrying in 10 seconds...\";\n      sleep 10\n   fi\ndone\necho \"Service not available
  failing job\";\nexit 1\n"
".deploy_dev_common":
  stage: test
  variables:
    role: node
    GITLAB_TOKEN: "${ARGOCD_GITLAB_ACCESS_TOKEN}"
    DIFF_FILE: "${CI_PROJECT_DIR}/config_diff.txt"
  environment:
    name: "$env"
  script:
  - echo "validating configuration diffs in case it's a quick-rollback deployment"
  - fb quick-rollback-params-diff "${SERVICE_NAME}" --env "${CI_ENVIRONMENT_NAME}"
    --rollbackToSha "${CI_COMMIT_SHORT_SHA}" --gitlabToken "${GITLAB_TOKEN}" --serviceRepoId
    "${CI_PROJECT_ID}" --diffFile "${DIFF_FILE}" --pipelineUrl "${CI_PIPELINE_URL}"
  - docker login -u gitlab-ci-token -p $CI_JOB_TOKEN $CI_REGISTRY
  - fb gen-docker-compose ${env} "${SERVICE_NAME}" "${IMAGE_PATH}" "${CI_JOB_TOKEN}"
    "${CI_PROJECT_ID}" "${CUSTOM_DOCKER_CONTAINERS_INPUT}"
  - mkdir -p /secrets/${SERVICE_NAME}
  - cp ./docker-compose.yml /secrets/${SERVICE_NAME}/docker-compose.yml
  - "(cd configurations; cp  -r * /secrets/${SERVICE_NAME})"
  - echo ${CI_REGISTRY_IMAGE} ${SERVICE_NAME} ${IMAGE_TAG} ${env}
  - docker-compose -p ${role} -f docker-compose.yml pull
  - docker-compose -p ${role} -f docker-compose.yml down
  - DOCKERS_TO_KILL=$(cat docker-compose.yml | yq '.services.*.container_name' | tr
    -d '"' | tr '\n' ' ') || /bin/true
  - docker rm -f "${DOCKERS_TO_KILL}" || /bin/true
  - docker rm -f ${SERVICE_NAME} || /bin/true
  - docker-compose -p ${role} -f docker-compose.yml rm --force
  - docker-compose -p ${role} -f docker-compose.yml up -d
  - docker exec nginx nginx -s reload
  - "(docker images ${CI_REGISTRY_IMAGE}/ci_build/* -q | xargs docker rmi -f) || /bin/true"
  - docker volume rm $(docker volume ls -qf dangling=true) || /bin/true
  - if [ "${VALIDATE_SERVICE_HEALTH}" == "true" ]; then echo "Continue to service
    health check"; else exit 0; fi
  - "apk update\napk add --no-cache jq\napk add grep\necho checking ${SERVICE_NAME}
    container\necho trying to resolve container health port\nSERVICE_HEALTH_PORT=${HEALTH_PORT:-$(docker
    inspect \"${SERVICE_NAME}\" | \\\n  jq -r '.[0].Config.Labels[\"com.datadoghq.ad.checks\"]
    // null' | \\\n  jq -r 'if . == null then \"\" else .http_check.instances[0].url
    // \"\" end' | \\\n  grep -oP ':\\K[0-9]+' || echo \"\")}\nif [ -z \"${SERVICE_HEALTH_PORT}\"
    ]; then\n   echo \"**************************************************************************\"\n
    \  echo \"Health port for your service is not configured in component-registry
    repo\"\n   echo \"Please configure it in https://gitlab.com/fireblocks/shell/infra/prod-services.\"\n
    \  echo \"**************************************************************************\"\n
    \  exit 1\nfi\necho checking service health in port $SERVICE_HEALTH_PORT\nfor
    i in {1..6}; do\n   if docker run --rm --network net curlimages/curl curl -s http://${SERVICE_NAME}:${SERVICE_HEALTH_PORT}/health
    | jq -r '.status'; then\n      echo \"Service is healthy\";\n      docker run
    --rm --network net curlimages/curl curl -s http://${SERVICE_NAME}:${SERVICE_HEALTH_PORT}/health
    | jq;            \n      exit 0\n   else\n      echo \"Service not available yet.
    Retrying in 10 seconds...\";\n      sleep 10\n   fi\ndone\necho \"Service not
    available failing job\";\nexit 1\n"
".deploy_prod_us_common":
  stage: deploy
  allow_failure: false
  before_script:
  - ''
  variables:
    DOCKER_STOP_TIMEOUT: "${DEFAULT_DOCKER_STOP_TIMEOUT}"
  script:
  - echo ${SERVICE_NAME} ${IMAGE_TAG} ${CI_ENVIRONMENT_NAME}
  - echo "started docker login $(date +"%T")"
  - docker login -u gitlab-ci-token -p $CI_JOB_TOKEN $CI_REGISTRY
  - echo "finished docker login $(date +"%T")"
  - echo "/secrets/${DOCKER_COMPOSE_PATH_PROD_US}"
  - if [ ! -f /secrets/${DOCKER_COMPOSE_PATH_PROD_US} ]; then echo "Missing docker-compose
    file /secrets/${DOCKER_COMPOSE_PATH_PROD_US}" && exit; fi
  - echo "Started docker compose pull $(date +"%T")";
  - docker-compose -f /secrets/${DOCKER_COMPOSE_PATH_PROD_US} pull;
  - echo "Finished docker compose pull $(date +"%T")";
  - echo "started docker-compose down $(date +"%T")"
  - docker-compose -f /secrets/${DOCKER_COMPOSE_PATH_PROD_US} -p $CONTAINER_NAME down
    -t $DOCKER_STOP_TIMEOUT
  - echo "finished docker-compose down $(date +"%T")"
  - echo $DOCKER_COMPOSE_PATH_PROD_US $DOCKER_STOP_TIMEOUT $CONTAINER_NAME
  - while [[ "$(docker ps --format '{{.Names}}' --filter name=${CONTAINER_NAME})"
    == "${CONTAINER_NAME}" ]]; do sleep 1; done;
  - echo "started docker compose up $(date +"%T")"
  - docker-compose -f /secrets/${DOCKER_COMPOSE_PATH_PROD_US} -p $CONTAINER_NAME up
    -d
  - echo "finished docker compose up $(date +"%T")"
  - echo "started docker rmi execution $(date +"%T")"
  - echo "${CI_REGISTRY_IMAGE}"
  - "(docker images ${CI_REGISTRY_IMAGE}/ci_build/* -q | xargs docker rmi -f) || /bin/true"
  - echo "finished docker rmi execution $(date +"%T")"
".docker_stop":
  tags:
  - "$RUNNER_NAME"
  environment:
    name: "${ENVIRONMENT_NAME}"
  script:
  - echo "stopping ${SERVICE_NAME} on ${RUNNER_NAME}"
  - docker stop ${SERVICE_NAME} || /bin/true
".deploy_dev1":
  stage: test
  variables:
    role: node
    GITLAB_TOKEN: "${ARGOCD_GITLAB_ACCESS_TOKEN}"
    DIFF_FILE: "${CI_PROJECT_DIR}/config_diff.txt"
    env: dev1
  environment:
    name: "$env"
  script:
  - echo "validating configuration diffs in case it's a quick-rollback deployment"
  - fb quick-rollback-params-diff "${SERVICE_NAME}" --env "${CI_ENVIRONMENT_NAME}"
    --rollbackToSha "${CI_COMMIT_SHORT_SHA}" --gitlabToken "${GITLAB_TOKEN}" --serviceRepoId
    "${CI_PROJECT_ID}" --diffFile "${DIFF_FILE}" --pipelineUrl "${CI_PIPELINE_URL}"
  - docker login -u gitlab-ci-token -p $CI_JOB_TOKEN $CI_REGISTRY
  - fb gen-docker-compose ${env} "${SERVICE_NAME}" "${IMAGE_PATH}" "${CI_JOB_TOKEN}"
    "${CI_PROJECT_ID}" "${CUSTOM_DOCKER_CONTAINERS_INPUT}"
  - mkdir -p /secrets/${SERVICE_NAME}
  - cp ./docker-compose.yml /secrets/${SERVICE_NAME}/docker-compose.yml
  - "(cd configurations; cp  -r * /secrets/${SERVICE_NAME})"
  - echo ${CI_REGISTRY_IMAGE} ${SERVICE_NAME} ${IMAGE_TAG} ${env}
  - docker-compose -p ${role} -f docker-compose.yml pull
  - docker-compose -p ${role} -f docker-compose.yml down
  - DOCKERS_TO_KILL=$(cat docker-compose.yml | yq '.services.*.container_name' | tr
    -d '"' | tr '\n' ' ') || /bin/true
  - docker rm -f "${DOCKERS_TO_KILL}" || /bin/true
  - docker rm -f ${SERVICE_NAME} || /bin/true
  - docker-compose -p ${role} -f docker-compose.yml rm --force
  - docker-compose -p ${role} -f docker-compose.yml up -d
  - docker exec nginx nginx -s reload
  - "(docker images ${CI_REGISTRY_IMAGE}/ci_build/* -q | xargs docker rmi -f) || /bin/true"
  - docker volume rm $(docker volume ls -qf dangling=true) || /bin/true
  - if [ "${VALIDATE_SERVICE_HEALTH}" == "true" ]; then echo "Continue to service
    health check"; else exit 0; fi
  - "apk update\napk add --no-cache jq\napk add grep\necho checking ${SERVICE_NAME}
    container\necho trying to resolve container health port\nSERVICE_HEALTH_PORT=${HEALTH_PORT:-$(docker
    inspect \"${SERVICE_NAME}\" | \\\n  jq -r '.[0].Config.Labels[\"com.datadoghq.ad.checks\"]
    // null' | \\\n  jq -r 'if . == null then \"\" else .http_check.instances[0].url
    // \"\" end' | \\\n  grep -oP ':\\K[0-9]+' || echo \"\")}\nif [ -z \"${SERVICE_HEALTH_PORT}\"
    ]; then\n   echo \"**************************************************************************\"\n
    \  echo \"Health port for your service is not configured in component-registry
    repo\"\n   echo \"Please configure it in https://gitlab.com/fireblocks/shell/infra/prod-services.\"\n
    \  echo \"**************************************************************************\"\n
    \  exit 1\nfi\necho checking service health in port $SERVICE_HEALTH_PORT\nfor
    i in {1..6}; do\n   if docker run --rm --network net curlimages/curl curl -s http://${SERVICE_NAME}:${SERVICE_HEALTH_PORT}/health
    | jq -r '.status'; then\n      echo \"Service is healthy\";\n      docker run
    --rm --network net curlimages/curl curl -s http://${SERVICE_NAME}:${SERVICE_HEALTH_PORT}/health
    | jq;            \n      exit 0\n   else\n      echo \"Service not available yet.
    Retrying in 10 seconds...\";\n      sleep 10\n   fi\ndone\necho \"Service not
    available failing job\";\nexit 1\n"
  extends: ".deploy_dev_common"
  tags:
  - dev1-node
".deploy_dev2":
  stage: test
  variables:
    role: node
    GITLAB_TOKEN: "${ARGOCD_GITLAB_ACCESS_TOKEN}"
    DIFF_FILE: "${CI_PROJECT_DIR}/config_diff.txt"
    env: dev2
  environment:
    name: "$env"
  script:
  - echo "validating configuration diffs in case it's a quick-rollback deployment"
  - fb quick-rollback-params-diff "${SERVICE_NAME}" --env "${CI_ENVIRONMENT_NAME}"
    --rollbackToSha "${CI_COMMIT_SHORT_SHA}" --gitlabToken "${GITLAB_TOKEN}" --serviceRepoId
    "${CI_PROJECT_ID}" --diffFile "${DIFF_FILE}" --pipelineUrl "${CI_PIPELINE_URL}"
  - docker login -u gitlab-ci-token -p $CI_JOB_TOKEN $CI_REGISTRY
  - fb gen-docker-compose ${env} "${SERVICE_NAME}" "${IMAGE_PATH}" "${CI_JOB_TOKEN}"
    "${CI_PROJECT_ID}" "${CUSTOM_DOCKER_CONTAINERS_INPUT}"
  - mkdir -p /secrets/${SERVICE_NAME}
  - cp ./docker-compose.yml /secrets/${SERVICE_NAME}/docker-compose.yml
  - "(cd configurations; cp  -r * /secrets/${SERVICE_NAME})"
  - echo ${CI_REGISTRY_IMAGE} ${SERVICE_NAME} ${IMAGE_TAG} ${env}
  - docker-compose -p ${role} -f docker-compose.yml pull
  - docker-compose -p ${role} -f docker-compose.yml down
  - DOCKERS_TO_KILL=$(cat docker-compose.yml | yq '.services.*.container_name' | tr
    -d '"' | tr '\n' ' ') || /bin/true
  - docker rm -f "${DOCKERS_TO_KILL}" || /bin/true
  - docker rm -f ${SERVICE_NAME} || /bin/true
  - docker-compose -p ${role} -f docker-compose.yml rm --force
  - docker-compose -p ${role} -f docker-compose.yml up -d
  - docker exec nginx nginx -s reload
  - "(docker images ${CI_REGISTRY_IMAGE}/ci_build/* -q | xargs docker rmi -f) || /bin/true"
  - docker volume rm $(docker volume ls -qf dangling=true) || /bin/true
  - if [ "${VALIDATE_SERVICE_HEALTH}" == "true" ]; then echo "Continue to service
    health check"; else exit 0; fi
  - "apk update\napk add --no-cache jq\napk add grep\necho checking ${SERVICE_NAME}
    container\necho trying to resolve container health port\nSERVICE_HEALTH_PORT=${HEALTH_PORT:-$(docker
    inspect \"${SERVICE_NAME}\" | \\\n  jq -r '.[0].Config.Labels[\"com.datadoghq.ad.checks\"]
    // null' | \\\n  jq -r 'if . == null then \"\" else .http_check.instances[0].url
    // \"\" end' | \\\n  grep -oP ':\\K[0-9]+' || echo \"\")}\nif [ -z \"${SERVICE_HEALTH_PORT}\"
    ]; then\n   echo \"**************************************************************************\"\n
    \  echo \"Health port for your service is not configured in component-registry
    repo\"\n   echo \"Please configure it in https://gitlab.com/fireblocks/shell/infra/prod-services.\"\n
    \  echo \"**************************************************************************\"\n
    \  exit 1\nfi\necho checking service health in port $SERVICE_HEALTH_PORT\nfor
    i in {1..6}; do\n   if docker run --rm --network net curlimages/curl curl -s http://${SERVICE_NAME}:${SERVICE_HEALTH_PORT}/health
    | jq -r '.status'; then\n      echo \"Service is healthy\";\n      docker run
    --rm --network net curlimages/curl curl -s http://${SERVICE_NAME}:${SERVICE_HEALTH_PORT}/health
    | jq;            \n      exit 0\n   else\n      echo \"Service not available yet.
    Retrying in 10 seconds...\";\n      sleep 10\n   fi\ndone\necho \"Service not
    available failing job\";\nexit 1\n"
  extends: ".deploy_dev_common"
  tags:
  - dev2-node
".deploy_dev3":
  stage: test
  variables:
    role: node
    GITLAB_TOKEN: "${ARGOCD_GITLAB_ACCESS_TOKEN}"
    DIFF_FILE: "${CI_PROJECT_DIR}/config_diff.txt"
    env: dev3
  environment:
    name: "$env"
  script:
  - echo "validating configuration diffs in case it's a quick-rollback deployment"
  - fb quick-rollback-params-diff "${SERVICE_NAME}" --env "${CI_ENVIRONMENT_NAME}"
    --rollbackToSha "${CI_COMMIT_SHORT_SHA}" --gitlabToken "${GITLAB_TOKEN}" --serviceRepoId
    "${CI_PROJECT_ID}" --diffFile "${DIFF_FILE}" --pipelineUrl "${CI_PIPELINE_URL}"
  - docker login -u gitlab-ci-token -p $CI_JOB_TOKEN $CI_REGISTRY
  - fb gen-docker-compose ${env} "${SERVICE_NAME}" "${IMAGE_PATH}" "${CI_JOB_TOKEN}"
    "${CI_PROJECT_ID}" "${CUSTOM_DOCKER_CONTAINERS_INPUT}"
  - mkdir -p /secrets/${SERVICE_NAME}
  - cp ./docker-compose.yml /secrets/${SERVICE_NAME}/docker-compose.yml
  - "(cd configurations; cp  -r * /secrets/${SERVICE_NAME})"
  - echo ${CI_REGISTRY_IMAGE} ${SERVICE_NAME} ${IMAGE_TAG} ${env}
  - docker-compose -p ${role} -f docker-compose.yml pull
  - docker-compose -p ${role} -f docker-compose.yml down
  - DOCKERS_TO_KILL=$(cat docker-compose.yml | yq '.services.*.container_name' | tr
    -d '"' | tr '\n' ' ') || /bin/true
  - docker rm -f "${DOCKERS_TO_KILL}" || /bin/true
  - docker rm -f ${SERVICE_NAME} || /bin/true
  - docker-compose -p ${role} -f docker-compose.yml rm --force
  - docker-compose -p ${role} -f docker-compose.yml up -d
  - docker exec nginx nginx -s reload
  - "(docker images ${CI_REGISTRY_IMAGE}/ci_build/* -q | xargs docker rmi -f) || /bin/true"
  - docker volume rm $(docker volume ls -qf dangling=true) || /bin/true
  - if [ "${VALIDATE_SERVICE_HEALTH}" == "true" ]; then echo "Continue to service
    health check"; else exit 0; fi
  - "apk update\napk add --no-cache jq\napk add grep\necho checking ${SERVICE_NAME}
    container\necho trying to resolve container health port\nSERVICE_HEALTH_PORT=${HEALTH_PORT:-$(docker
    inspect \"${SERVICE_NAME}\" | \\\n  jq -r '.[0].Config.Labels[\"com.datadoghq.ad.checks\"]
    // null' | \\\n  jq -r 'if . == null then \"\" else .http_check.instances[0].url
    // \"\" end' | \\\n  grep -oP ':\\K[0-9]+' || echo \"\")}\nif [ -z \"${SERVICE_HEALTH_PORT}\"
    ]; then\n   echo \"**************************************************************************\"\n
    \  echo \"Health port for your service is not configured in component-registry
    repo\"\n   echo \"Please configure it in https://gitlab.com/fireblocks/shell/infra/prod-services.\"\n
    \  echo \"**************************************************************************\"\n
    \  exit 1\nfi\necho checking service health in port $SERVICE_HEALTH_PORT\nfor
    i in {1..6}; do\n   if docker run --rm --network net curlimages/curl curl -s http://${SERVICE_NAME}:${SERVICE_HEALTH_PORT}/health
    | jq -r '.status'; then\n      echo \"Service is healthy\";\n      docker run
    --rm --network net curlimages/curl curl -s http://${SERVICE_NAME}:${SERVICE_HEALTH_PORT}/health
    | jq;            \n      exit 0\n   else\n      echo \"Service not available yet.
    Retrying in 10 seconds...\";\n      sleep 10\n   fi\ndone\necho \"Service not
    available failing job\";\nexit 1\n"
  extends: ".deploy_dev_common"
  tags:
  - dev3-srv
".deploy_dev4":
  stage: test
  variables:
    role: node
    GITLAB_TOKEN: "${ARGOCD_GITLAB_ACCESS_TOKEN}"
    DIFF_FILE: "${CI_PROJECT_DIR}/config_diff.txt"
    env: dev4
  environment:
    name: "$env"
  script:
  - echo "validating configuration diffs in case it's a quick-rollback deployment"
  - fb quick-rollback-params-diff "${SERVICE_NAME}" --env "${CI_ENVIRONMENT_NAME}"
    --rollbackToSha "${CI_COMMIT_SHORT_SHA}" --gitlabToken "${GITLAB_TOKEN}" --serviceRepoId
    "${CI_PROJECT_ID}" --diffFile "${DIFF_FILE}" --pipelineUrl "${CI_PIPELINE_URL}"
  - docker login -u gitlab-ci-token -p $CI_JOB_TOKEN $CI_REGISTRY
  - fb gen-docker-compose ${env} "${SERVICE_NAME}" "${IMAGE_PATH}" "${CI_JOB_TOKEN}"
    "${CI_PROJECT_ID}" "${CUSTOM_DOCKER_CONTAINERS_INPUT}"
  - mkdir -p /secrets/${SERVICE_NAME}
  - cp ./docker-compose.yml /secrets/${SERVICE_NAME}/docker-compose.yml
  - "(cd configurations; cp  -r * /secrets/${SERVICE_NAME})"
  - echo ${CI_REGISTRY_IMAGE} ${SERVICE_NAME} ${IMAGE_TAG} ${env}
  - docker-compose -p ${role} -f docker-compose.yml pull
  - docker-compose -p ${role} -f docker-compose.yml down
  - DOCKERS_TO_KILL=$(cat docker-compose.yml | yq '.services.*.container_name' | tr
    -d '"' | tr '\n' ' ') || /bin/true
  - docker rm -f "${DOCKERS_TO_KILL}" || /bin/true
  - docker rm -f ${SERVICE_NAME} || /bin/true
  - docker-compose -p ${role} -f docker-compose.yml rm --force
  - docker-compose -p ${role} -f docker-compose.yml up -d
  - docker exec nginx nginx -s reload
  - "(docker images ${CI_REGISTRY_IMAGE}/ci_build/* -q | xargs docker rmi -f) || /bin/true"
  - docker volume rm $(docker volume ls -qf dangling=true) || /bin/true
  - if [ "${VALIDATE_SERVICE_HEALTH}" == "true" ]; then echo "Continue to service
    health check"; else exit 0; fi
  - "apk update\napk add --no-cache jq\napk add grep\necho checking ${SERVICE_NAME}
    container\necho trying to resolve container health port\nSERVICE_HEALTH_PORT=${HEALTH_PORT:-$(docker
    inspect \"${SERVICE_NAME}\" | \\\n  jq -r '.[0].Config.Labels[\"com.datadoghq.ad.checks\"]
    // null' | \\\n  jq -r 'if . == null then \"\" else .http_check.instances[0].url
    // \"\" end' | \\\n  grep -oP ':\\K[0-9]+' || echo \"\")}\nif [ -z \"${SERVICE_HEALTH_PORT}\"
    ]; then\n   echo \"**************************************************************************\"\n
    \  echo \"Health port for your service is not configured in component-registry
    repo\"\n   echo \"Please configure it in https://gitlab.com/fireblocks/shell/infra/prod-services.\"\n
    \  echo \"**************************************************************************\"\n
    \  exit 1\nfi\necho checking service health in port $SERVICE_HEALTH_PORT\nfor
    i in {1..6}; do\n   if docker run --rm --network net curlimages/curl curl -s http://${SERVICE_NAME}:${SERVICE_HEALTH_PORT}/health
    | jq -r '.status'; then\n      echo \"Service is healthy\";\n      docker run
    --rm --network net curlimages/curl curl -s http://${SERVICE_NAME}:${SERVICE_HEALTH_PORT}/health
    | jq;            \n      exit 0\n   else\n      echo \"Service not available yet.
    Retrying in 10 seconds...\";\n      sleep 10\n   fi\ndone\necho \"Service not
    available failing job\";\nexit 1\n"
  extends: ".deploy_dev_common"
  tags:
  - dev4-srv
".deploy_stage":
  stage: test
  variables:
    role: node
    GITLAB_TOKEN: "${ARGOCD_GITLAB_ACCESS_TOKEN}"
    DIFF_FILE: "${CI_PROJECT_DIR}/config_diff.txt"
    env: stage
  environment:
    name: "$env"
  script:
  - echo "validating configuration diffs in case it's a quick-rollback deployment"
  - fb quick-rollback-params-diff "${SERVICE_NAME}" --env "${CI_ENVIRONMENT_NAME}"
    --rollbackToSha "${CI_COMMIT_SHORT_SHA}" --gitlabToken "${GITLAB_TOKEN}" --serviceRepoId
    "${CI_PROJECT_ID}" --diffFile "${DIFF_FILE}" --pipelineUrl "${CI_PIPELINE_URL}"
  - docker login -u gitlab-ci-token -p $CI_JOB_TOKEN $CI_REGISTRY
  - fb gen-docker-compose ${env} "${SERVICE_NAME}" "${IMAGE_PATH}" "${CI_JOB_TOKEN}"
    "${CI_PROJECT_ID}" "${CUSTOM_DOCKER_CONTAINERS_INPUT}"
  - mkdir -p /secrets/${SERVICE_NAME}
  - cp ./docker-compose.yml /secrets/${SERVICE_NAME}/docker-compose.yml
  - "(cd configurations; cp  -r * /secrets/${SERVICE_NAME})"
  - echo ${CI_REGISTRY_IMAGE} ${SERVICE_NAME} ${IMAGE_TAG} ${env}
  - docker-compose -p ${role} -f docker-compose.yml pull
  - docker-compose -p ${role} -f docker-compose.yml down
  - DOCKERS_TO_KILL=$(cat docker-compose.yml | yq '.services.*.container_name' | tr
    -d '"' | tr '\n' ' ') || /bin/true
  - docker rm -f "${DOCKERS_TO_KILL}" || /bin/true
  - docker rm -f ${SERVICE_NAME} || /bin/true
  - docker-compose -p ${role} -f docker-compose.yml rm --force
  - docker-compose -p ${role} -f docker-compose.yml up -d
  - docker exec nginx nginx -s reload
  - "(docker images ${CI_REGISTRY_IMAGE}/ci_build/* -q | xargs docker rmi -f) || /bin/true"
  - docker volume rm $(docker volume ls -qf dangling=true) || /bin/true
  - if [ "${VALIDATE_SERVICE_HEALTH}" == "true" ]; then echo "Continue to service
    health check"; else exit 0; fi
  - "apk update\napk add --no-cache jq\napk add grep\necho checking ${SERVICE_NAME}
    container\necho trying to resolve container health port\nSERVICE_HEALTH_PORT=${HEALTH_PORT:-$(docker
    inspect \"${SERVICE_NAME}\" | \\\n  jq -r '.[0].Config.Labels[\"com.datadoghq.ad.checks\"]
    // null' | \\\n  jq -r 'if . == null then \"\" else .http_check.instances[0].url
    // \"\" end' | \\\n  grep -oP ':\\K[0-9]+' || echo \"\")}\nif [ -z \"${SERVICE_HEALTH_PORT}\"
    ]; then\n   echo \"**************************************************************************\"\n
    \  echo \"Health port for your service is not configured in component-registry
    repo\"\n   echo \"Please configure it in https://gitlab.com/fireblocks/shell/infra/prod-services.\"\n
    \  echo \"**************************************************************************\"\n
    \  exit 1\nfi\necho checking service health in port $SERVICE_HEALTH_PORT\nfor
    i in {1..6}; do\n   if docker run --rm --network net curlimages/curl curl -s http://${SERVICE_NAME}:${SERVICE_HEALTH_PORT}/health
    | jq -r '.status'; then\n      echo \"Service is healthy\";\n      docker run
    --rm --network net curlimages/curl curl -s http://${SERVICE_NAME}:${SERVICE_HEALTH_PORT}/health
    | jq;            \n      exit 0\n   else\n      echo \"Service not available yet.
    Retrying in 10 seconds...\";\n      sleep 10\n   fi\ndone\necho \"Service not
    available failing job\";\nexit 1\n"
  extends: ".deploy_dev_common"
  tags:
  - stage-services-1
".deploy_pre1":
  stage: test
  variables:
    role: node
    GITLAB_TOKEN: "${ARGOCD_GITLAB_ACCESS_TOKEN}"
    DIFF_FILE: "${CI_PROJECT_DIR}/config_diff.txt"
    env: pre1
    VALIDATE_SERVICE_HEALTH: true
  environment:
    name: "$env"
  script:
  - echo "validating configuration diffs in case it's a quick-rollback deployment"
  - fb quick-rollback-params-diff "${SERVICE_NAME}" --env "${CI_ENVIRONMENT_NAME}"
    --rollbackToSha "${CI_COMMIT_SHORT_SHA}" --gitlabToken "${GITLAB_TOKEN}" --serviceRepoId
    "${CI_PROJECT_ID}" --diffFile "${DIFF_FILE}" --pipelineUrl "${CI_PIPELINE_URL}"
  - docker login -u gitlab-ci-token -p $CI_JOB_TOKEN $CI_REGISTRY
  - fb gen-docker-compose ${env} "${SERVICE_NAME}" "${IMAGE_PATH}" "${CI_JOB_TOKEN}"
    "${CI_PROJECT_ID}" "${CUSTOM_DOCKER_CONTAINERS_INPUT}"
  - mkdir -p /secrets/${SERVICE_NAME}
  - cp ./docker-compose.yml /secrets/${SERVICE_NAME}/docker-compose.yml
  - "(cd configurations; cp  -r * /secrets/${SERVICE_NAME})"
  - echo ${CI_REGISTRY_IMAGE} ${SERVICE_NAME} ${IMAGE_TAG} ${env}
  - docker-compose -p ${role} -f docker-compose.yml pull
  - docker-compose -p ${role} -f docker-compose.yml down
  - DOCKERS_TO_KILL=$(cat docker-compose.yml | yq '.services.*.container_name' | tr
    -d '"' | tr '\n' ' ') || /bin/true
  - docker rm -f "${DOCKERS_TO_KILL}" || /bin/true
  - docker rm -f ${SERVICE_NAME} || /bin/true
  - docker-compose -p ${role} -f docker-compose.yml rm --force
  - docker-compose -p ${role} -f docker-compose.yml up -d
  - docker exec nginx nginx -s reload
  - "(docker images ${CI_REGISTRY_IMAGE}/ci_build/* -q | xargs docker rmi -f) || /bin/true"
  - docker volume rm $(docker volume ls -qf dangling=true) || /bin/true
  - if [ "${VALIDATE_SERVICE_HEALTH}" == "true" ]; then echo "Continue to service
    health check"; else exit 0; fi
  - "apk update\napk add --no-cache jq\napk add grep\necho checking ${SERVICE_NAME}
    container\necho trying to resolve container health port\nSERVICE_HEALTH_PORT=${HEALTH_PORT:-$(docker
    inspect \"${SERVICE_NAME}\" | \\\n  jq -r '.[0].Config.Labels[\"com.datadoghq.ad.checks\"]
    // null' | \\\n  jq -r 'if . == null then \"\" else .http_check.instances[0].url
    // \"\" end' | \\\n  grep -oP ':\\K[0-9]+' || echo \"\")}\nif [ -z \"${SERVICE_HEALTH_PORT}\"
    ]; then\n   echo \"**************************************************************************\"\n
    \  echo \"Health port for your service is not configured in component-registry
    repo\"\n   echo \"Please configure it in https://gitlab.com/fireblocks/shell/infra/prod-services.\"\n
    \  echo \"**************************************************************************\"\n
    \  exit 1\nfi\necho checking service health in port $SERVICE_HEALTH_PORT\nfor
    i in {1..6}; do\n   if docker run --rm --network net curlimages/curl curl -s http://${SERVICE_NAME}:${SERVICE_HEALTH_PORT}/health
    | jq -r '.status'; then\n      echo \"Service is healthy\";\n      docker run
    --rm --network net curlimages/curl curl -s http://${SERVICE_NAME}:${SERVICE_HEALTH_PORT}/health
    | jq;            \n      exit 0\n   else\n      echo \"Service not available yet.
    Retrying in 10 seconds...\";\n      sleep 10\n   fi\ndone\necho \"Service not
    available failing job\";\nexit 1\n"
  extends: ".deploy_dev_common"
  allow_failure: false
  tags:
  - pre1-services-1
".deploy_general:after_build":
  image: registry.gitlab.com/fireblocks/devops/terraform/terraform-runner:v0.5.2
  stage: deploy-dev
  after_script:
  - rm -fr /builds/terraform/
  - echo 'Done!'
  before_script:
  - apt-get update
  - apt-get install -y curl
  - curl -fsSL https://deb.nodesource.com/setup_18.x | bash -
  - apt install -y nodejs
  - npm install -g yarn
  - touch .npmrc
  - npm config set --location=user @fireblocks:registry https://gitlab.com/api/v4/packages/npm/
  - npm config set --location=user '//gitlab.com/api/v4/packages/npm/:_authToken'
    "${NPM_REG_TOKEN}"
  - npm config set --location=user '//gitlab.com/api/v4/projects/20565764/packages/npm/:_authToken'
    "${NPM_REG_TOKEN}"
  - echo "@fireblocks:registry=https://gitlab.com/api/v4/packages/npm/">>.npmrc
  - echo "//gitlab.com/api/v4/packages/npm/:_authToken=${NPM_REG_TOKEN}">>.npmrc
  - echo "//gitlab.com/api/v4/projects/20565764/packages/npm/:_authToken=${NPM_REG_TOKEN}">>.npmrc
  - yarn global add @fireblocks/fb-cli
  - echo "validating configuration diffs in case it's a quick-rollback deployment"
  - cd /builds/
  - rm -fr /builds/terraform/
  - git clone --depth 1 --branch $TERRAFORM_REPO_BRANCH https://gitlab-ci-token:${CI_JOB_TOKEN}@gitlab.com/fireblocks/devops/terraform.git
  - "$(assume-role.sh ${TERRAGRUNT_ROLE} gitlab-runner)"
  - echo ${TERRAGRUNT_PROJECT}
  - echo looking for ${CI_PROJECT_DIR}/configurations/${TERRAGRUNT_ENV}.yaml
  - echo looking for ${CI_PROJECT_DIR}/configurations/${TERRAGRUNT_ENV}.${SERVICE_NAME}.yaml
  - if [[ ${COPY_CONFIG}="true" && -f ${CI_PROJECT_DIR}/configurations/ ]]; then ls
    ${CI_PROJECT_DIR}/configurations/ ; fi
  - if [[ ${COPY_CONFIG}="true" && -f ${CI_PROJECT_DIR}/configurations/${TERRAGRUNT_ENV}.yaml
    ]] ; then cp ${CI_PROJECT_DIR}/configurations/${TERRAGRUNT_ENV}.yaml ${TERRAGRUNT_PROJECT}/${TERRAGRUNT_ENV}.yaml
    ; fi
  - if [[ ${COPY_CONFIG}="true" && -f ${CI_PROJECT_DIR}/configurations/${TERRAGRUNT_ENV}/env.yaml
    ]] ; then cp ${CI_PROJECT_DIR}/configurations/${TERRAGRUNT_ENV}/env.yaml ${TERRAGRUNT_PROJECT}/${TERRAGRUNT_ENV}/env.yaml
    ; fi
  - if [[ ${COPY_CONFIG}="true" && -f ${CI_PROJECT_DIR}/configurations/${TERRAGRUNT_ENV}.${SERVICE_NAME}.yaml
    ]] ; then cp ${CI_PROJECT_DIR}/configurations/${TERRAGRUNT_ENV}.${SERVICE_NAME}.yaml
    ${TERRAGRUNT_PROJECT}/${TERRAGRUNT_ENV}.yaml ; fi
  - cd ${TERRAGRUNT_PROJECT}
  script:
  - echo ${SERVICE_NAME} ${IMAGE_TAG} ${CI_ENVIRONMENT_NAME} TERRAGRUNT_ENV:${TERRAGRUNT_ENV}
  - terragrunt init
  - terragrunt apply --auto-approve --var service_tag=${IMAGE_TAG}
  environment:
    name: "$env"
  variables:
    APP_VERSION: "$IMAGE_TAG"
    JOB: deploy_terragrunt_service_${TERRAGRUNT_ENV}
    TERRAGRUNT_PROJECT: "/builds/terraform/terragrunt/devx/apps/shell-services/${SERVICE_NAME}"
    TERRAFORM_SOURCE: "/builds/terraform/terraform//"
    TERRAGRUNT_BUCKET: fireblocks-terraform-remote-state-${TERRAGRUNT_ENV}
    TERRAGRUNT_LOCK: terraform-state-lock-${TERRAGRUNT_ENV}
    TERRAFORM_REPO_BRANCH: main
    GITLAB_TOKEN: "${ARGOCD_GITLAB_ACCESS_TOKEN}"
    DIFF_FILE: "${CI_PROJECT_DIR}/config_diff.txt"
  artifacts:
    paths:
    - "${CI_PROJECT_DIR}/config_diff.txt"
    when: on_failure
".deploy_general_dev:after_build":
  image: registry.gitlab.com/fireblocks/devops/terraform/terraform-runner:v0.5.2
  stage: deploy-dev
  after_script:
  - rm -fr /builds/terraform/
  - echo 'Done!'
  before_script:
  - apt-get update
  - apt-get install -y curl
  - curl -fsSL https://deb.nodesource.com/setup_18.x | bash -
  - apt install -y nodejs
  - npm install -g yarn
  - touch .npmrc
  - npm config set --location=user @fireblocks:registry https://gitlab.com/api/v4/packages/npm/
  - npm config set --location=user '//gitlab.com/api/v4/packages/npm/:_authToken'
    "${NPM_REG_TOKEN}"
  - npm config set --location=user '//gitlab.com/api/v4/projects/20565764/packages/npm/:_authToken'
    "${NPM_REG_TOKEN}"
  - echo "@fireblocks:registry=https://gitlab.com/api/v4/packages/npm/">>.npmrc
  - echo "//gitlab.com/api/v4/packages/npm/:_authToken=${NPM_REG_TOKEN}">>.npmrc
  - echo "//gitlab.com/api/v4/projects/20565764/packages/npm/:_authToken=${NPM_REG_TOKEN}">>.npmrc
  - yarn global add @fireblocks/fb-cli
  - echo "validating configuration diffs in case it's a quick-rollback deployment"
  - cd /builds/
  - rm -fr /builds/terraform/
  - git clone --depth 1 --branch $TERRAFORM_REPO_BRANCH https://gitlab-ci-token:${CI_JOB_TOKEN}@gitlab.com/fireblocks/devops/terraform.git
  - "$(assume-role.sh ${TERRAGRUNT_ROLE} gitlab-runner)"
  - echo ${TERRAGRUNT_PROJECT}
  - echo looking for ${CI_PROJECT_DIR}/configurations/${TERRAGRUNT_ENV}.yaml
  - echo looking for ${CI_PROJECT_DIR}/configurations/${TERRAGRUNT_ENV}.${SERVICE_NAME}.yaml
  - if [[ ${COPY_CONFIG}="true" && -f ${CI_PROJECT_DIR}/configurations/ ]]; then ls
    ${CI_PROJECT_DIR}/configurations/ ; fi
  - if [[ ${COPY_CONFIG}="true" && -f ${CI_PROJECT_DIR}/configurations/${TERRAGRUNT_ENV}.yaml
    ]] ; then cp ${CI_PROJECT_DIR}/configurations/${TERRAGRUNT_ENV}.yaml ${TERRAGRUNT_PROJECT}/${TERRAGRUNT_ENV}.yaml
    ; fi
  - if [[ ${COPY_CONFIG}="true" && -f ${CI_PROJECT_DIR}/configurations/${TERRAGRUNT_ENV}/env.yaml
    ]] ; then cp ${CI_PROJECT_DIR}/configurations/${TERRAGRUNT_ENV}/env.yaml ${TERRAGRUNT_PROJECT}/${TERRAGRUNT_ENV}/env.yaml
    ; fi
  - if [[ ${COPY_CONFIG}="true" && -f ${CI_PROJECT_DIR}/configurations/${TERRAGRUNT_ENV}.${SERVICE_NAME}.yaml
    ]] ; then cp ${CI_PROJECT_DIR}/configurations/${TERRAGRUNT_ENV}.${SERVICE_NAME}.yaml
    ${TERRAGRUNT_PROJECT}/${TERRAGRUNT_ENV}.yaml ; fi
  - cd ${TERRAGRUNT_PROJECT}
  script:
  - echo ${SERVICE_NAME} ${IMAGE_TAG} ${CI_ENVIRONMENT_NAME} TERRAGRUNT_ENV:${TERRAGRUNT_ENV}
  - terragrunt init
  - terragrunt apply --auto-approve --var service_tag=${IMAGE_TAG}
  environment:
    name: "$env"
  variables:
    APP_VERSION: "$IMAGE_TAG"
    JOB: deploy_terragrunt_service_${TERRAGRUNT_ENV}
    TERRAGRUNT_PROJECT: "/builds/terraform/terragrunt/devx/apps/shell-services/${SERVICE_NAME}"
    TERRAFORM_SOURCE: "/builds/terraform/terraform//"
    TERRAGRUNT_BUCKET: fireblocks-terraform-remote-state-${TERRAGRUNT_ENV}
    TERRAGRUNT_LOCK: terraform-state-lock-${TERRAGRUNT_ENV}
    TERRAFORM_REPO_BRANCH: main
    GITLAB_TOKEN: "${ARGOCD_GITLAB_ACCESS_TOKEN}"
    DIFF_FILE: "${CI_PROJECT_DIR}/config_diff.txt"
    AWS_REGION: us-east-2
    TERRAGRUNT_ROLE: arn:aws:iam::318128524537:role/devx-application-CICD-role
    TERRAGRUNT_ENV: "${env}"
  artifacts:
    paths:
    - "${CI_PROJECT_DIR}/config_diff.txt"
    when: on_failure
  extends: ".deploy_general:after_build"
".terraform":
  image: registry.gitlab.com/fireblocks/devops/terraform/terraform-runner:v0.5.2
  environment:
    name: "$env"
  after_script:
  - rm -fr /builds/terraform/
  - echo 'Done!'
  variables:
    APP_VERSION: "$IMAGE_TAG"
    JOB: deploy_terragrunt_service_${env}
    TERRAGRUNT_PROJECT: "/builds/terraform/terragrunt/devx/apps/shell-services/${SERVICE_NAME}"
    TERRAFORM_SOURCE: "/builds/terraform/terraform//"
    TERRAGRUNT_BUCKET: fireblocks-terraform-remote-state-${env}
    TERRAGRUNT_ENV: "${env}"
    TERRAGRUNT_LOCK: terraform-state-lock-${env}
    TERRAFORM_REPO_BRANCH: main
".with_kubectl":
  image: registry.gitlab.com/fireblocks/devops/terraform/terraform-runner:v0.5.2
  environment:
    name: "$env"
  after_script:
  - rm -fr /builds/terraform/
  - echo 'Done!'
  variables:
    APP_VERSION: "$IMAGE_TAG"
    JOB: deploy_terragrunt_service_${env}
    TERRAGRUNT_PROJECT: "/builds/terraform/terragrunt/devx/apps/shell-services/${SERVICE_NAME}"
    TERRAFORM_SOURCE: "/builds/terraform/terraform//"
    TERRAGRUNT_BUCKET: fireblocks-terraform-remote-state-${env}
    TERRAGRUNT_ENV: "${env}"
    TERRAGRUNT_LOCK: terraform-state-lock-${env}
    TERRAFORM_REPO_BRANCH: main
  extends: ".terraform"
  before_script:
  - apt-get update
  - apt-get install zip unzip
  - cd /builds/
  - rm -fr /builds/terraform/
  - git clone --depth 1 --branch $TERRAFORM_REPO_BRANCH https://gitlab-ci-token:${CI_JOB_TOKEN}@gitlab.com/fireblocks/devops/terraform.git
  - curl "https://awscli.amazonaws.com/awscli-exe-linux-x86_64.zip" -o "awscliv2.zip"
  - unzip -qo awscliv2.zip
  - "./aws/install --update"
  - "$(assume-role.sh ${TERRAGRUNT_ROLE} gitlab-runner)"
  - echo ${TERRAGRUNT_PROJECT}
  - cd ${TERRAGRUNT_PROJECT}
  - curl -LO https://storage.googleapis.com/kubernetes-release/release/$(curl -s https://storage.googleapis.com/kubernetes-release/release/stable.txt)/bin/linux/amd64/kubectl
  - chmod +x ./kubectl && mv ./kubectl /usr/local/bin/kubectl
  - mkdir -p $HOME/.kube
  - aws eks update-kubeconfig --region ${AWS_REGION} --name ${K8S_CLUSTER_NAME}
".act_sandbox":
  tags:
  - sandbox
  variables:
    K8S_CLUSTER_NAME: dlg-sandbox-k8s
    AWS_REGION: us-east-2
    TERRAGRUNT_ROLE: arn:aws:iam::751886943440:role/dlg-sandbox-k8s-EKSDevRWAccessRole
    env: sandbox
".act_eu":
  tags:
  - eu-prod-fr
  variables:
    AWS_REGION: eu-central-1
    TERRAGRUNT_ROLE: arn:aws:iam::455399297295:role/eu-prod-fr-shell-EKSDevRWAccessRole
    env: eu-prod
    K8S_CLUSTER_NAME: eu-prod
".act_eu2":
  tags:
  - eu2-prod-fr
  variables:
    AWS_REGION: eu-central-1
    TERRAGRUNT_ROLE: arn:aws:iam::803035224331:role/eu2-prod-fr-shell-EKSDevRWAccessRole
    env: eu2-prod
    K8S_CLUSTER_NAME: eu2-prod
".act_bnym-dev":
  tags:
  - bnym-dev
  variables:
    AWS_REGION: us-east-2
    TERRAGRUNT_ROLE: arn:aws:iam::414623400063:role/useast2-bnym-dev-sh-k8s-EKSDevRWAccessRole
    env: bnym-dev-shell
    K8S_CLUSTER_NAME: bnym-dev-shell
".act_devx":
  tags:
  - devx-application-gitlab-runner
  variables:
    AWS_REGION: us-east-2
    K8S_CLUSTER_NAME: devx-k8s
    TERRAGRUNT_ROLE: arn:aws:iam::318128524537:role/devx-application-CICD-role
".scale_replicas":
  image: registry.gitlab.com/fireblocks/devops/terraform/terraform-runner:v0.5.2
  environment:
    name: "$env"
  after_script:
  - rm -fr /builds/terraform/
  - echo 'Done!'
  variables:
    APP_VERSION: "$IMAGE_TAG"
    JOB: deploy_terragrunt_service_${env}
    TERRAGRUNT_PROJECT: "/builds/terraform/terragrunt/devx/apps/shell-services/${SERVICE_NAME}"
    TERRAFORM_SOURCE: "/builds/terraform/terraform//"
    TERRAGRUNT_BUCKET: fireblocks-terraform-remote-state-${env}
    TERRAGRUNT_ENV: "${env}"
    TERRAGRUNT_LOCK: terraform-state-lock-${env}
    TERRAFORM_REPO_BRANCH: main
  extends: ".with_kubectl"
  before_script:
  - apt-get update
  - apt-get install zip unzip
  - cd /builds/
  - rm -fr /builds/terraform/
  - git clone --depth 1 --branch $TERRAFORM_REPO_BRANCH https://gitlab-ci-token:${CI_JOB_TOKEN}@gitlab.com/fireblocks/devops/terraform.git
  - curl "https://awscli.amazonaws.com/awscli-exe-linux-x86_64.zip" -o "awscliv2.zip"
  - unzip -qo awscliv2.zip
  - "./aws/install --update"
  - "$(assume-role.sh ${TERRAGRUNT_ROLE} gitlab-runner)"
  - echo ${TERRAGRUNT_PROJECT}
  - cd ${TERRAGRUNT_PROJECT}
  - curl -LO https://storage.googleapis.com/kubernetes-release/release/$(curl -s https://storage.googleapis.com/kubernetes-release/release/stable.txt)/bin/linux/amd64/kubectl
  - chmod +x ./kubectl && mv ./kubectl /usr/local/bin/kubectl
  - mkdir -p $HOME/.kube
  - aws eks update-kubeconfig --region ${AWS_REGION} --name ${K8S_CLUSTER_NAME}
  script:
  - echo ${SERVICE_NAME} ${IMAGE_TAG} ${CI_ENVIRONMENT_NAME}
  - kubectl get deployments ${SERVICE_NAME} -n $env
  - |
    if [ -z $NUM_OF_REPLICAS ]; then
      echo "NUM_OF_REPLICAS variable is not defined"
    else
      kubectl scale deployment ${SERVICE_NAME} --replicas=${NUM_OF_REPLICAS} -n $env
    fi
  - kubectl get deployments ${SERVICE_NAME} -n $env
".get_deployment_data":
  image: registry.gitlab.com/fireblocks/devops/terraform/terraform-runner:v0.5.2
  environment:
    name: "$env"
  after_script:
  - rm -fr /builds/terraform/
  - echo 'Done!'
  variables:
    APP_VERSION: "$IMAGE_TAG"
    JOB: deploy_terragrunt_service_${env}
    TERRAGRUNT_PROJECT: "/builds/terraform/terragrunt/devx/apps/shell-services/${SERVICE_NAME}"
    TERRAFORM_SOURCE: "/builds/terraform/terraform//"
    TERRAGRUNT_BUCKET: fireblocks-terraform-remote-state-${env}
    TERRAGRUNT_ENV: "${env}"
    TERRAGRUNT_LOCK: terraform-state-lock-${env}
    TERRAFORM_REPO_BRANCH: main
  extends: ".with_kubectl"
  before_script:
  - apt-get update
  - apt-get install zip unzip
  - cd /builds/
  - rm -fr /builds/terraform/
  - git clone --depth 1 --branch $TERRAFORM_REPO_BRANCH https://gitlab-ci-token:${CI_JOB_TOKEN}@gitlab.com/fireblocks/devops/terraform.git
  - curl "https://awscli.amazonaws.com/awscli-exe-linux-x86_64.zip" -o "awscliv2.zip"
  - unzip -qo awscliv2.zip
  - "./aws/install --update"
  - "$(assume-role.sh ${TERRAGRUNT_ROLE} gitlab-runner)"
  - echo ${TERRAGRUNT_PROJECT}
  - cd ${TERRAGRUNT_PROJECT}
  - curl -LO https://storage.googleapis.com/kubernetes-release/release/$(curl -s https://storage.googleapis.com/kubernetes-release/release/stable.txt)/bin/linux/amd64/kubectl
  - chmod +x ./kubectl && mv ./kubectl /usr/local/bin/kubectl
  - mkdir -p $HOME/.kube
  - aws eks update-kubeconfig --region ${AWS_REGION} --name ${K8S_CLUSTER_NAME}
  script:
  - echo ${SERVICE_NAME} ${IMAGE_TAG} ${CI_ENVIRONMENT_NAME}
  - kubectl get deployments ${SERVICE_NAME} -n $env
".deploy_dev5:after_build":
  image: registry.gitlab.com/fireblocks/devops/terraform/terraform-runner:v0.5.2
  stage: deploy-dev
  after_script:
  - rm -fr /builds/terraform/
  - echo 'Done!'
  before_script:
  - apt-get update
  - apt-get install -y curl
  - curl -fsSL https://deb.nodesource.com/setup_18.x | bash -
  - apt install -y nodejs
  - npm install -g yarn
  - touch .npmrc
  - npm config set --location=user @fireblocks:registry https://gitlab.com/api/v4/packages/npm/
  - npm config set --location=user '//gitlab.com/api/v4/packages/npm/:_authToken'
    "${NPM_REG_TOKEN}"
  - npm config set --location=user '//gitlab.com/api/v4/projects/20565764/packages/npm/:_authToken'
    "${NPM_REG_TOKEN}"
  - echo "@fireblocks:registry=https://gitlab.com/api/v4/packages/npm/">>.npmrc
  - echo "//gitlab.com/api/v4/packages/npm/:_authToken=${NPM_REG_TOKEN}">>.npmrc
  - echo "//gitlab.com/api/v4/projects/20565764/packages/npm/:_authToken=${NPM_REG_TOKEN}">>.npmrc
  - yarn global add @fireblocks/fb-cli
  - echo "validating configuration diffs in case it's a quick-rollback deployment"
  - cd /builds/
  - rm -fr /builds/terraform/
  - git clone --depth 1 --branch $TERRAFORM_REPO_BRANCH https://gitlab-ci-token:${CI_JOB_TOKEN}@gitlab.com/fireblocks/devops/terraform.git
  - "$(assume-role.sh ${TERRAGRUNT_ROLE} gitlab-runner)"
  - echo ${TERRAGRUNT_PROJECT}
  - echo looking for ${CI_PROJECT_DIR}/configurations/${TERRAGRUNT_ENV}.yaml
  - echo looking for ${CI_PROJECT_DIR}/configurations/${TERRAGRUNT_ENV}.${SERVICE_NAME}.yaml
  - if [[ ${COPY_CONFIG}="true" && -f ${CI_PROJECT_DIR}/configurations/ ]]; then ls
    ${CI_PROJECT_DIR}/configurations/ ; fi
  - if [[ ${COPY_CONFIG}="true" && -f ${CI_PROJECT_DIR}/configurations/${TERRAGRUNT_ENV}.yaml
    ]] ; then cp ${CI_PROJECT_DIR}/configurations/${TERRAGRUNT_ENV}.yaml ${TERRAGRUNT_PROJECT}/${TERRAGRUNT_ENV}.yaml
    ; fi
  - if [[ ${COPY_CONFIG}="true" && -f ${CI_PROJECT_DIR}/configurations/${TERRAGRUNT_ENV}/env.yaml
    ]] ; then cp ${CI_PROJECT_DIR}/configurations/${TERRAGRUNT_ENV}/env.yaml ${TERRAGRUNT_PROJECT}/${TERRAGRUNT_ENV}/env.yaml
    ; fi
  - if [[ ${COPY_CONFIG}="true" && -f ${CI_PROJECT_DIR}/configurations/${TERRAGRUNT_ENV}.${SERVICE_NAME}.yaml
    ]] ; then cp ${CI_PROJECT_DIR}/configurations/${TERRAGRUNT_ENV}.${SERVICE_NAME}.yaml
    ${TERRAGRUNT_PROJECT}/${TERRAGRUNT_ENV}.yaml ; fi
  - cd ${TERRAGRUNT_PROJECT}
  script:
  - echo ${SERVICE_NAME} ${IMAGE_TAG} ${CI_ENVIRONMENT_NAME} TERRAGRUNT_ENV:${TERRAGRUNT_ENV}
  - terragrunt init
  - terragrunt apply --auto-approve --var service_tag=${IMAGE_TAG}
  environment:
    name: "$env"
  variables:
    APP_VERSION: "$IMAGE_TAG"
    JOB: deploy_terragrunt_service_${TERRAGRUNT_ENV}
    TERRAGRUNT_PROJECT: "/builds/terraform/terragrunt/devx/apps/shell-services/${SERVICE_NAME}"
    TERRAFORM_SOURCE: "/builds/terraform/terraform//"
    TERRAGRUNT_BUCKET: fireblocks-terraform-remote-state-${TERRAGRUNT_ENV}
    TERRAGRUNT_LOCK: terraform-state-lock-${TERRAGRUNT_ENV}
    TERRAFORM_REPO_BRANCH: main
    GITLAB_TOKEN: "${ARGOCD_GITLAB_ACCESS_TOKEN}"
    DIFF_FILE: "${CI_PROJECT_DIR}/config_diff.txt"
    AWS_REGION: us-east-2
    TERRAGRUNT_ROLE: arn:aws:iam::318128524537:role/devx-application-CICD-role
    TERRAGRUNT_ENV: "${env}"
    env: dev5
  artifacts:
    paths:
    - "${CI_PROJECT_DIR}/config_diff.txt"
    when: on_failure
  extends: ".deploy_general_dev:after_build"
  tags:
  - devx-application-gitlab-runner
".deploy_dev6:after_build":
  image: registry.gitlab.com/fireblocks/devops/terraform/terraform-runner:v0.5.2
  stage: deploy-dev
  after_script:
  - rm -fr /builds/terraform/
  - echo 'Done!'
  before_script:
  - apt-get update
  - apt-get install -y curl
  - curl -fsSL https://deb.nodesource.com/setup_18.x | bash -
  - apt install -y nodejs
  - npm install -g yarn
  - touch .npmrc
  - npm config set --location=user @fireblocks:registry https://gitlab.com/api/v4/packages/npm/
  - npm config set --location=user '//gitlab.com/api/v4/packages/npm/:_authToken'
    "${NPM_REG_TOKEN}"
  - npm config set --location=user '//gitlab.com/api/v4/projects/20565764/packages/npm/:_authToken'
    "${NPM_REG_TOKEN}"
  - echo "@fireblocks:registry=https://gitlab.com/api/v4/packages/npm/">>.npmrc
  - echo "//gitlab.com/api/v4/packages/npm/:_authToken=${NPM_REG_TOKEN}">>.npmrc
  - echo "//gitlab.com/api/v4/projects/20565764/packages/npm/:_authToken=${NPM_REG_TOKEN}">>.npmrc
  - yarn global add @fireblocks/fb-cli
  - echo "validating configuration diffs in case it's a quick-rollback deployment"
  - cd /builds/
  - rm -fr /builds/terraform/
  - git clone --depth 1 --branch $TERRAFORM_REPO_BRANCH https://gitlab-ci-token:${CI_JOB_TOKEN}@gitlab.com/fireblocks/devops/terraform.git
  - "$(assume-role.sh ${TERRAGRUNT_ROLE} gitlab-runner)"
  - echo ${TERRAGRUNT_PROJECT}
  - echo looking for ${CI_PROJECT_DIR}/configurations/${TERRAGRUNT_ENV}.yaml
  - echo looking for ${CI_PROJECT_DIR}/configurations/${TERRAGRUNT_ENV}.${SERVICE_NAME}.yaml
  - if [[ ${COPY_CONFIG}="true" && -f ${CI_PROJECT_DIR}/configurations/ ]]; then ls
    ${CI_PROJECT_DIR}/configurations/ ; fi
  - if [[ ${COPY_CONFIG}="true" && -f ${CI_PROJECT_DIR}/configurations/${TERRAGRUNT_ENV}.yaml
    ]] ; then cp ${CI_PROJECT_DIR}/configurations/${TERRAGRUNT_ENV}.yaml ${TERRAGRUNT_PROJECT}/${TERRAGRUNT_ENV}.yaml
    ; fi
  - if [[ ${COPY_CONFIG}="true" && -f ${CI_PROJECT_DIR}/configurations/${TERRAGRUNT_ENV}/env.yaml
    ]] ; then cp ${CI_PROJECT_DIR}/configurations/${TERRAGRUNT_ENV}/env.yaml ${TERRAGRUNT_PROJECT}/${TERRAGRUNT_ENV}/env.yaml
    ; fi
  - if [[ ${COPY_CONFIG}="true" && -f ${CI_PROJECT_DIR}/configurations/${TERRAGRUNT_ENV}.${SERVICE_NAME}.yaml
    ]] ; then cp ${CI_PROJECT_DIR}/configurations/${TERRAGRUNT_ENV}.${SERVICE_NAME}.yaml
    ${TERRAGRUNT_PROJECT}/${TERRAGRUNT_ENV}.yaml ; fi
  - cd ${TERRAGRUNT_PROJECT}
  script:
  - echo ${SERVICE_NAME} ${IMAGE_TAG} ${CI_ENVIRONMENT_NAME} TERRAGRUNT_ENV:${TERRAGRUNT_ENV}
  - terragrunt init
  - terragrunt apply --auto-approve --var service_tag=${IMAGE_TAG}
  environment:
    name: "$env"
  variables:
    APP_VERSION: "$IMAGE_TAG"
    JOB: deploy_terragrunt_service_${TERRAGRUNT_ENV}
    TERRAGRUNT_PROJECT: "/builds/terraform/terragrunt/devx/apps/shell-services/${SERVICE_NAME}"
    TERRAFORM_SOURCE: "/builds/terraform/terraform//"
    TERRAGRUNT_BUCKET: fireblocks-terraform-remote-state-${TERRAGRUNT_ENV}
    TERRAGRUNT_LOCK: terraform-state-lock-${TERRAGRUNT_ENV}
    TERRAFORM_REPO_BRANCH: main
    GITLAB_TOKEN: "${ARGOCD_GITLAB_ACCESS_TOKEN}"
    DIFF_FILE: "${CI_PROJECT_DIR}/config_diff.txt"
    AWS_REGION: us-east-2
    TERRAGRUNT_ROLE: arn:aws:iam::318128524537:role/devx-application-CICD-role
    TERRAGRUNT_ENV: "${env}"
    env: dev6
  artifacts:
    paths:
    - "${CI_PROJECT_DIR}/config_diff.txt"
    when: on_failure
  extends: ".deploy_general_dev:after_build"
  tags:
  - devx-application-gitlab-runner
".deploy_dev6_experimental:after_build":
  image: registry.gitlab.com/fireblocks/devops/terraform/terraform-runner:v0.5.2
  stage: deploy-dev
  after_script:
  - rm -fr /builds/terraform/
  - echo 'Done!'
  before_script:
  - apt-get update
  - apt-get install -y curl
  - curl -fsSL https://deb.nodesource.com/setup_18.x | bash -
  - apt install -y nodejs
  - npm install -g yarn
  - touch .npmrc
  - npm config set --location=user @fireblocks:registry https://gitlab.com/api/v4/packages/npm/
  - npm config set --location=user '//gitlab.com/api/v4/packages/npm/:_authToken'
    "${NPM_REG_TOKEN}"
  - npm config set --location=user '//gitlab.com/api/v4/projects/20565764/packages/npm/:_authToken'
    "${NPM_REG_TOKEN}"
  - echo "@fireblocks:registry=https://gitlab.com/api/v4/packages/npm/">>.npmrc
  - echo "//gitlab.com/api/v4/packages/npm/:_authToken=${NPM_REG_TOKEN}">>.npmrc
  - echo "//gitlab.com/api/v4/projects/20565764/packages/npm/:_authToken=${NPM_REG_TOKEN}">>.npmrc
  - yarn global add @fireblocks/fb-cli
  - echo "validating configuration diffs in case it's a quick-rollback deployment"
  - cd /builds/
  - rm -fr /builds/terraform/
  - git clone --depth 1 --branch $TERRAFORM_REPO_BRANCH https://gitlab-ci-token:${CI_JOB_TOKEN}@gitlab.com/fireblocks/devops/terraform.git
  - "$(assume-role.sh ${TERRAGRUNT_ROLE} gitlab-runner)"
  - echo ${TERRAGRUNT_PROJECT}
  - echo looking for ${CI_PROJECT_DIR}/configurations/${TERRAGRUNT_ENV}.yaml
  - echo looking for ${CI_PROJECT_DIR}/configurations/${TERRAGRUNT_ENV}.${SERVICE_NAME}.yaml
  - if [[ ${COPY_CONFIG}="true" && -f ${CI_PROJECT_DIR}/configurations/ ]]; then ls
    ${CI_PROJECT_DIR}/configurations/ ; fi
  - if [[ ${COPY_CONFIG}="true" && -f ${CI_PROJECT_DIR}/configurations/${TERRAGRUNT_ENV}.yaml
    ]] ; then cp ${CI_PROJECT_DIR}/configurations/${TERRAGRUNT_ENV}.yaml ${TERRAGRUNT_PROJECT}/${TERRAGRUNT_ENV}.yaml
    ; fi
  - if [[ ${COPY_CONFIG}="true" && -f ${CI_PROJECT_DIR}/configurations/${TERRAGRUNT_ENV}/env.yaml
    ]] ; then cp ${CI_PROJECT_DIR}/configurations/${TERRAGRUNT_ENV}/env.yaml ${TERRAGRUNT_PROJECT}/${TERRAGRUNT_ENV}/env.yaml
    ; fi
  - if [[ ${COPY_CONFIG}="true" && -f ${CI_PROJECT_DIR}/configurations/${TERRAGRUNT_ENV}.${SERVICE_NAME}.yaml
    ]] ; then cp ${CI_PROJECT_DIR}/configurations/${TERRAGRUNT_ENV}.${SERVICE_NAME}.yaml
    ${TERRAGRUNT_PROJECT}/${TERRAGRUNT_ENV}.yaml ; fi
  - cd ${TERRAGRUNT_PROJECT}
  script:
  - echo ${SERVICE_NAME} ${IMAGE_TAG} ${CI_ENVIRONMENT_NAME} TERRAGRUNT_ENV:${TERRAGRUNT_ENV}
  - terragrunt init
  - terragrunt apply --auto-approve --var service_tag=${IMAGE_TAG}
  environment:
    name: "$env"
  variables:
    APP_VERSION: "$IMAGE_TAG"
    JOB: deploy_terragrunt_service_${TERRAGRUNT_ENV}
    TERRAGRUNT_PROJECT: "/builds/terraform/terragrunt/devx/apps/shell-services/${SERVICE_NAME}"
    TERRAFORM_SOURCE: "/builds/terraform/terraform//"
    TERRAGRUNT_BUCKET: fireblocks-terraform-remote-state-${TERRAGRUNT_ENV}
    TERRAGRUNT_LOCK: terraform-state-lock-${TERRAGRUNT_ENV}
    TERRAFORM_REPO_BRANCH: DEVOPS-1522-auth-lambda
    GITLAB_TOKEN: "${ARGOCD_GITLAB_ACCESS_TOKEN}"
    DIFF_FILE: "${CI_PROJECT_DIR}/config_diff.txt"
    AWS_REGION: us-east-2
    TERRAGRUNT_ROLE: arn:aws:iam::318128524537:role/devx-application-CICD-role
    TERRAGRUNT_ENV: "${env}"
    env: dev6
  artifacts:
    paths:
    - "${CI_PROJECT_DIR}/config_diff.txt"
    when: on_failure
  extends: ".deploy_general_dev:after_build"
  tags:
  - devx-application-gitlab-runner
".deploy_dev7:after_build":
  image: registry.gitlab.com/fireblocks/devops/terraform/terraform-runner:v0.5.2
  stage: deploy-dev
  after_script:
  - rm -fr /builds/terraform/
  - echo 'Done!'
  before_script:
  - apt-get update
  - apt-get install -y curl
  - curl -fsSL https://deb.nodesource.com/setup_18.x | bash -
  - apt install -y nodejs
  - npm install -g yarn
  - touch .npmrc
  - npm config set --location=user @fireblocks:registry https://gitlab.com/api/v4/packages/npm/
  - npm config set --location=user '//gitlab.com/api/v4/packages/npm/:_authToken'
    "${NPM_REG_TOKEN}"
  - npm config set --location=user '//gitlab.com/api/v4/projects/20565764/packages/npm/:_authToken'
    "${NPM_REG_TOKEN}"
  - echo "@fireblocks:registry=https://gitlab.com/api/v4/packages/npm/">>.npmrc
  - echo "//gitlab.com/api/v4/packages/npm/:_authToken=${NPM_REG_TOKEN}">>.npmrc
  - echo "//gitlab.com/api/v4/projects/20565764/packages/npm/:_authToken=${NPM_REG_TOKEN}">>.npmrc
  - yarn global add @fireblocks/fb-cli
  - echo "validating configuration diffs in case it's a quick-rollback deployment"
  - cd /builds/
  - rm -fr /builds/terraform/
  - git clone --depth 1 --branch $TERRAFORM_REPO_BRANCH https://gitlab-ci-token:${CI_JOB_TOKEN}@gitlab.com/fireblocks/devops/terraform.git
  - "$(assume-role.sh ${TERRAGRUNT_ROLE} gitlab-runner)"
  - echo ${TERRAGRUNT_PROJECT}
  - echo looking for ${CI_PROJECT_DIR}/configurations/${TERRAGRUNT_ENV}.yaml
  - echo looking for ${CI_PROJECT_DIR}/configurations/${TERRAGRUNT_ENV}.${SERVICE_NAME}.yaml
  - if [[ ${COPY_CONFIG}="true" && -f ${CI_PROJECT_DIR}/configurations/ ]]; then ls
    ${CI_PROJECT_DIR}/configurations/ ; fi
  - if [[ ${COPY_CONFIG}="true" && -f ${CI_PROJECT_DIR}/configurations/${TERRAGRUNT_ENV}.yaml
    ]] ; then cp ${CI_PROJECT_DIR}/configurations/${TERRAGRUNT_ENV}.yaml ${TERRAGRUNT_PROJECT}/${TERRAGRUNT_ENV}.yaml
    ; fi
  - if [[ ${COPY_CONFIG}="true" && -f ${CI_PROJECT_DIR}/configurations/${TERRAGRUNT_ENV}/env.yaml
    ]] ; then cp ${CI_PROJECT_DIR}/configurations/${TERRAGRUNT_ENV}/env.yaml ${TERRAGRUNT_PROJECT}/${TERRAGRUNT_ENV}/env.yaml
    ; fi
  - if [[ ${COPY_CONFIG}="true" && -f ${CI_PROJECT_DIR}/configurations/${TERRAGRUNT_ENV}.${SERVICE_NAME}.yaml
    ]] ; then cp ${CI_PROJECT_DIR}/configurations/${TERRAGRUNT_ENV}.${SERVICE_NAME}.yaml
    ${TERRAGRUNT_PROJECT}/${TERRAGRUNT_ENV}.yaml ; fi
  - cd ${TERRAGRUNT_PROJECT}
  script:
  - echo ${SERVICE_NAME} ${IMAGE_TAG} ${CI_ENVIRONMENT_NAME} TERRAGRUNT_ENV:${TERRAGRUNT_ENV}
  - terragrunt init
  - terragrunt apply --auto-approve --var service_tag=${IMAGE_TAG}
  environment:
    name: "$env"
  variables:
    APP_VERSION: "$IMAGE_TAG"
    JOB: deploy_terragrunt_service_${TERRAGRUNT_ENV}
    TERRAGRUNT_PROJECT: "/builds/terraform/terragrunt/devx/apps/shell-services/${SERVICE_NAME}"
    TERRAFORM_SOURCE: "/builds/terraform/terraform//"
    TERRAGRUNT_BUCKET: fireblocks-terraform-remote-state-${TERRAGRUNT_ENV}
    TERRAGRUNT_LOCK: terraform-state-lock-${TERRAGRUNT_ENV}
    TERRAFORM_REPO_BRANCH: main
    GITLAB_TOKEN: "${ARGOCD_GITLAB_ACCESS_TOKEN}"
    DIFF_FILE: "${CI_PROJECT_DIR}/config_diff.txt"
    AWS_REGION: us-east-2
    TERRAGRUNT_ROLE: arn:aws:iam::318128524537:role/devx-application-CICD-role
    TERRAGRUNT_ENV: "${env}"
    env: dev7
  artifacts:
    paths:
    - "${CI_PROJECT_DIR}/config_diff.txt"
    when: on_failure
  extends: ".deploy_general_dev:after_build"
  tags:
  - devx-application-gitlab-runner
".deploy_dev8:after_build":
  image: registry.gitlab.com/fireblocks/devops/terraform/terraform-runner:v0.5.2
  stage: deploy-dev
  after_script:
  - rm -fr /builds/terraform/
  - echo 'Done!'
  before_script:
  - apt-get update
  - apt-get install -y curl
  - curl -fsSL https://deb.nodesource.com/setup_18.x | bash -
  - apt install -y nodejs
  - npm install -g yarn
  - touch .npmrc
  - npm config set --location=user @fireblocks:registry https://gitlab.com/api/v4/packages/npm/
  - npm config set --location=user '//gitlab.com/api/v4/packages/npm/:_authToken'
    "${NPM_REG_TOKEN}"
  - npm config set --location=user '//gitlab.com/api/v4/projects/20565764/packages/npm/:_authToken'
    "${NPM_REG_TOKEN}"
  - echo "@fireblocks:registry=https://gitlab.com/api/v4/packages/npm/">>.npmrc
  - echo "//gitlab.com/api/v4/packages/npm/:_authToken=${NPM_REG_TOKEN}">>.npmrc
  - echo "//gitlab.com/api/v4/projects/20565764/packages/npm/:_authToken=${NPM_REG_TOKEN}">>.npmrc
  - yarn global add @fireblocks/fb-cli
  - echo "validating configuration diffs in case it's a quick-rollback deployment"
  - cd /builds/
  - rm -fr /builds/terraform/
  - git clone --depth 1 --branch $TERRAFORM_REPO_BRANCH https://gitlab-ci-token:${CI_JOB_TOKEN}@gitlab.com/fireblocks/devops/terraform.git
  - "$(assume-role.sh ${TERRAGRUNT_ROLE} gitlab-runner)"
  - echo ${TERRAGRUNT_PROJECT}
  - echo looking for ${CI_PROJECT_DIR}/configurations/${TERRAGRUNT_ENV}.yaml
  - echo looking for ${CI_PROJECT_DIR}/configurations/${TERRAGRUNT_ENV}.${SERVICE_NAME}.yaml
  - if [[ ${COPY_CONFIG}="true" && -f ${CI_PROJECT_DIR}/configurations/ ]]; then ls
    ${CI_PROJECT_DIR}/configurations/ ; fi
  - if [[ ${COPY_CONFIG}="true" && -f ${CI_PROJECT_DIR}/configurations/${TERRAGRUNT_ENV}.yaml
    ]] ; then cp ${CI_PROJECT_DIR}/configurations/${TERRAGRUNT_ENV}.yaml ${TERRAGRUNT_PROJECT}/${TERRAGRUNT_ENV}.yaml
    ; fi
  - if [[ ${COPY_CONFIG}="true" && -f ${CI_PROJECT_DIR}/configurations/${TERRAGRUNT_ENV}/env.yaml
    ]] ; then cp ${CI_PROJECT_DIR}/configurations/${TERRAGRUNT_ENV}/env.yaml ${TERRAGRUNT_PROJECT}/${TERRAGRUNT_ENV}/env.yaml
    ; fi
  - if [[ ${COPY_CONFIG}="true" && -f ${CI_PROJECT_DIR}/configurations/${TERRAGRUNT_ENV}.${SERVICE_NAME}.yaml
    ]] ; then cp ${CI_PROJECT_DIR}/configurations/${TERRAGRUNT_ENV}.${SERVICE_NAME}.yaml
    ${TERRAGRUNT_PROJECT}/${TERRAGRUNT_ENV}.yaml ; fi
  - cd ${TERRAGRUNT_PROJECT}
  script:
  - echo ${SERVICE_NAME} ${IMAGE_TAG} ${CI_ENVIRONMENT_NAME} TERRAGRUNT_ENV:${TERRAGRUNT_ENV}
  - terragrunt init
  - terragrunt apply --auto-approve --var service_tag=${IMAGE_TAG}
  environment:
    name: "$env"
  variables:
    APP_VERSION: "$IMAGE_TAG"
    JOB: deploy_terragrunt_service_${TERRAGRUNT_ENV}
    TERRAGRUNT_PROJECT: "/builds/terraform/terragrunt/devx/apps/shell-services/${SERVICE_NAME}"
    TERRAFORM_SOURCE: "/builds/terraform/terraform//"
    TERRAGRUNT_BUCKET: fireblocks-terraform-remote-state-${TERRAGRUNT_ENV}
    TERRAGRUNT_LOCK: terraform-state-lock-${TERRAGRUNT_ENV}
    TERRAFORM_REPO_BRANCH: main
    GITLAB_TOKEN: "${ARGOCD_GITLAB_ACCESS_TOKEN}"
    DIFF_FILE: "${CI_PROJECT_DIR}/config_diff.txt"
    AWS_REGION: us-east-2
    TERRAGRUNT_ROLE: arn:aws:iam::318128524537:role/devx-application-CICD-role
    TERRAGRUNT_ENV: "${env}"
    env: dev8
  artifacts:
    paths:
    - "${CI_PROJECT_DIR}/config_diff.txt"
    when: on_failure
  extends: ".deploy_general_dev:after_build"
  tags:
  - devx-application-gitlab-runner
".deploy_dev9:after_build":
  image: registry.gitlab.com/fireblocks/devops/terraform/terraform-runner:v0.5.2
  stage: deploy-dev
  after_script:
  - rm -fr /builds/terraform/
  - echo 'Done!'
  before_script:
  - apt-get update
  - apt-get install -y curl
  - curl -fsSL https://deb.nodesource.com/setup_18.x | bash -
  - apt install -y nodejs
  - npm install -g yarn
  - touch .npmrc
  - npm config set --location=user @fireblocks:registry https://gitlab.com/api/v4/packages/npm/
  - npm config set --location=user '//gitlab.com/api/v4/packages/npm/:_authToken'
    "${NPM_REG_TOKEN}"
  - npm config set --location=user '//gitlab.com/api/v4/projects/20565764/packages/npm/:_authToken'
    "${NPM_REG_TOKEN}"
  - echo "@fireblocks:registry=https://gitlab.com/api/v4/packages/npm/">>.npmrc
  - echo "//gitlab.com/api/v4/packages/npm/:_authToken=${NPM_REG_TOKEN}">>.npmrc
  - echo "//gitlab.com/api/v4/projects/20565764/packages/npm/:_authToken=${NPM_REG_TOKEN}">>.npmrc
  - yarn global add @fireblocks/fb-cli
  - echo "validating configuration diffs in case it's a quick-rollback deployment"
  - cd /builds/
  - rm -fr /builds/terraform/
  - git clone --depth 1 --branch $TERRAFORM_REPO_BRANCH https://gitlab-ci-token:${CI_JOB_TOKEN}@gitlab.com/fireblocks/devops/terraform.git
  - "$(assume-role.sh ${TERRAGRUNT_ROLE} gitlab-runner)"
  - echo ${TERRAGRUNT_PROJECT}
  - echo looking for ${CI_PROJECT_DIR}/configurations/${TERRAGRUNT_ENV}.yaml
  - echo looking for ${CI_PROJECT_DIR}/configurations/${TERRAGRUNT_ENV}.${SERVICE_NAME}.yaml
  - if [[ ${COPY_CONFIG}="true" && -f ${CI_PROJECT_DIR}/configurations/ ]]; then ls
    ${CI_PROJECT_DIR}/configurations/ ; fi
  - if [[ ${COPY_CONFIG}="true" && -f ${CI_PROJECT_DIR}/configurations/${TERRAGRUNT_ENV}.yaml
    ]] ; then cp ${CI_PROJECT_DIR}/configurations/${TERRAGRUNT_ENV}.yaml ${TERRAGRUNT_PROJECT}/${TERRAGRUNT_ENV}.yaml
    ; fi
  - if [[ ${COPY_CONFIG}="true" && -f ${CI_PROJECT_DIR}/configurations/${TERRAGRUNT_ENV}/env.yaml
    ]] ; then cp ${CI_PROJECT_DIR}/configurations/${TERRAGRUNT_ENV}/env.yaml ${TERRAGRUNT_PROJECT}/${TERRAGRUNT_ENV}/env.yaml
    ; fi
  - if [[ ${COPY_CONFIG}="true" && -f ${CI_PROJECT_DIR}/configurations/${TERRAGRUNT_ENV}.${SERVICE_NAME}.yaml
    ]] ; then cp ${CI_PROJECT_DIR}/configurations/${TERRAGRUNT_ENV}.${SERVICE_NAME}.yaml
    ${TERRAGRUNT_PROJECT}/${TERRAGRUNT_ENV}.yaml ; fi
  - cd ${TERRAGRUNT_PROJECT}
  script:
  - echo ${SERVICE_NAME} ${IMAGE_TAG} ${CI_ENVIRONMENT_NAME} TERRAGRUNT_ENV:${TERRAGRUNT_ENV}
  - terragrunt init
  - terragrunt apply --auto-approve --var service_tag=${IMAGE_TAG}
  environment:
    name: "$env"
  variables:
    APP_VERSION: "$IMAGE_TAG"
    JOB: deploy_terragrunt_service_${TERRAGRUNT_ENV}
    TERRAGRUNT_PROJECT: "/builds/terraform/terragrunt/devx/apps/shell-services/${SERVICE_NAME}"
    TERRAFORM_SOURCE: "/builds/terraform/terraform//"
    TERRAGRUNT_BUCKET: fireblocks-terraform-remote-state-${TERRAGRUNT_ENV}
    TERRAGRUNT_LOCK: terraform-state-lock-${TERRAGRUNT_ENV}
    TERRAFORM_REPO_BRANCH: main
    GITLAB_TOKEN: "${ARGOCD_GITLAB_ACCESS_TOKEN}"
    DIFF_FILE: "${CI_PROJECT_DIR}/config_diff.txt"
    AWS_REGION: us-east-2
    TERRAGRUNT_ROLE: arn:aws:iam::318128524537:role/devx-application-CICD-role
    TERRAGRUNT_ENV: "${env}"
    env: dev9
  artifacts:
    paths:
    - "${CI_PROJECT_DIR}/config_diff.txt"
    when: on_failure
  extends: ".deploy_general_dev:after_build"
  tags:
  - devx-application-gitlab-runner
".deploy_dev10:after_build":
  image: registry.gitlab.com/fireblocks/devops/terraform/terraform-runner:v0.5.2
  stage: deploy-dev
  after_script:
  - rm -fr /builds/terraform/
  - echo 'Done!'
  before_script:
  - apt-get update
  - apt-get install -y curl
  - curl -fsSL https://deb.nodesource.com/setup_18.x | bash -
  - apt install -y nodejs
  - npm install -g yarn
  - touch .npmrc
  - npm config set --location=user @fireblocks:registry https://gitlab.com/api/v4/packages/npm/
  - npm config set --location=user '//gitlab.com/api/v4/packages/npm/:_authToken'
    "${NPM_REG_TOKEN}"
  - npm config set --location=user '//gitlab.com/api/v4/projects/20565764/packages/npm/:_authToken'
    "${NPM_REG_TOKEN}"
  - echo "@fireblocks:registry=https://gitlab.com/api/v4/packages/npm/">>.npmrc
  - echo "//gitlab.com/api/v4/packages/npm/:_authToken=${NPM_REG_TOKEN}">>.npmrc
  - echo "//gitlab.com/api/v4/projects/20565764/packages/npm/:_authToken=${NPM_REG_TOKEN}">>.npmrc
  - yarn global add @fireblocks/fb-cli
  - echo "validating configuration diffs in case it's a quick-rollback deployment"
  - cd /builds/
  - rm -fr /builds/terraform/
  - git clone --depth 1 --branch $TERRAFORM_REPO_BRANCH https://gitlab-ci-token:${CI_JOB_TOKEN}@gitlab.com/fireblocks/devops/terraform.git
  - "$(assume-role.sh ${TERRAGRUNT_ROLE} gitlab-runner)"
  - echo ${TERRAGRUNT_PROJECT}
  - echo looking for ${CI_PROJECT_DIR}/configurations/${TERRAGRUNT_ENV}.yaml
  - echo looking for ${CI_PROJECT_DIR}/configurations/${TERRAGRUNT_ENV}.${SERVICE_NAME}.yaml
  - if [[ ${COPY_CONFIG}="true" && -f ${CI_PROJECT_DIR}/configurations/ ]]; then ls
    ${CI_PROJECT_DIR}/configurations/ ; fi
  - if [[ ${COPY_CONFIG}="true" && -f ${CI_PROJECT_DIR}/configurations/${TERRAGRUNT_ENV}.yaml
    ]] ; then cp ${CI_PROJECT_DIR}/configurations/${TERRAGRUNT_ENV}.yaml ${TERRAGRUNT_PROJECT}/${TERRAGRUNT_ENV}.yaml
    ; fi
  - if [[ ${COPY_CONFIG}="true" && -f ${CI_PROJECT_DIR}/configurations/${TERRAGRUNT_ENV}/env.yaml
    ]] ; then cp ${CI_PROJECT_DIR}/configurations/${TERRAGRUNT_ENV}/env.yaml ${TERRAGRUNT_PROJECT}/${TERRAGRUNT_ENV}/env.yaml
    ; fi
  - if [[ ${COPY_CONFIG}="true" && -f ${CI_PROJECT_DIR}/configurations/${TERRAGRUNT_ENV}.${SERVICE_NAME}.yaml
    ]] ; then cp ${CI_PROJECT_DIR}/configurations/${TERRAGRUNT_ENV}.${SERVICE_NAME}.yaml
    ${TERRAGRUNT_PROJECT}/${TERRAGRUNT_ENV}.yaml ; fi
  - cd ${TERRAGRUNT_PROJECT}
  script:
  - echo ${SERVICE_NAME} ${IMAGE_TAG} ${CI_ENVIRONMENT_NAME} TERRAGRUNT_ENV:${TERRAGRUNT_ENV}
  - terragrunt init
  - terragrunt apply --auto-approve --var service_tag=${IMAGE_TAG}
  environment:
    name: "$env"
  variables:
    APP_VERSION: "$IMAGE_TAG"
    JOB: deploy_terragrunt_service_${TERRAGRUNT_ENV}
    TERRAGRUNT_PROJECT: "/builds/terraform/terragrunt/devx/apps/shell-services/${SERVICE_NAME}"
    TERRAFORM_SOURCE: "/builds/terraform/terraform//"
    TERRAGRUNT_BUCKET: fireblocks-terraform-remote-state-${TERRAGRUNT_ENV}
    TERRAGRUNT_LOCK: terraform-state-lock-${TERRAGRUNT_ENV}
    TERRAFORM_REPO_BRANCH: main
    GITLAB_TOKEN: "${ARGOCD_GITLAB_ACCESS_TOKEN}"
    DIFF_FILE: "${CI_PROJECT_DIR}/config_diff.txt"
    AWS_REGION: us-east-2
    TERRAGRUNT_ROLE: arn:aws:iam::318128524537:role/devx-application-CICD-role
    TERRAGRUNT_ENV: "${env}"
    env: dev10
  artifacts:
    paths:
    - "${CI_PROJECT_DIR}/config_diff.txt"
    when: on_failure
  extends: ".deploy_general_dev:after_build"
  tags:
  - devx-application-gitlab-runner
".deploy_dev11:after_build":
  image: registry.gitlab.com/fireblocks/devops/terraform/terraform-runner:v0.5.2
  stage: deploy-dev
  after_script:
  - rm -fr /builds/terraform/
  - echo 'Done!'
  before_script:
  - apt-get update
  - apt-get install -y curl
  - curl -fsSL https://deb.nodesource.com/setup_18.x | bash -
  - apt install -y nodejs
  - npm install -g yarn
  - touch .npmrc
  - npm config set --location=user @fireblocks:registry https://gitlab.com/api/v4/packages/npm/
  - npm config set --location=user '//gitlab.com/api/v4/packages/npm/:_authToken'
    "${NPM_REG_TOKEN}"
  - npm config set --location=user '//gitlab.com/api/v4/projects/20565764/packages/npm/:_authToken'
    "${NPM_REG_TOKEN}"
  - echo "@fireblocks:registry=https://gitlab.com/api/v4/packages/npm/">>.npmrc
  - echo "//gitlab.com/api/v4/packages/npm/:_authToken=${NPM_REG_TOKEN}">>.npmrc
  - echo "//gitlab.com/api/v4/projects/20565764/packages/npm/:_authToken=${NPM_REG_TOKEN}">>.npmrc
  - yarn global add @fireblocks/fb-cli
  - echo "validating configuration diffs in case it's a quick-rollback deployment"
  - cd /builds/
  - rm -fr /builds/terraform/
  - git clone --depth 1 --branch $TERRAFORM_REPO_BRANCH https://gitlab-ci-token:${CI_JOB_TOKEN}@gitlab.com/fireblocks/devops/terraform.git
  - "$(assume-role.sh ${TERRAGRUNT_ROLE} gitlab-runner)"
  - echo ${TERRAGRUNT_PROJECT}
  - echo looking for ${CI_PROJECT_DIR}/configurations/${TERRAGRUNT_ENV}.yaml
  - echo looking for ${CI_PROJECT_DIR}/configurations/${TERRAGRUNT_ENV}.${SERVICE_NAME}.yaml
  - if [[ ${COPY_CONFIG}="true" && -f ${CI_PROJECT_DIR}/configurations/ ]]; then ls
    ${CI_PROJECT_DIR}/configurations/ ; fi
  - if [[ ${COPY_CONFIG}="true" && -f ${CI_PROJECT_DIR}/configurations/${TERRAGRUNT_ENV}.yaml
    ]] ; then cp ${CI_PROJECT_DIR}/configurations/${TERRAGRUNT_ENV}.yaml ${TERRAGRUNT_PROJECT}/${TERRAGRUNT_ENV}.yaml
    ; fi
  - if [[ ${COPY_CONFIG}="true" && -f ${CI_PROJECT_DIR}/configurations/${TERRAGRUNT_ENV}/env.yaml
    ]] ; then cp ${CI_PROJECT_DIR}/configurations/${TERRAGRUNT_ENV}/env.yaml ${TERRAGRUNT_PROJECT}/${TERRAGRUNT_ENV}/env.yaml
    ; fi
  - if [[ ${COPY_CONFIG}="true" && -f ${CI_PROJECT_DIR}/configurations/${TERRAGRUNT_ENV}.${SERVICE_NAME}.yaml
    ]] ; then cp ${CI_PROJECT_DIR}/configurations/${TERRAGRUNT_ENV}.${SERVICE_NAME}.yaml
    ${TERRAGRUNT_PROJECT}/${TERRAGRUNT_ENV}.yaml ; fi
  - cd ${TERRAGRUNT_PROJECT}
  script:
  - echo ${SERVICE_NAME} ${IMAGE_TAG} ${CI_ENVIRONMENT_NAME} TERRAGRUNT_ENV:${TERRAGRUNT_ENV}
  - terragrunt init
  - terragrunt apply --auto-approve --var service_tag=${IMAGE_TAG}
  environment:
    name: "$env"
  variables:
    APP_VERSION: "$IMAGE_TAG"
    JOB: deploy_terragrunt_service_${TERRAGRUNT_ENV}
    TERRAGRUNT_PROJECT: "/builds/terraform/terragrunt/devx/apps/shell-services/${SERVICE_NAME}"
    TERRAFORM_SOURCE: "/builds/terraform/terraform//"
    TERRAGRUNT_BUCKET: fireblocks-terraform-remote-state-${TERRAGRUNT_ENV}
    TERRAGRUNT_LOCK: terraform-state-lock-${TERRAGRUNT_ENV}
    TERRAFORM_REPO_BRANCH: main
    GITLAB_TOKEN: "${ARGOCD_GITLAB_ACCESS_TOKEN}"
    DIFF_FILE: "${CI_PROJECT_DIR}/config_diff.txt"
    AWS_REGION: us-east-2
    TERRAGRUNT_ROLE: arn:aws:iam::318128524537:role/devx-application-CICD-role
    TERRAGRUNT_ENV: "${env}"
    env: dev11
  artifacts:
    paths:
    - "${CI_PROJECT_DIR}/config_diff.txt"
    when: on_failure
  extends: ".deploy_general_dev:after_build"
  tags:
  - devx-application-gitlab-runner
".deploy_dev12:after_build":
  image: registry.gitlab.com/fireblocks/devops/terraform/terraform-runner:v0.5.2
  stage: deploy-dev
  after_script:
  - rm -fr /builds/terraform/
  - echo 'Done!'
  before_script:
  - apt-get update
  - apt-get install -y curl
  - curl -fsSL https://deb.nodesource.com/setup_18.x | bash -
  - apt install -y nodejs
  - npm install -g yarn
  - touch .npmrc
  - npm config set --location=user @fireblocks:registry https://gitlab.com/api/v4/packages/npm/
  - npm config set --location=user '//gitlab.com/api/v4/packages/npm/:_authToken'
    "${NPM_REG_TOKEN}"
  - npm config set --location=user '//gitlab.com/api/v4/projects/20565764/packages/npm/:_authToken'
    "${NPM_REG_TOKEN}"
  - echo "@fireblocks:registry=https://gitlab.com/api/v4/packages/npm/">>.npmrc
  - echo "//gitlab.com/api/v4/packages/npm/:_authToken=${NPM_REG_TOKEN}">>.npmrc
  - echo "//gitlab.com/api/v4/projects/20565764/packages/npm/:_authToken=${NPM_REG_TOKEN}">>.npmrc
  - yarn global add @fireblocks/fb-cli
  - echo "validating configuration diffs in case it's a quick-rollback deployment"
  - cd /builds/
  - rm -fr /builds/terraform/
  - git clone --depth 1 --branch $TERRAFORM_REPO_BRANCH https://gitlab-ci-token:${CI_JOB_TOKEN}@gitlab.com/fireblocks/devops/terraform.git
  - "$(assume-role.sh ${TERRAGRUNT_ROLE} gitlab-runner)"
  - echo ${TERRAGRUNT_PROJECT}
  - echo looking for ${CI_PROJECT_DIR}/configurations/${TERRAGRUNT_ENV}.yaml
  - echo looking for ${CI_PROJECT_DIR}/configurations/${TERRAGRUNT_ENV}.${SERVICE_NAME}.yaml
  - if [[ ${COPY_CONFIG}="true" && -f ${CI_PROJECT_DIR}/configurations/ ]]; then ls
    ${CI_PROJECT_DIR}/configurations/ ; fi
  - if [[ ${COPY_CONFIG}="true" && -f ${CI_PROJECT_DIR}/configurations/${TERRAGRUNT_ENV}.yaml
    ]] ; then cp ${CI_PROJECT_DIR}/configurations/${TERRAGRUNT_ENV}.yaml ${TERRAGRUNT_PROJECT}/${TERRAGRUNT_ENV}.yaml
    ; fi
  - if [[ ${COPY_CONFIG}="true" && -f ${CI_PROJECT_DIR}/configurations/${TERRAGRUNT_ENV}/env.yaml
    ]] ; then cp ${CI_PROJECT_DIR}/configurations/${TERRAGRUNT_ENV}/env.yaml ${TERRAGRUNT_PROJECT}/${TERRAGRUNT_ENV}/env.yaml
    ; fi
  - if [[ ${COPY_CONFIG}="true" && -f ${CI_PROJECT_DIR}/configurations/${TERRAGRUNT_ENV}.${SERVICE_NAME}.yaml
    ]] ; then cp ${CI_PROJECT_DIR}/configurations/${TERRAGRUNT_ENV}.${SERVICE_NAME}.yaml
    ${TERRAGRUNT_PROJECT}/${TERRAGRUNT_ENV}.yaml ; fi
  - cd ${TERRAGRUNT_PROJECT}
  script:
  - echo ${SERVICE_NAME} ${IMAGE_TAG} ${CI_ENVIRONMENT_NAME} TERRAGRUNT_ENV:${TERRAGRUNT_ENV}
  - terragrunt init
  - terragrunt apply --auto-approve --var service_tag=${IMAGE_TAG}
  environment:
    name: "$env"
  variables:
    APP_VERSION: "$IMAGE_TAG"
    JOB: deploy_terragrunt_service_${TERRAGRUNT_ENV}
    TERRAGRUNT_PROJECT: "/builds/terraform/terragrunt/devx/apps/shell-services/${SERVICE_NAME}"
    TERRAFORM_SOURCE: "/builds/terraform/terraform//"
    TERRAGRUNT_BUCKET: fireblocks-terraform-remote-state-${TERRAGRUNT_ENV}
    TERRAGRUNT_LOCK: terraform-state-lock-${TERRAGRUNT_ENV}
    TERRAFORM_REPO_BRANCH: main
    GITLAB_TOKEN: "${ARGOCD_GITLAB_ACCESS_TOKEN}"
    DIFF_FILE: "${CI_PROJECT_DIR}/config_diff.txt"
    AWS_REGION: us-east-2
    TERRAGRUNT_ROLE: arn:aws:iam::318128524537:role/devx-application-CICD-role
    TERRAGRUNT_ENV: "${env}"
    env: dev12
  artifacts:
    paths:
    - "${CI_PROJECT_DIR}/config_diff.txt"
    when: on_failure
  extends: ".deploy_general_dev:after_build"
  tags:
  - devx-application-gitlab-runner
".deploy_dev13:after_build":
  image: registry.gitlab.com/fireblocks/devops/terraform/terraform-runner:v0.5.2
  stage: deploy-dev
  after_script:
  - rm -fr /builds/terraform/
  - echo 'Done!'
  before_script:
  - apt-get update
  - apt-get install -y curl
  - curl -fsSL https://deb.nodesource.com/setup_18.x | bash -
  - apt install -y nodejs
  - npm install -g yarn
  - touch .npmrc
  - npm config set --location=user @fireblocks:registry https://gitlab.com/api/v4/packages/npm/
  - npm config set --location=user '//gitlab.com/api/v4/packages/npm/:_authToken'
    "${NPM_REG_TOKEN}"
  - npm config set --location=user '//gitlab.com/api/v4/projects/20565764/packages/npm/:_authToken'
    "${NPM_REG_TOKEN}"
  - echo "@fireblocks:registry=https://gitlab.com/api/v4/packages/npm/">>.npmrc
  - echo "//gitlab.com/api/v4/packages/npm/:_authToken=${NPM_REG_TOKEN}">>.npmrc
  - echo "//gitlab.com/api/v4/projects/20565764/packages/npm/:_authToken=${NPM_REG_TOKEN}">>.npmrc
  - yarn global add @fireblocks/fb-cli
  - echo "validating configuration diffs in case it's a quick-rollback deployment"
  - cd /builds/
  - rm -fr /builds/terraform/
  - git clone --depth 1 --branch $TERRAFORM_REPO_BRANCH https://gitlab-ci-token:${CI_JOB_TOKEN}@gitlab.com/fireblocks/devops/terraform.git
  - "$(assume-role.sh ${TERRAGRUNT_ROLE} gitlab-runner)"
  - echo ${TERRAGRUNT_PROJECT}
  - echo looking for ${CI_PROJECT_DIR}/configurations/${TERRAGRUNT_ENV}.yaml
  - echo looking for ${CI_PROJECT_DIR}/configurations/${TERRAGRUNT_ENV}.${SERVICE_NAME}.yaml
  - if [[ ${COPY_CONFIG}="true" && -f ${CI_PROJECT_DIR}/configurations/ ]]; then ls
    ${CI_PROJECT_DIR}/configurations/ ; fi
  - if [[ ${COPY_CONFIG}="true" && -f ${CI_PROJECT_DIR}/configurations/${TERRAGRUNT_ENV}.yaml
    ]] ; then cp ${CI_PROJECT_DIR}/configurations/${TERRAGRUNT_ENV}.yaml ${TERRAGRUNT_PROJECT}/${TERRAGRUNT_ENV}.yaml
    ; fi
  - if [[ ${COPY_CONFIG}="true" && -f ${CI_PROJECT_DIR}/configurations/${TERRAGRUNT_ENV}/env.yaml
    ]] ; then cp ${CI_PROJECT_DIR}/configurations/${TERRAGRUNT_ENV}/env.yaml ${TERRAGRUNT_PROJECT}/${TERRAGRUNT_ENV}/env.yaml
    ; fi
  - if [[ ${COPY_CONFIG}="true" && -f ${CI_PROJECT_DIR}/configurations/${TERRAGRUNT_ENV}.${SERVICE_NAME}.yaml
    ]] ; then cp ${CI_PROJECT_DIR}/configurations/${TERRAGRUNT_ENV}.${SERVICE_NAME}.yaml
    ${TERRAGRUNT_PROJECT}/${TERRAGRUNT_ENV}.yaml ; fi
  - cd ${TERRAGRUNT_PROJECT}
  script:
  - echo ${SERVICE_NAME} ${IMAGE_TAG} ${CI_ENVIRONMENT_NAME} TERRAGRUNT_ENV:${TERRAGRUNT_ENV}
  - terragrunt init
  - terragrunt apply --auto-approve --var service_tag=${IMAGE_TAG}
  environment:
    name: "$env"
  variables:
    APP_VERSION: "$IMAGE_TAG"
    JOB: deploy_terragrunt_service_${TERRAGRUNT_ENV}
    TERRAGRUNT_PROJECT: "/builds/terraform/terragrunt/devx/apps/shell-services/${SERVICE_NAME}"
    TERRAFORM_SOURCE: "/builds/terraform/terraform//"
    TERRAGRUNT_BUCKET: fireblocks-terraform-remote-state-${TERRAGRUNT_ENV}
    TERRAGRUNT_LOCK: terraform-state-lock-${TERRAGRUNT_ENV}
    TERRAFORM_REPO_BRANCH: main
    GITLAB_TOKEN: "${ARGOCD_GITLAB_ACCESS_TOKEN}"
    DIFF_FILE: "${CI_PROJECT_DIR}/config_diff.txt"
    AWS_REGION: us-east-2
    TERRAGRUNT_ROLE: arn:aws:iam::318128524537:role/devx-application-CICD-role
    TERRAGRUNT_ENV: "${env}"
    env: dev13
  artifacts:
    paths:
    - "${CI_PROJECT_DIR}/config_diff.txt"
    when: on_failure
  extends: ".deploy_general_dev:after_build"
  tags:
  - devx-application-gitlab-runner
".deploy_dev14:after_build":
  image: registry.gitlab.com/fireblocks/devops/terraform/terraform-runner:v0.5.2
  stage: deploy-dev
  after_script:
  - rm -fr /builds/terraform/
  - echo 'Done!'
  before_script:
  - apt-get update
  - apt-get install -y curl
  - curl -fsSL https://deb.nodesource.com/setup_18.x | bash -
  - apt install -y nodejs
  - npm install -g yarn
  - touch .npmrc
  - npm config set --location=user @fireblocks:registry https://gitlab.com/api/v4/packages/npm/
  - npm config set --location=user '//gitlab.com/api/v4/packages/npm/:_authToken'
    "${NPM_REG_TOKEN}"
  - npm config set --location=user '//gitlab.com/api/v4/projects/20565764/packages/npm/:_authToken'
    "${NPM_REG_TOKEN}"
  - echo "@fireblocks:registry=https://gitlab.com/api/v4/packages/npm/">>.npmrc
  - echo "//gitlab.com/api/v4/packages/npm/:_authToken=${NPM_REG_TOKEN}">>.npmrc
  - echo "//gitlab.com/api/v4/projects/20565764/packages/npm/:_authToken=${NPM_REG_TOKEN}">>.npmrc
  - yarn global add @fireblocks/fb-cli
  - echo "validating configuration diffs in case it's a quick-rollback deployment"
  - cd /builds/
  - rm -fr /builds/terraform/
  - git clone --depth 1 --branch $TERRAFORM_REPO_BRANCH https://gitlab-ci-token:${CI_JOB_TOKEN}@gitlab.com/fireblocks/devops/terraform.git
  - "$(assume-role.sh ${TERRAGRUNT_ROLE} gitlab-runner)"
  - echo ${TERRAGRUNT_PROJECT}
  - echo looking for ${CI_PROJECT_DIR}/configurations/${TERRAGRUNT_ENV}.yaml
  - echo looking for ${CI_PROJECT_DIR}/configurations/${TERRAGRUNT_ENV}.${SERVICE_NAME}.yaml
  - if [[ ${COPY_CONFIG}="true" && -f ${CI_PROJECT_DIR}/configurations/ ]]; then ls
    ${CI_PROJECT_DIR}/configurations/ ; fi
  - if [[ ${COPY_CONFIG}="true" && -f ${CI_PROJECT_DIR}/configurations/${TERRAGRUNT_ENV}.yaml
    ]] ; then cp ${CI_PROJECT_DIR}/configurations/${TERRAGRUNT_ENV}.yaml ${TERRAGRUNT_PROJECT}/${TERRAGRUNT_ENV}.yaml
    ; fi
  - if [[ ${COPY_CONFIG}="true" && -f ${CI_PROJECT_DIR}/configurations/${TERRAGRUNT_ENV}/env.yaml
    ]] ; then cp ${CI_PROJECT_DIR}/configurations/${TERRAGRUNT_ENV}/env.yaml ${TERRAGRUNT_PROJECT}/${TERRAGRUNT_ENV}/env.yaml
    ; fi
  - if [[ ${COPY_CONFIG}="true" && -f ${CI_PROJECT_DIR}/configurations/${TERRAGRUNT_ENV}.${SERVICE_NAME}.yaml
    ]] ; then cp ${CI_PROJECT_DIR}/configurations/${TERRAGRUNT_ENV}.${SERVICE_NAME}.yaml
    ${TERRAGRUNT_PROJECT}/${TERRAGRUNT_ENV}.yaml ; fi
  - cd ${TERRAGRUNT_PROJECT}
  script:
  - echo ${SERVICE_NAME} ${IMAGE_TAG} ${CI_ENVIRONMENT_NAME} TERRAGRUNT_ENV:${TERRAGRUNT_ENV}
  - terragrunt init
  - terragrunt apply --auto-approve --var service_tag=${IMAGE_TAG}
  environment:
    name: "$env"
  variables:
    APP_VERSION: "$IMAGE_TAG"
    JOB: deploy_terragrunt_service_${TERRAGRUNT_ENV}
    TERRAGRUNT_PROJECT: "/builds/terraform/terragrunt/devx/apps/shell-services/${SERVICE_NAME}"
    TERRAFORM_SOURCE: "/builds/terraform/terraform//"
    TERRAGRUNT_BUCKET: fireblocks-terraform-remote-state-${TERRAGRUNT_ENV}
    TERRAGRUNT_LOCK: terraform-state-lock-${TERRAGRUNT_ENV}
    TERRAFORM_REPO_BRANCH: main
    GITLAB_TOKEN: "${ARGOCD_GITLAB_ACCESS_TOKEN}"
    DIFF_FILE: "${CI_PROJECT_DIR}/config_diff.txt"
    AWS_REGION: us-east-2
    TERRAGRUNT_ROLE: arn:aws:iam::318128524537:role/devx-application-CICD-role
    TERRAGRUNT_ENV: "${env}"
    env: dev14
  artifacts:
    paths:
    - "${CI_PROJECT_DIR}/config_diff.txt"
    when: on_failure
  extends: ".deploy_general_dev:after_build"
  tags:
  - devx-application-gitlab-runner
".deploy_dev15:after_build":
  image: registry.gitlab.com/fireblocks/devops/terraform/terraform-runner:v0.5.2
  stage: deploy-dev
  after_script:
  - rm -fr /builds/terraform/
  - echo 'Done!'
  before_script:
  - apt-get update
  - apt-get install -y curl
  - curl -fsSL https://deb.nodesource.com/setup_18.x | bash -
  - apt install -y nodejs
  - npm install -g yarn
  - touch .npmrc
  - npm config set --location=user @fireblocks:registry https://gitlab.com/api/v4/packages/npm/
  - npm config set --location=user '//gitlab.com/api/v4/packages/npm/:_authToken'
    "${NPM_REG_TOKEN}"
  - npm config set --location=user '//gitlab.com/api/v4/projects/20565764/packages/npm/:_authToken'
    "${NPM_REG_TOKEN}"
  - echo "@fireblocks:registry=https://gitlab.com/api/v4/packages/npm/">>.npmrc
  - echo "//gitlab.com/api/v4/packages/npm/:_authToken=${NPM_REG_TOKEN}">>.npmrc
  - echo "//gitlab.com/api/v4/projects/20565764/packages/npm/:_authToken=${NPM_REG_TOKEN}">>.npmrc
  - yarn global add @fireblocks/fb-cli
  - echo "validating configuration diffs in case it's a quick-rollback deployment"
  - cd /builds/
  - rm -fr /builds/terraform/
  - git clone --depth 1 --branch $TERRAFORM_REPO_BRANCH https://gitlab-ci-token:${CI_JOB_TOKEN}@gitlab.com/fireblocks/devops/terraform.git
  - "$(assume-role.sh ${TERRAGRUNT_ROLE} gitlab-runner)"
  - echo ${TERRAGRUNT_PROJECT}
  - echo looking for ${CI_PROJECT_DIR}/configurations/${TERRAGRUNT_ENV}.yaml
  - echo looking for ${CI_PROJECT_DIR}/configurations/${TERRAGRUNT_ENV}.${SERVICE_NAME}.yaml
  - if [[ ${COPY_CONFIG}="true" && -f ${CI_PROJECT_DIR}/configurations/ ]]; then ls
    ${CI_PROJECT_DIR}/configurations/ ; fi
  - if [[ ${COPY_CONFIG}="true" && -f ${CI_PROJECT_DIR}/configurations/${TERRAGRUNT_ENV}.yaml
    ]] ; then cp ${CI_PROJECT_DIR}/configurations/${TERRAGRUNT_ENV}.yaml ${TERRAGRUNT_PROJECT}/${TERRAGRUNT_ENV}.yaml
    ; fi
  - if [[ ${COPY_CONFIG}="true" && -f ${CI_PROJECT_DIR}/configurations/${TERRAGRUNT_ENV}/env.yaml
    ]] ; then cp ${CI_PROJECT_DIR}/configurations/${TERRAGRUNT_ENV}/env.yaml ${TERRAGRUNT_PROJECT}/${TERRAGRUNT_ENV}/env.yaml
    ; fi
  - if [[ ${COPY_CONFIG}="true" && -f ${CI_PROJECT_DIR}/configurations/${TERRAGRUNT_ENV}.${SERVICE_NAME}.yaml
    ]] ; then cp ${CI_PROJECT_DIR}/configurations/${TERRAGRUNT_ENV}.${SERVICE_NAME}.yaml
    ${TERRAGRUNT_PROJECT}/${TERRAGRUNT_ENV}.yaml ; fi
  - cd ${TERRAGRUNT_PROJECT}
  script:
  - echo ${SERVICE_NAME} ${IMAGE_TAG} ${CI_ENVIRONMENT_NAME} TERRAGRUNT_ENV:${TERRAGRUNT_ENV}
  - terragrunt init
  - terragrunt apply --auto-approve --var service_tag=${IMAGE_TAG}
  environment:
    name: "$env"
  variables:
    APP_VERSION: "$IMAGE_TAG"
    JOB: deploy_terragrunt_service_${TERRAGRUNT_ENV}
    TERRAGRUNT_PROJECT: "/builds/terraform/terragrunt/devx/apps/shell-services/${SERVICE_NAME}"
    TERRAFORM_SOURCE: "/builds/terraform/terraform//"
    TERRAGRUNT_BUCKET: fireblocks-terraform-remote-state-${TERRAGRUNT_ENV}
    TERRAGRUNT_LOCK: terraform-state-lock-${TERRAGRUNT_ENV}
    TERRAFORM_REPO_BRANCH: main
    GITLAB_TOKEN: "${ARGOCD_GITLAB_ACCESS_TOKEN}"
    DIFF_FILE: "${CI_PROJECT_DIR}/config_diff.txt"
    AWS_REGION: us-east-2
    TERRAGRUNT_ROLE: arn:aws:iam::318128524537:role/devx-application-CICD-role
    TERRAGRUNT_ENV: "${env}"
    env: dev15
  artifacts:
    paths:
    - "${CI_PROJECT_DIR}/config_diff.txt"
    when: on_failure
  extends: ".deploy_general_dev:after_build"
  tags:
  - devx-application-gitlab-runner
".deploy_eu-prod-fr:after_build":
  image: registry.gitlab.com/fireblocks/devops/terraform/terraform-runner:v0.5.2
  stage: deploy-dev
  after_script:
  - rm -fr /builds/terraform/
  - echo 'Done!'
  before_script:
  - apt-get update
  - apt-get install -y curl
  - curl -fsSL https://deb.nodesource.com/setup_18.x | bash -
  - apt install -y nodejs
  - npm install -g yarn
  - touch .npmrc
  - npm config set --location=user @fireblocks:registry https://gitlab.com/api/v4/packages/npm/
  - npm config set --location=user '//gitlab.com/api/v4/packages/npm/:_authToken'
    "${NPM_REG_TOKEN}"
  - npm config set --location=user '//gitlab.com/api/v4/projects/20565764/packages/npm/:_authToken'
    "${NPM_REG_TOKEN}"
  - echo "@fireblocks:registry=https://gitlab.com/api/v4/packages/npm/">>.npmrc
  - echo "//gitlab.com/api/v4/packages/npm/:_authToken=${NPM_REG_TOKEN}">>.npmrc
  - echo "//gitlab.com/api/v4/projects/20565764/packages/npm/:_authToken=${NPM_REG_TOKEN}">>.npmrc
  - yarn global add @fireblocks/fb-cli
  - echo "validating configuration diffs in case it's a quick-rollback deployment"
  - cd /builds/
  - rm -fr /builds/terraform/
  - git clone --depth 1 --branch $TERRAFORM_REPO_BRANCH https://gitlab-ci-token:${CI_JOB_TOKEN}@gitlab.com/fireblocks/devops/terraform.git
  - "$(assume-role.sh ${TERRAGRUNT_ROLE} gitlab-runner)"
  - echo ${TERRAGRUNT_PROJECT}
  - echo looking for ${CI_PROJECT_DIR}/configurations/${TERRAGRUNT_ENV}.yaml
  - echo looking for ${CI_PROJECT_DIR}/configurations/${TERRAGRUNT_ENV}.${SERVICE_NAME}.yaml
  - if [[ ${COPY_CONFIG}="true" && -f ${CI_PROJECT_DIR}/configurations/ ]]; then ls
    ${CI_PROJECT_DIR}/configurations/ ; fi
  - if [[ ${COPY_CONFIG}="true" && -f ${CI_PROJECT_DIR}/configurations/${TERRAGRUNT_ENV}.yaml
    ]] ; then cp ${CI_PROJECT_DIR}/configurations/${TERRAGRUNT_ENV}.yaml ${TERRAGRUNT_PROJECT}/${TERRAGRUNT_ENV}.yaml
    ; fi
  - if [[ ${COPY_CONFIG}="true" && -f ${CI_PROJECT_DIR}/configurations/${TERRAGRUNT_ENV}/env.yaml
    ]] ; then cp ${CI_PROJECT_DIR}/configurations/${TERRAGRUNT_ENV}/env.yaml ${TERRAGRUNT_PROJECT}/${TERRAGRUNT_ENV}/env.yaml
    ; fi
  - if [[ ${COPY_CONFIG}="true" && -f ${CI_PROJECT_DIR}/configurations/${TERRAGRUNT_ENV}.${SERVICE_NAME}.yaml
    ]] ; then cp ${CI_PROJECT_DIR}/configurations/${TERRAGRUNT_ENV}.${SERVICE_NAME}.yaml
    ${TERRAGRUNT_PROJECT}/${TERRAGRUNT_ENV}.yaml ; fi
  - cd ${TERRAGRUNT_PROJECT}
  script:
  - echo ${SERVICE_NAME} ${IMAGE_TAG} ${CI_ENVIRONMENT_NAME} TERRAGRUNT_ENV:${TERRAGRUNT_ENV}
  - terragrunt init
  - terragrunt apply --auto-approve --var service_tag=${IMAGE_TAG}
  environment:
    name: "$env"
  variables:
    APP_VERSION: "$IMAGE_TAG"
    JOB: deploy_terragrunt_service_${TERRAGRUNT_ENV}
    TERRAGRUNT_PROJECT: "/builds/terraform/terragrunt/devx/apps/shell-services/${SERVICE_NAME}"
    TERRAFORM_SOURCE: "/builds/terraform/terraform//"
    TERRAGRUNT_BUCKET: fireblocks-terraform-remote-state-${TERRAGRUNT_ENV}
    TERRAGRUNT_LOCK: terraform-state-lock-${TERRAGRUNT_ENV}
    TERRAFORM_REPO_BRANCH: main
    GITLAB_TOKEN: "${ARGOCD_GITLAB_ACCESS_TOKEN}"
    DIFF_FILE: "${CI_PROJECT_DIR}/config_diff.txt"
    AWS_REGION: eu-central-1
    TERRAGRUNT_ROLE: arn:aws:iam::455399297295:role/eu-prod-fr-shell-EKSDevRWAccessRole
    TERRAGRUNT_ENV: eu-prod-fr
    env: eu-prod
  artifacts:
    paths:
    - "${CI_PROJECT_DIR}/config_diff.txt"
    when: on_failure
  extends: ".deploy_general:after_build"
  tags:
  - eu-prod-fr
".deploy_sandbox:after_build":
  image: registry.gitlab.com/fireblocks/devops/terraform/terraform-runner:v0.5.2
  stage: deploy-dev
  after_script:
  - rm -fr /builds/terraform/
  - echo 'Done!'
  before_script:
  - apt-get update
  - apt-get install -y curl
  - curl -fsSL https://deb.nodesource.com/setup_18.x | bash -
  - apt install -y nodejs
  - npm install -g yarn
  - touch .npmrc
  - npm config set --location=user @fireblocks:registry https://gitlab.com/api/v4/packages/npm/
  - npm config set --location=user '//gitlab.com/api/v4/packages/npm/:_authToken'
    "${NPM_REG_TOKEN}"
  - npm config set --location=user '//gitlab.com/api/v4/projects/20565764/packages/npm/:_authToken'
    "${NPM_REG_TOKEN}"
  - echo "@fireblocks:registry=https://gitlab.com/api/v4/packages/npm/">>.npmrc
  - echo "//gitlab.com/api/v4/packages/npm/:_authToken=${NPM_REG_TOKEN}">>.npmrc
  - echo "//gitlab.com/api/v4/projects/20565764/packages/npm/:_authToken=${NPM_REG_TOKEN}">>.npmrc
  - yarn global add @fireblocks/fb-cli
  - echo "validating configuration diffs in case it's a quick-rollback deployment"
  - cd /builds/
  - rm -fr /builds/terraform/
  - git clone --depth 1 --branch $TERRAFORM_REPO_BRANCH https://gitlab-ci-token:${CI_JOB_TOKEN}@gitlab.com/fireblocks/devops/terraform.git
  - "$(assume-role.sh ${TERRAGRUNT_ROLE} gitlab-runner)"
  - echo ${TERRAGRUNT_PROJECT}
  - echo looking for ${CI_PROJECT_DIR}/configurations/${TERRAGRUNT_ENV}.yaml
  - echo looking for ${CI_PROJECT_DIR}/configurations/${TERRAGRUNT_ENV}.${SERVICE_NAME}.yaml
  - if [[ ${COPY_CONFIG}="true" && -f ${CI_PROJECT_DIR}/configurations/ ]]; then ls
    ${CI_PROJECT_DIR}/configurations/ ; fi
  - if [[ ${COPY_CONFIG}="true" && -f ${CI_PROJECT_DIR}/configurations/${TERRAGRUNT_ENV}.yaml
    ]] ; then cp ${CI_PROJECT_DIR}/configurations/${TERRAGRUNT_ENV}.yaml ${TERRAGRUNT_PROJECT}/${TERRAGRUNT_ENV}.yaml
    ; fi
  - if [[ ${COPY_CONFIG}="true" && -f ${CI_PROJECT_DIR}/configurations/${TERRAGRUNT_ENV}/env.yaml
    ]] ; then cp ${CI_PROJECT_DIR}/configurations/${TERRAGRUNT_ENV}/env.yaml ${TERRAGRUNT_PROJECT}/${TERRAGRUNT_ENV}/env.yaml
    ; fi
  - if [[ ${COPY_CONFIG}="true" && -f ${CI_PROJECT_DIR}/configurations/${TERRAGRUNT_ENV}.${SERVICE_NAME}.yaml
    ]] ; then cp ${CI_PROJECT_DIR}/configurations/${TERRAGRUNT_ENV}.${SERVICE_NAME}.yaml
    ${TERRAGRUNT_PROJECT}/${TERRAGRUNT_ENV}.yaml ; fi
  - cd ${TERRAGRUNT_PROJECT}
  script:
  - echo ${SERVICE_NAME} ${IMAGE_TAG} ${CI_ENVIRONMENT_NAME} TERRAGRUNT_ENV:${TERRAGRUNT_ENV}
  - terragrunt init
  - terragrunt apply --auto-approve --var service_tag=${IMAGE_TAG}
  environment:
    name: "$env"
  variables:
    APP_VERSION: "$IMAGE_TAG"
    JOB: deploy_terragrunt_service_${TERRAGRUNT_ENV}
    TERRAGRUNT_PROJECT: "/builds/terraform/terragrunt/devx/apps/shell-services/${SERVICE_NAME}"
    TERRAFORM_SOURCE: "/builds/terraform/terraform//"
    TERRAGRUNT_BUCKET: fireblocks-terraform-remote-state-${TERRAGRUNT_ENV}
    TERRAGRUNT_LOCK: terraform-state-lock-${TERRAGRUNT_ENV}
    TERRAFORM_REPO_BRANCH: main
    GITLAB_TOKEN: "${ARGOCD_GITLAB_ACCESS_TOKEN}"
    DIFF_FILE: "${CI_PROJECT_DIR}/config_diff.txt"
    AWS_REGION: us-east-2
    TERRAGRUNT_ROLE: arn:aws:iam::751886943440:role/dlg-sandbox-k8s-EKSDevRWAccessRole
    TERRAGRUNT_ENV: sandbox
    env: sandbox
  artifacts:
    paths:
    - "${CI_PROJECT_DIR}/config_diff.txt"
    when: on_failure
  extends: ".deploy_general:after_build"
  tags:
  - sandbox
".deploy_bnym-dev-shell:after_build":
  image: registry.gitlab.com/fireblocks/devops/terraform/terraform-runner:v0.5.2
  stage: deploy-dev
  after_script:
  - rm -fr /builds/terraform/
  - echo 'Done!'
  before_script:
  - apt-get update
  - apt-get install -y curl
  - curl -fsSL https://deb.nodesource.com/setup_18.x | bash -
  - apt install -y nodejs
  - npm install -g yarn
  - touch .npmrc
  - npm config set --location=user @fireblocks:registry https://gitlab.com/api/v4/packages/npm/
  - npm config set --location=user '//gitlab.com/api/v4/packages/npm/:_authToken'
    "${NPM_REG_TOKEN}"
  - npm config set --location=user '//gitlab.com/api/v4/projects/20565764/packages/npm/:_authToken'
    "${NPM_REG_TOKEN}"
  - echo "@fireblocks:registry=https://gitlab.com/api/v4/packages/npm/">>.npmrc
  - echo "//gitlab.com/api/v4/packages/npm/:_authToken=${NPM_REG_TOKEN}">>.npmrc
  - echo "//gitlab.com/api/v4/projects/20565764/packages/npm/:_authToken=${NPM_REG_TOKEN}">>.npmrc
  - yarn global add @fireblocks/fb-cli
  - echo "validating configuration diffs in case it's a quick-rollback deployment"
  - cd /builds/
  - rm -fr /builds/terraform/
  - git clone --depth 1 --branch $TERRAFORM_REPO_BRANCH https://gitlab-ci-token:${CI_JOB_TOKEN}@gitlab.com/fireblocks/devops/terraform.git
  - "$(assume-role.sh ${TERRAGRUNT_ROLE} gitlab-runner)"
  - echo ${TERRAGRUNT_PROJECT}
  - echo looking for ${CI_PROJECT_DIR}/configurations/${TERRAGRUNT_ENV}.yaml
  - echo looking for ${CI_PROJECT_DIR}/configurations/${TERRAGRUNT_ENV}.${SERVICE_NAME}.yaml
  - if [[ ${COPY_CONFIG}="true" && -f ${CI_PROJECT_DIR}/configurations/ ]]; then ls
    ${CI_PROJECT_DIR}/configurations/ ; fi
  - if [[ ${COPY_CONFIG}="true" && -f ${CI_PROJECT_DIR}/configurations/${TERRAGRUNT_ENV}.yaml
    ]] ; then cp ${CI_PROJECT_DIR}/configurations/${TERRAGRUNT_ENV}.yaml ${TERRAGRUNT_PROJECT}/${TERRAGRUNT_ENV}.yaml
    ; fi
  - if [[ ${COPY_CONFIG}="true" && -f ${CI_PROJECT_DIR}/configurations/${TERRAGRUNT_ENV}/env.yaml
    ]] ; then cp ${CI_PROJECT_DIR}/configurations/${TERRAGRUNT_ENV}/env.yaml ${TERRAGRUNT_PROJECT}/${TERRAGRUNT_ENV}/env.yaml
    ; fi
  - if [[ ${COPY_CONFIG}="true" && -f ${CI_PROJECT_DIR}/configurations/${TERRAGRUNT_ENV}.${SERVICE_NAME}.yaml
    ]] ; then cp ${CI_PROJECT_DIR}/configurations/${TERRAGRUNT_ENV}.${SERVICE_NAME}.yaml
    ${TERRAGRUNT_PROJECT}/${TERRAGRUNT_ENV}.yaml ; fi
  - cd ${TERRAGRUNT_PROJECT}
  script:
  - echo ${SERVICE_NAME} ${IMAGE_TAG} ${CI_ENVIRONMENT_NAME} TERRAGRUNT_ENV:${TERRAGRUNT_ENV}
  - terragrunt init
  - terragrunt apply --auto-approve --var service_tag=${IMAGE_TAG}
  environment:
    name: "$env"
  variables:
    APP_VERSION: "$IMAGE_TAG"
    JOB: deploy_terragrunt_service_${TERRAGRUNT_ENV}
    TERRAGRUNT_PROJECT: "/builds/terraform/terragrunt/devx/apps/shell-services/${SERVICE_NAME}"
    TERRAFORM_SOURCE: "/builds/terraform/terraform//"
    TERRAGRUNT_BUCKET: fireblocks-terraform-remote-state-${TERRAGRUNT_ENV}
    TERRAGRUNT_LOCK: terraform-state-lock-${TERRAGRUNT_ENV}
    TERRAFORM_REPO_BRANCH: main
    GITLAB_TOKEN: "${ARGOCD_GITLAB_ACCESS_TOKEN}"
    DIFF_FILE: "${CI_PROJECT_DIR}/config_diff.txt"
    AWS_REGION: us-east-2
    TERRAGRUNT_ROLE: arn:aws:iam::414623400063:role/useast2-bnym-dev-sh-k8s-EKSDevRWAccessRole
    TERRAGRUNT_ENV: bnym-dev-shell
    env: bnym-dev
  artifacts:
    paths:
    - "${CI_PROJECT_DIR}/config_diff.txt"
    when: on_failure
  extends: ".deploy_general:after_build"
  tags:
  - bnym-dev
".deploy_bnym-prod-shell:after_build":
  image: registry.gitlab.com/fireblocks/devops/terraform/terraform-runner:v0.5.2
  stage: deploy-dev
  after_script:
  - rm -fr /builds/terraform/
  - echo 'Done!'
  before_script:
  - apt-get update
  - apt-get install -y curl
  - curl -fsSL https://deb.nodesource.com/setup_18.x | bash -
  - apt install -y nodejs
  - npm install -g yarn
  - touch .npmrc
  - npm config set --location=user @fireblocks:registry https://gitlab.com/api/v4/packages/npm/
  - npm config set --location=user '//gitlab.com/api/v4/packages/npm/:_authToken'
    "${NPM_REG_TOKEN}"
  - npm config set --location=user '//gitlab.com/api/v4/projects/20565764/packages/npm/:_authToken'
    "${NPM_REG_TOKEN}"
  - echo "@fireblocks:registry=https://gitlab.com/api/v4/packages/npm/">>.npmrc
  - echo "//gitlab.com/api/v4/packages/npm/:_authToken=${NPM_REG_TOKEN}">>.npmrc
  - echo "//gitlab.com/api/v4/projects/20565764/packages/npm/:_authToken=${NPM_REG_TOKEN}">>.npmrc
  - yarn global add @fireblocks/fb-cli
  - echo "validating configuration diffs in case it's a quick-rollback deployment"
  - cd /builds/
  - rm -fr /builds/terraform/
  - git clone --depth 1 --branch $TERRAFORM_REPO_BRANCH https://gitlab-ci-token:${CI_JOB_TOKEN}@gitlab.com/fireblocks/devops/terraform.git
  - "$(assume-role.sh ${TERRAGRUNT_ROLE} gitlab-runner)"
  - echo ${TERRAGRUNT_PROJECT}
  - echo looking for ${CI_PROJECT_DIR}/configurations/${TERRAGRUNT_ENV}.yaml
  - echo looking for ${CI_PROJECT_DIR}/configurations/${TERRAGRUNT_ENV}.${SERVICE_NAME}.yaml
  - if [[ ${COPY_CONFIG}="true" && -f ${CI_PROJECT_DIR}/configurations/ ]]; then ls
    ${CI_PROJECT_DIR}/configurations/ ; fi
  - if [[ ${COPY_CONFIG}="true" && -f ${CI_PROJECT_DIR}/configurations/${TERRAGRUNT_ENV}.yaml
    ]] ; then cp ${CI_PROJECT_DIR}/configurations/${TERRAGRUNT_ENV}.yaml ${TERRAGRUNT_PROJECT}/${TERRAGRUNT_ENV}.yaml
    ; fi
  - if [[ ${COPY_CONFIG}="true" && -f ${CI_PROJECT_DIR}/configurations/${TERRAGRUNT_ENV}/env.yaml
    ]] ; then cp ${CI_PROJECT_DIR}/configurations/${TERRAGRUNT_ENV}/env.yaml ${TERRAGRUNT_PROJECT}/${TERRAGRUNT_ENV}/env.yaml
    ; fi
  - if [[ ${COPY_CONFIG}="true" && -f ${CI_PROJECT_DIR}/configurations/${TERRAGRUNT_ENV}.${SERVICE_NAME}.yaml
    ]] ; then cp ${CI_PROJECT_DIR}/configurations/${TERRAGRUNT_ENV}.${SERVICE_NAME}.yaml
    ${TERRAGRUNT_PROJECT}/${TERRAGRUNT_ENV}.yaml ; fi
  - cd ${TERRAGRUNT_PROJECT}
  script:
  - echo ${SERVICE_NAME} ${IMAGE_TAG} ${CI_ENVIRONMENT_NAME} TERRAGRUNT_ENV:${TERRAGRUNT_ENV}
  - terragrunt init
  - terragrunt apply --auto-approve --var service_tag=${IMAGE_TAG}
  environment:
    name: "$env"
  variables:
    APP_VERSION: "$IMAGE_TAG"
    JOB: deploy_terragrunt_service_${TERRAGRUNT_ENV}
    TERRAGRUNT_PROJECT: "/builds/terraform/terragrunt/devx/apps/shell-services/${SERVICE_NAME}"
    TERRAFORM_SOURCE: "/builds/terraform/terraform//"
    TERRAGRUNT_BUCKET: fireblocks-terraform-remote-state-${TERRAGRUNT_ENV}
    TERRAGRUNT_LOCK: terraform-state-lock-${TERRAGRUNT_ENV}
    TERRAFORM_REPO_BRANCH: main
    GITLAB_TOKEN: "${ARGOCD_GITLAB_ACCESS_TOKEN}"
    DIFF_FILE: "${CI_PROJECT_DIR}/config_diff.txt"
    AWS_REGION: us-east-2
    TERRAGRUNT_ROLE: arn:aws:iam::296106167418:role/bnym-prod-application-CICD-role
    TERRAGRUNT_ENV: bnym-prod-shell
    env: bnym-prod
  artifacts:
    paths:
    - "${CI_PROJECT_DIR}/config_diff.txt"
    when: on_failure
  extends: ".deploy_general:after_build"
  tags:
  - bnym-prod-application-gitlab-runner
".deploy_eu2-prod-fr:after_build":
  image: registry.gitlab.com/fireblocks/devops/terraform/terraform-runner:v0.5.2
  stage: deploy-dev
  after_script:
  - rm -fr /builds/terraform/
  - echo 'Done!'
  before_script:
  - apt-get update
  - apt-get install -y curl
  - curl -fsSL https://deb.nodesource.com/setup_18.x | bash -
  - apt install -y nodejs
  - npm install -g yarn
  - touch .npmrc
  - npm config set --location=user @fireblocks:registry https://gitlab.com/api/v4/packages/npm/
  - npm config set --location=user '//gitlab.com/api/v4/packages/npm/:_authToken'
    "${NPM_REG_TOKEN}"
  - npm config set --location=user '//gitlab.com/api/v4/projects/20565764/packages/npm/:_authToken'
    "${NPM_REG_TOKEN}"
  - echo "@fireblocks:registry=https://gitlab.com/api/v4/packages/npm/">>.npmrc
  - echo "//gitlab.com/api/v4/packages/npm/:_authToken=${NPM_REG_TOKEN}">>.npmrc
  - echo "//gitlab.com/api/v4/projects/20565764/packages/npm/:_authToken=${NPM_REG_TOKEN}">>.npmrc
  - yarn global add @fireblocks/fb-cli
  - echo "validating configuration diffs in case it's a quick-rollback deployment"
  - cd /builds/
  - rm -fr /builds/terraform/
  - git clone --depth 1 --branch $TERRAFORM_REPO_BRANCH https://gitlab-ci-token:${CI_JOB_TOKEN}@gitlab.com/fireblocks/devops/terraform.git
  - "$(assume-role.sh ${TERRAGRUNT_ROLE} gitlab-runner)"
  - echo ${TERRAGRUNT_PROJECT}
  - echo looking for ${CI_PROJECT_DIR}/configurations/${TERRAGRUNT_ENV}.yaml
  - echo looking for ${CI_PROJECT_DIR}/configurations/${TERRAGRUNT_ENV}.${SERVICE_NAME}.yaml
  - if [[ ${COPY_CONFIG}="true" && -f ${CI_PROJECT_DIR}/configurations/ ]]; then ls
    ${CI_PROJECT_DIR}/configurations/ ; fi
  - if [[ ${COPY_CONFIG}="true" && -f ${CI_PROJECT_DIR}/configurations/${TERRAGRUNT_ENV}.yaml
    ]] ; then cp ${CI_PROJECT_DIR}/configurations/${TERRAGRUNT_ENV}.yaml ${TERRAGRUNT_PROJECT}/${TERRAGRUNT_ENV}.yaml
    ; fi
  - if [[ ${COPY_CONFIG}="true" && -f ${CI_PROJECT_DIR}/configurations/${TERRAGRUNT_ENV}/env.yaml
    ]] ; then cp ${CI_PROJECT_DIR}/configurations/${TERRAGRUNT_ENV}/env.yaml ${TERRAGRUNT_PROJECT}/${TERRAGRUNT_ENV}/env.yaml
    ; fi
  - if [[ ${COPY_CONFIG}="true" && -f ${CI_PROJECT_DIR}/configurations/${TERRAGRUNT_ENV}.${SERVICE_NAME}.yaml
    ]] ; then cp ${CI_PROJECT_DIR}/configurations/${TERRAGRUNT_ENV}.${SERVICE_NAME}.yaml
    ${TERRAGRUNT_PROJECT}/${TERRAGRUNT_ENV}.yaml ; fi
  - cd ${TERRAGRUNT_PROJECT}
  script:
  - echo ${SERVICE_NAME} ${IMAGE_TAG} ${CI_ENVIRONMENT_NAME} TERRAGRUNT_ENV:${TERRAGRUNT_ENV}
  - terragrunt init
  - terragrunt apply --auto-approve --var service_tag=${IMAGE_TAG}
  environment:
    name: "$env"
  variables:
    APP_VERSION: "$IMAGE_TAG"
    JOB: deploy_terragrunt_service_${TERRAGRUNT_ENV}
    TERRAGRUNT_PROJECT: "/builds/terraform/terragrunt/devx/apps/shell-services/${SERVICE_NAME}"
    TERRAFORM_SOURCE: "/builds/terraform/terraform//"
    TERRAGRUNT_BUCKET: fireblocks-terraform-remote-state-${TERRAGRUNT_ENV}
    TERRAGRUNT_LOCK: terraform-state-lock-${TERRAGRUNT_ENV}
    TERRAFORM_REPO_BRANCH: main
    GITLAB_TOKEN: "${ARGOCD_GITLAB_ACCESS_TOKEN}"
    DIFF_FILE: "${CI_PROJECT_DIR}/config_diff.txt"
    AWS_REGION: eu-central-1
    TERRAGRUNT_ROLE: arn:aws:iam::803035224331:role/eu2-prod-fr-shell-EKSDevRWAccessRole
    TERRAGRUNT_ENV: eu2-prod-fr-shell
    env: eu2-prod
  artifacts:
    paths:
    - "${CI_PROJECT_DIR}/config_diff.txt"
    when: on_failure
  extends: ".deploy_general:after_build"
  tags:
  - eu2-prod-fr
".validate-config": |
  yq --version || (echo "please install yq" && exit 1)
  json_list="["
  if [[ -f "${CUSTOM_PARAM_LIST}" ]]; then
    for custom_config in $(cat $CUSTOM_PARAM_LIST | jq -c '.[]'); do
      config_prefix=$(echo $custom_config | jq -r '.prefix' | envsubst)
      config_path=$(echo $custom_config | jq -r '.path' | envsubst)
      if yq -e $config_path; then
        json_list="${json_list}
        {
          \"prefix\": \"${config_prefix}\",
          \"path\": \"${config_path}\"
        },"
      fi
    done
  else
    if [ -f $COMMON_FILE_PATH ]; then
      json_list="${json_list}
      {
        \"prefix\": \"/${ENV_NAME}/${SERVICE_NAME}/common\",
        \"path\": \"${COMMON_FILE_PATH}\"
      },"
    fi
    if yq -e $ENV_FILE_PATH; then
      json_list="${json_list}
      {
        \"prefix\": \"/${ENV_NAME}/${SERVICE_NAME}\",
        \"path\": \"${ENV_FILE_PATH}\"
      },"
    fi
  fi
  json_list="${json_list%?}]"
  export PARAMS_LIST=${json_list}
  echo "PARAMS_LIST: ${PARAMS_LIST}"
".provision-configuration:k8s":
  image: registry.gitlab.com/fireblocks/devops/terraform/terraform-runner:v0.5.4
  retry: 2
  rules:
  - if: $CI_CONFIG_MANAGEMENT_ENABLED == "true"
    when: on_success
  after_script:
  - rm -fr /builds/terraform/
  - echo 'Done!'
  before_script:
  - cd /builds/
  - |
    yq --version || (echo "please install yq" && exit 1)
    json_list="["
    if [[ -f "${CUSTOM_PARAM_LIST}" ]]; then
      for custom_config in $(cat $CUSTOM_PARAM_LIST | jq -c '.[]'); do
        config_prefix=$(echo $custom_config | jq -r '.prefix' | envsubst)
        config_path=$(echo $custom_config | jq -r '.path' | envsubst)
        if yq -e $config_path; then
          json_list="${json_list}
          {
            \"prefix\": \"${config_prefix}\",
            \"path\": \"${config_path}\"
          },"
        fi
      done
    else
      if [ -f $COMMON_FILE_PATH ]; then
        json_list="${json_list}
        {
          \"prefix\": \"/${ENV_NAME}/${SERVICE_NAME}/common\",
          \"path\": \"${COMMON_FILE_PATH}\"
        },"
      fi
      if yq -e $ENV_FILE_PATH; then
        json_list="${json_list}
        {
          \"prefix\": \"/${ENV_NAME}/${SERVICE_NAME}\",
          \"path\": \"${ENV_FILE_PATH}\"
        },"
      fi
    fi
    json_list="${json_list%?}]"
    export PARAMS_LIST=${json_list}
    echo "PARAMS_LIST: ${PARAMS_LIST}"
  - rm -fr /builds/terraform/
  - git clone https://gitlab-ci-token:${CI_JOB_TOKEN}@gitlab.com/fireblocks/devops/terraform.git
  - "$(assume-role.sh ${TERRAGRUNT_ROLE} gitlab-runner)"
  - cd /builds/terraform
  - "$(python3 switch-devx-env.py ${TERRAFORM_ENV_NAME})"
  - echo ${TERRAGRUNT_PROJECT}
  - cd ${TERRAGRUNT_PROJECT}
  script:
  - echo ${SERVICE_NAME} ${IMAGE_TAG} ${CI_ENVIRONMENT_NAME}
  - terragrunt apply --auto-approve --terragrunt-non-interactive --var "parameter_files=${PARAMS_LIST}"
  variables:
    TERRAGRUNT_PROJECT: "/builds/terraform/terragrunt/devx/parameter-store"
    TERRAFORM_ENV_NAME: "${ENV_NAME}"
    COMMON_FILE_PATH: "${CI_PROJECT_DIR}/configurations/common/parameters.yaml"
    ENV_FILE_PATH: "${CI_PROJECT_DIR}/configurations/${ENV_NAME}/parameters.yaml"
    CUSTOM_PARAM_LIST: "${CI_PROJECT_DIR}/configurations/custom-param-configuration.json"
".provision-configuration:legacy":
  image: registry.gitlab.com/fireblocks/devops/terraform/terraform-runner:v0.5.4
  retry: 2
  rules:
  - if: $CI_CONFIG_MANAGEMENT_ENABLED == "true"
    when: always
  tags:
  - dev-common-runner
  after_script:
  - rm -fr /builds/terraform/
  - echo 'Done!'
  before_script:
  - apt install unzip
  - curl "https://awscli.amazonaws.com/awscli-exe-linux-x86_64.zip" -o "awscliv2.zip"
  - unzip -q awscliv2.zip
  - "./aws/install"
  - cd /builds/
  - |
    yq --version || (echo "please install yq" && exit 1)
    json_list="["
    if [[ -f "${CUSTOM_PARAM_LIST}" ]]; then
      for custom_config in $(cat $CUSTOM_PARAM_LIST | jq -c '.[]'); do
        config_prefix=$(echo $custom_config | jq -r '.prefix' | envsubst)
        config_path=$(echo $custom_config | jq -r '.path' | envsubst)
        if yq -e $config_path; then
          json_list="${json_list}
          {
            \"prefix\": \"${config_prefix}\",
            \"path\": \"${config_path}\"
          },"
        fi
      done
    else
      if [ -f $COMMON_FILE_PATH ]; then
        json_list="${json_list}
        {
          \"prefix\": \"/${ENV_NAME}/${SERVICE_NAME}/common\",
          \"path\": \"${COMMON_FILE_PATH}\"
        },"
      fi
      if yq -e $ENV_FILE_PATH; then
        json_list="${json_list}
        {
          \"prefix\": \"/${ENV_NAME}/${SERVICE_NAME}\",
          \"path\": \"${ENV_FILE_PATH}\"
        },"
      fi
    fi
    json_list="${json_list%?}]"
    export PARAMS_LIST=${json_list}
    echo "PARAMS_LIST: ${PARAMS_LIST}"
  - rm -fr /builds/terraform/
  - git clone https://gitlab-ci-token:${CI_JOB_TOKEN}@gitlab.com/fireblocks/devops/terraform.git
  - cd /builds/terraform
  - "$(python3 switch-devx-env.py us-prod-legacy)"
  - echo ${TERRAGRUNT_PROJECT}
  - cd ${TERRAGRUNT_PROJECT}
  script:
  - echo ${SERVICE_NAME} ${IMAGE_TAG} ${CI_ENVIRONMENT_NAME}
  - terragrunt apply --auto-approve --terragrunt-non-interactive --var "parameter_files=${PARAMS_LIST}"
  variables:
    TERRAGRUNT_PROJECT: "/builds/terraform/terragrunt/devx/parameter-store"
    COMMON_FILE_PATH: "${CI_PROJECT_DIR}/configurations/common/parameters.yaml"
    ENV_FILE_PATH: "${CI_PROJECT_DIR}/configurations/${ENV_NAME}/parameters.yaml"
    CUSTOM_PARAM_LIST: "${CI_PROJECT_DIR}/configurations/custom-param-configuration.json"
".config_dev1":
  image: registry.gitlab.com/fireblocks/devops/terraform/terraform-runner:v0.5.4
  retry: 2
  rules:
  - if: $CI_CONFIG_MANAGEMENT_ENABLED == "true"
    when: always
  tags:
  - dev-common-runner
  after_script:
  - rm -fr /builds/terraform/
  - echo 'Done!'
  before_script:
  - apt install unzip
  - curl "https://awscli.amazonaws.com/awscli-exe-linux-x86_64.zip" -o "awscliv2.zip"
  - unzip -q awscliv2.zip
  - "./aws/install"
  - cd /builds/
  - |
    yq --version || (echo "please install yq" && exit 1)
    json_list="["
    if [[ -f "${CUSTOM_PARAM_LIST}" ]]; then
      for custom_config in $(cat $CUSTOM_PARAM_LIST | jq -c '.[]'); do
        config_prefix=$(echo $custom_config | jq -r '.prefix' | envsubst)
        config_path=$(echo $custom_config | jq -r '.path' | envsubst)
        if yq -e $config_path; then
          json_list="${json_list}
          {
            \"prefix\": \"${config_prefix}\",
            \"path\": \"${config_path}\"
          },"
        fi
      done
    else
      if [ -f $COMMON_FILE_PATH ]; then
        json_list="${json_list}
        {
          \"prefix\": \"/${ENV_NAME}/${SERVICE_NAME}/common\",
          \"path\": \"${COMMON_FILE_PATH}\"
        },"
      fi
      if yq -e $ENV_FILE_PATH; then
        json_list="${json_list}
        {
          \"prefix\": \"/${ENV_NAME}/${SERVICE_NAME}\",
          \"path\": \"${ENV_FILE_PATH}\"
        },"
      fi
    fi
    json_list="${json_list%?}]"
    export PARAMS_LIST=${json_list}
    echo "PARAMS_LIST: ${PARAMS_LIST}"
  - rm -fr /builds/terraform/
  - git clone https://gitlab-ci-token:${CI_JOB_TOKEN}@gitlab.com/fireblocks/devops/terraform.git
  - cd /builds/terraform
  - "$(python3 switch-devx-env.py us-prod-legacy)"
  - echo ${TERRAGRUNT_PROJECT}
  - cd ${TERRAGRUNT_PROJECT}
  script:
  - echo ${SERVICE_NAME} ${IMAGE_TAG} ${CI_ENVIRONMENT_NAME}
  - terragrunt apply --auto-approve --terragrunt-non-interactive --var "parameter_files=${PARAMS_LIST}"
  variables:
    TERRAGRUNT_PROJECT: "/builds/terraform/terragrunt/devx/parameter-store"
    COMMON_FILE_PATH: "${CI_PROJECT_DIR}/configurations/common/parameters.yaml"
    ENV_FILE_PATH: "${CI_PROJECT_DIR}/configurations/${ENV_NAME}/parameters.yaml"
    CUSTOM_PARAM_LIST: "${CI_PROJECT_DIR}/configurations/custom-param-configuration.json"
    AWS_REGION: us-east-2
    ENV_NAME: dev1
  extends: ".provision-configuration:legacy"
".config_dev1_k8s":
  image: registry.gitlab.com/fireblocks/devops/terraform/terraform-runner:v0.5.4
  retry: 2
  rules:
  - if: $CI_CONFIG_MANAGEMENT_ENABLED == "true"
    when: on_success
  after_script:
  - rm -fr /builds/terraform/
  - echo 'Done!'
  before_script:
  - cd /builds/
  - |
    yq --version || (echo "please install yq" && exit 1)
    json_list="["
    if [[ -f "${CUSTOM_PARAM_LIST}" ]]; then
      for custom_config in $(cat $CUSTOM_PARAM_LIST | jq -c '.[]'); do
        config_prefix=$(echo $custom_config | jq -r '.prefix' | envsubst)
        config_path=$(echo $custom_config | jq -r '.path' | envsubst)
        if yq -e $config_path; then
          json_list="${json_list}
          {
            \"prefix\": \"${config_prefix}\",
            \"path\": \"${config_path}\"
          },"
        fi
      done
    else
      if [ -f $COMMON_FILE_PATH ]; then
        json_list="${json_list}
        {
          \"prefix\": \"/${ENV_NAME}/${SERVICE_NAME}/common\",
          \"path\": \"${COMMON_FILE_PATH}\"
        },"
      fi
      if yq -e $ENV_FILE_PATH; then
        json_list="${json_list}
        {
          \"prefix\": \"/${ENV_NAME}/${SERVICE_NAME}\",
          \"path\": \"${ENV_FILE_PATH}\"
        },"
      fi
    fi
    json_list="${json_list%?}]"
    export PARAMS_LIST=${json_list}
    echo "PARAMS_LIST: ${PARAMS_LIST}"
  - rm -fr /builds/terraform/
  - git clone https://gitlab-ci-token:${CI_JOB_TOKEN}@gitlab.com/fireblocks/devops/terraform.git
  - "$(assume-role.sh ${TERRAGRUNT_ROLE} gitlab-runner)"
  - cd /builds/terraform
  - "$(python3 switch-devx-env.py ${TERRAFORM_ENV_NAME})"
  - echo ${TERRAGRUNT_PROJECT}
  - cd ${TERRAGRUNT_PROJECT}
  script:
  - echo ${SERVICE_NAME} ${IMAGE_TAG} ${CI_ENVIRONMENT_NAME}
  - terragrunt apply --auto-approve --terragrunt-non-interactive --var "parameter_files=${PARAMS_LIST}"
  variables:
    TERRAGRUNT_PROJECT: "/builds/terraform/terragrunt/devx/parameter-store"
    TERRAFORM_ENV_NAME: "${ENV_NAME}"
    COMMON_FILE_PATH: "${CI_PROJECT_DIR}/configurations/common/parameters.yaml"
    ENV_FILE_PATH: "${CI_PROJECT_DIR}/configurations/${ENV_NAME}/parameters.yaml"
    CUSTOM_PARAM_LIST: "${CI_PROJECT_DIR}/configurations/custom-param-configuration.json"
    AWS_REGION: us-east-2
    TERRAGRUNT_ROLE: arn:aws:iam::318128524537:role/gitlab-runner-parameter-store-role
    ENV_NAME: dev1
  extends: ".provision-configuration:k8s"
  tags:
  - shared-devx
  stage: configure
".config_dev2":
  image: registry.gitlab.com/fireblocks/devops/terraform/terraform-runner:v0.5.4
  retry: 2
  rules:
  - if: $CI_CONFIG_MANAGEMENT_ENABLED == "true"
    when: always
  tags:
  - dev-common-runner
  after_script:
  - rm -fr /builds/terraform/
  - echo 'Done!'
  before_script:
  - apt install unzip
  - curl "https://awscli.amazonaws.com/awscli-exe-linux-x86_64.zip" -o "awscliv2.zip"
  - unzip -q awscliv2.zip
  - "./aws/install"
  - cd /builds/
  - |
    yq --version || (echo "please install yq" && exit 1)
    json_list="["
    if [[ -f "${CUSTOM_PARAM_LIST}" ]]; then
      for custom_config in $(cat $CUSTOM_PARAM_LIST | jq -c '.[]'); do
        config_prefix=$(echo $custom_config | jq -r '.prefix' | envsubst)
        config_path=$(echo $custom_config | jq -r '.path' | envsubst)
        if yq -e $config_path; then
          json_list="${json_list}
          {
            \"prefix\": \"${config_prefix}\",
            \"path\": \"${config_path}\"
          },"
        fi
      done
    else
      if [ -f $COMMON_FILE_PATH ]; then
        json_list="${json_list}
        {
          \"prefix\": \"/${ENV_NAME}/${SERVICE_NAME}/common\",
          \"path\": \"${COMMON_FILE_PATH}\"
        },"
      fi
      if yq -e $ENV_FILE_PATH; then
        json_list="${json_list}
        {
          \"prefix\": \"/${ENV_NAME}/${SERVICE_NAME}\",
          \"path\": \"${ENV_FILE_PATH}\"
        },"
      fi
    fi
    json_list="${json_list%?}]"
    export PARAMS_LIST=${json_list}
    echo "PARAMS_LIST: ${PARAMS_LIST}"
  - rm -fr /builds/terraform/
  - git clone https://gitlab-ci-token:${CI_JOB_TOKEN}@gitlab.com/fireblocks/devops/terraform.git
  - cd /builds/terraform
  - "$(python3 switch-devx-env.py us-prod-legacy)"
  - echo ${TERRAGRUNT_PROJECT}
  - cd ${TERRAGRUNT_PROJECT}
  script:
  - echo ${SERVICE_NAME} ${IMAGE_TAG} ${CI_ENVIRONMENT_NAME}
  - terragrunt apply --auto-approve --terragrunt-non-interactive --var "parameter_files=${PARAMS_LIST}"
  variables:
    TERRAGRUNT_PROJECT: "/builds/terraform/terragrunt/devx/parameter-store"
    COMMON_FILE_PATH: "${CI_PROJECT_DIR}/configurations/common/parameters.yaml"
    ENV_FILE_PATH: "${CI_PROJECT_DIR}/configurations/${ENV_NAME}/parameters.yaml"
    CUSTOM_PARAM_LIST: "${CI_PROJECT_DIR}/configurations/custom-param-configuration.json"
    AWS_REGION: us-east-2
    ENV_NAME: dev2
  extends: ".provision-configuration:legacy"
".config_dev2_k8s":
  image: registry.gitlab.com/fireblocks/devops/terraform/terraform-runner:v0.5.4
  retry: 2
  rules:
  - if: $CI_CONFIG_MANAGEMENT_ENABLED == "true"
    when: on_success
  after_script:
  - rm -fr /builds/terraform/
  - echo 'Done!'
  before_script:
  - cd /builds/
  - |
    yq --version || (echo "please install yq" && exit 1)
    json_list="["
    if [[ -f "${CUSTOM_PARAM_LIST}" ]]; then
      for custom_config in $(cat $CUSTOM_PARAM_LIST | jq -c '.[]'); do
        config_prefix=$(echo $custom_config | jq -r '.prefix' | envsubst)
        config_path=$(echo $custom_config | jq -r '.path' | envsubst)
        if yq -e $config_path; then
          json_list="${json_list}
          {
            \"prefix\": \"${config_prefix}\",
            \"path\": \"${config_path}\"
          },"
        fi
      done
    else
      if [ -f $COMMON_FILE_PATH ]; then
        json_list="${json_list}
        {
          \"prefix\": \"/${ENV_NAME}/${SERVICE_NAME}/common\",
          \"path\": \"${COMMON_FILE_PATH}\"
        },"
      fi
      if yq -e $ENV_FILE_PATH; then
        json_list="${json_list}
        {
          \"prefix\": \"/${ENV_NAME}/${SERVICE_NAME}\",
          \"path\": \"${ENV_FILE_PATH}\"
        },"
      fi
    fi
    json_list="${json_list%?}]"
    export PARAMS_LIST=${json_list}
    echo "PARAMS_LIST: ${PARAMS_LIST}"
  - rm -fr /builds/terraform/
  - git clone https://gitlab-ci-token:${CI_JOB_TOKEN}@gitlab.com/fireblocks/devops/terraform.git
  - "$(assume-role.sh ${TERRAGRUNT_ROLE} gitlab-runner)"
  - cd /builds/terraform
  - "$(python3 switch-devx-env.py ${TERRAFORM_ENV_NAME})"
  - echo ${TERRAGRUNT_PROJECT}
  - cd ${TERRAGRUNT_PROJECT}
  script:
  - echo ${SERVICE_NAME} ${IMAGE_TAG} ${CI_ENVIRONMENT_NAME}
  - terragrunt apply --auto-approve --terragrunt-non-interactive --var "parameter_files=${PARAMS_LIST}"
  variables:
    TERRAGRUNT_PROJECT: "/builds/terraform/terragrunt/devx/parameter-store"
    TERRAFORM_ENV_NAME: "${ENV_NAME}"
    COMMON_FILE_PATH: "${CI_PROJECT_DIR}/configurations/common/parameters.yaml"
    ENV_FILE_PATH: "${CI_PROJECT_DIR}/configurations/${ENV_NAME}/parameters.yaml"
    CUSTOM_PARAM_LIST: "${CI_PROJECT_DIR}/configurations/custom-param-configuration.json"
    AWS_REGION: us-east-2
    TERRAGRUNT_ROLE: arn:aws:iam::318128524537:role/gitlab-runner-parameter-store-role
    ENV_NAME: dev2
  extends: ".provision-configuration:k8s"
  tags:
  - shared-devx
  stage: configure
".config_dev3":
  image: registry.gitlab.com/fireblocks/devops/terraform/terraform-runner:v0.5.4
  retry: 2
  rules:
  - if: $CI_CONFIG_MANAGEMENT_ENABLED == "true"
    when: always
  tags:
  - dev-common-runner
  after_script:
  - rm -fr /builds/terraform/
  - echo 'Done!'
  before_script:
  - apt install unzip
  - curl "https://awscli.amazonaws.com/awscli-exe-linux-x86_64.zip" -o "awscliv2.zip"
  - unzip -q awscliv2.zip
  - "./aws/install"
  - cd /builds/
  - |
    yq --version || (echo "please install yq" && exit 1)
    json_list="["
    if [[ -f "${CUSTOM_PARAM_LIST}" ]]; then
      for custom_config in $(cat $CUSTOM_PARAM_LIST | jq -c '.[]'); do
        config_prefix=$(echo $custom_config | jq -r '.prefix' | envsubst)
        config_path=$(echo $custom_config | jq -r '.path' | envsubst)
        if yq -e $config_path; then
          json_list="${json_list}
          {
            \"prefix\": \"${config_prefix}\",
            \"path\": \"${config_path}\"
          },"
        fi
      done
    else
      if [ -f $COMMON_FILE_PATH ]; then
        json_list="${json_list}
        {
          \"prefix\": \"/${ENV_NAME}/${SERVICE_NAME}/common\",
          \"path\": \"${COMMON_FILE_PATH}\"
        },"
      fi
      if yq -e $ENV_FILE_PATH; then
        json_list="${json_list}
        {
          \"prefix\": \"/${ENV_NAME}/${SERVICE_NAME}\",
          \"path\": \"${ENV_FILE_PATH}\"
        },"
      fi
    fi
    json_list="${json_list%?}]"
    export PARAMS_LIST=${json_list}
    echo "PARAMS_LIST: ${PARAMS_LIST}"
  - rm -fr /builds/terraform/
  - git clone https://gitlab-ci-token:${CI_JOB_TOKEN}@gitlab.com/fireblocks/devops/terraform.git
  - cd /builds/terraform
  - "$(python3 switch-devx-env.py us-prod-legacy)"
  - echo ${TERRAGRUNT_PROJECT}
  - cd ${TERRAGRUNT_PROJECT}
  script:
  - echo ${SERVICE_NAME} ${IMAGE_TAG} ${CI_ENVIRONMENT_NAME}
  - terragrunt apply --auto-approve --terragrunt-non-interactive --var "parameter_files=${PARAMS_LIST}"
  variables:
    TERRAGRUNT_PROJECT: "/builds/terraform/terragrunt/devx/parameter-store"
    COMMON_FILE_PATH: "${CI_PROJECT_DIR}/configurations/common/parameters.yaml"
    ENV_FILE_PATH: "${CI_PROJECT_DIR}/configurations/${ENV_NAME}/parameters.yaml"
    CUSTOM_PARAM_LIST: "${CI_PROJECT_DIR}/configurations/custom-param-configuration.json"
    AWS_REGION: us-east-2
    ENV_NAME: dev3
  extends: ".provision-configuration:legacy"
".config_dev3_k8s":
  image: registry.gitlab.com/fireblocks/devops/terraform/terraform-runner:v0.5.4
  retry: 2
  rules:
  - if: $CI_CONFIG_MANAGEMENT_ENABLED == "true"
    when: on_success
  after_script:
  - rm -fr /builds/terraform/
  - echo 'Done!'
  before_script:
  - cd /builds/
  - |
    yq --version || (echo "please install yq" && exit 1)
    json_list="["
    if [[ -f "${CUSTOM_PARAM_LIST}" ]]; then
      for custom_config in $(cat $CUSTOM_PARAM_LIST | jq -c '.[]'); do
        config_prefix=$(echo $custom_config | jq -r '.prefix' | envsubst)
        config_path=$(echo $custom_config | jq -r '.path' | envsubst)
        if yq -e $config_path; then
          json_list="${json_list}
          {
            \"prefix\": \"${config_prefix}\",
            \"path\": \"${config_path}\"
          },"
        fi
      done
    else
      if [ -f $COMMON_FILE_PATH ]; then
        json_list="${json_list}
        {
          \"prefix\": \"/${ENV_NAME}/${SERVICE_NAME}/common\",
          \"path\": \"${COMMON_FILE_PATH}\"
        },"
      fi
      if yq -e $ENV_FILE_PATH; then
        json_list="${json_list}
        {
          \"prefix\": \"/${ENV_NAME}/${SERVICE_NAME}\",
          \"path\": \"${ENV_FILE_PATH}\"
        },"
      fi
    fi
    json_list="${json_list%?}]"
    export PARAMS_LIST=${json_list}
    echo "PARAMS_LIST: ${PARAMS_LIST}"
  - rm -fr /builds/terraform/
  - git clone https://gitlab-ci-token:${CI_JOB_TOKEN}@gitlab.com/fireblocks/devops/terraform.git
  - "$(assume-role.sh ${TERRAGRUNT_ROLE} gitlab-runner)"
  - cd /builds/terraform
  - "$(python3 switch-devx-env.py ${TERRAFORM_ENV_NAME})"
  - echo ${TERRAGRUNT_PROJECT}
  - cd ${TERRAGRUNT_PROJECT}
  script:
  - echo ${SERVICE_NAME} ${IMAGE_TAG} ${CI_ENVIRONMENT_NAME}
  - terragrunt apply --auto-approve --terragrunt-non-interactive --var "parameter_files=${PARAMS_LIST}"
  variables:
    TERRAGRUNT_PROJECT: "/builds/terraform/terragrunt/devx/parameter-store"
    TERRAFORM_ENV_NAME: "${ENV_NAME}"
    COMMON_FILE_PATH: "${CI_PROJECT_DIR}/configurations/common/parameters.yaml"
    ENV_FILE_PATH: "${CI_PROJECT_DIR}/configurations/${ENV_NAME}/parameters.yaml"
    CUSTOM_PARAM_LIST: "${CI_PROJECT_DIR}/configurations/custom-param-configuration.json"
    AWS_REGION: us-east-2
    TERRAGRUNT_ROLE: arn:aws:iam::318128524537:role/gitlab-runner-parameter-store-role
    ENV_NAME: dev3
  extends: ".provision-configuration:k8s"
  tags:
  - shared-devx
  stage: configure
".config_dev4":
  image: registry.gitlab.com/fireblocks/devops/terraform/terraform-runner:v0.5.4
  retry: 2
  rules:
  - if: $CI_CONFIG_MANAGEMENT_ENABLED == "true"
    when: always
  tags:
  - dev-common-runner
  after_script:
  - rm -fr /builds/terraform/
  - echo 'Done!'
  before_script:
  - apt install unzip
  - curl "https://awscli.amazonaws.com/awscli-exe-linux-x86_64.zip" -o "awscliv2.zip"
  - unzip -q awscliv2.zip
  - "./aws/install"
  - cd /builds/
  - |
    yq --version || (echo "please install yq" && exit 1)
    json_list="["
    if [[ -f "${CUSTOM_PARAM_LIST}" ]]; then
      for custom_config in $(cat $CUSTOM_PARAM_LIST | jq -c '.[]'); do
        config_prefix=$(echo $custom_config | jq -r '.prefix' | envsubst)
        config_path=$(echo $custom_config | jq -r '.path' | envsubst)
        if yq -e $config_path; then
          json_list="${json_list}
          {
            \"prefix\": \"${config_prefix}\",
            \"path\": \"${config_path}\"
          },"
        fi
      done
    else
      if [ -f $COMMON_FILE_PATH ]; then
        json_list="${json_list}
        {
          \"prefix\": \"/${ENV_NAME}/${SERVICE_NAME}/common\",
          \"path\": \"${COMMON_FILE_PATH}\"
        },"
      fi
      if yq -e $ENV_FILE_PATH; then
        json_list="${json_list}
        {
          \"prefix\": \"/${ENV_NAME}/${SERVICE_NAME}\",
          \"path\": \"${ENV_FILE_PATH}\"
        },"
      fi
    fi
    json_list="${json_list%?}]"
    export PARAMS_LIST=${json_list}
    echo "PARAMS_LIST: ${PARAMS_LIST}"
  - rm -fr /builds/terraform/
  - git clone https://gitlab-ci-token:${CI_JOB_TOKEN}@gitlab.com/fireblocks/devops/terraform.git
  - cd /builds/terraform
  - "$(python3 switch-devx-env.py us-prod-legacy)"
  - echo ${TERRAGRUNT_PROJECT}
  - cd ${TERRAGRUNT_PROJECT}
  script:
  - echo ${SERVICE_NAME} ${IMAGE_TAG} ${CI_ENVIRONMENT_NAME}
  - terragrunt apply --auto-approve --terragrunt-non-interactive --var "parameter_files=${PARAMS_LIST}"
  variables:
    TERRAGRUNT_PROJECT: "/builds/terraform/terragrunt/devx/parameter-store"
    COMMON_FILE_PATH: "${CI_PROJECT_DIR}/configurations/common/parameters.yaml"
    ENV_FILE_PATH: "${CI_PROJECT_DIR}/configurations/${ENV_NAME}/parameters.yaml"
    CUSTOM_PARAM_LIST: "${CI_PROJECT_DIR}/configurations/custom-param-configuration.json"
    AWS_REGION: us-east-2
    ENV_NAME: dev4
  extends: ".provision-configuration:legacy"
".config_dev4_k8s":
  image: registry.gitlab.com/fireblocks/devops/terraform/terraform-runner:v0.5.4
  retry: 2
  rules:
  - if: $CI_CONFIG_MANAGEMENT_ENABLED == "true"
    when: on_success
  after_script:
  - rm -fr /builds/terraform/
  - echo 'Done!'
  before_script:
  - cd /builds/
  - |
    yq --version || (echo "please install yq" && exit 1)
    json_list="["
    if [[ -f "${CUSTOM_PARAM_LIST}" ]]; then
      for custom_config in $(cat $CUSTOM_PARAM_LIST | jq -c '.[]'); do
        config_prefix=$(echo $custom_config | jq -r '.prefix' | envsubst)
        config_path=$(echo $custom_config | jq -r '.path' | envsubst)
        if yq -e $config_path; then
          json_list="${json_list}
          {
            \"prefix\": \"${config_prefix}\",
            \"path\": \"${config_path}\"
          },"
        fi
      done
    else
      if [ -f $COMMON_FILE_PATH ]; then
        json_list="${json_list}
        {
          \"prefix\": \"/${ENV_NAME}/${SERVICE_NAME}/common\",
          \"path\": \"${COMMON_FILE_PATH}\"
        },"
      fi
      if yq -e $ENV_FILE_PATH; then
        json_list="${json_list}
        {
          \"prefix\": \"/${ENV_NAME}/${SERVICE_NAME}\",
          \"path\": \"${ENV_FILE_PATH}\"
        },"
      fi
    fi
    json_list="${json_list%?}]"
    export PARAMS_LIST=${json_list}
    echo "PARAMS_LIST: ${PARAMS_LIST}"
  - rm -fr /builds/terraform/
  - git clone https://gitlab-ci-token:${CI_JOB_TOKEN}@gitlab.com/fireblocks/devops/terraform.git
  - "$(assume-role.sh ${TERRAGRUNT_ROLE} gitlab-runner)"
  - cd /builds/terraform
  - "$(python3 switch-devx-env.py ${TERRAFORM_ENV_NAME})"
  - echo ${TERRAGRUNT_PROJECT}
  - cd ${TERRAGRUNT_PROJECT}
  script:
  - echo ${SERVICE_NAME} ${IMAGE_TAG} ${CI_ENVIRONMENT_NAME}
  - terragrunt apply --auto-approve --terragrunt-non-interactive --var "parameter_files=${PARAMS_LIST}"
  variables:
    TERRAGRUNT_PROJECT: "/builds/terraform/terragrunt/devx/parameter-store"
    TERRAFORM_ENV_NAME: "${ENV_NAME}"
    COMMON_FILE_PATH: "${CI_PROJECT_DIR}/configurations/common/parameters.yaml"
    ENV_FILE_PATH: "${CI_PROJECT_DIR}/configurations/${ENV_NAME}/parameters.yaml"
    CUSTOM_PARAM_LIST: "${CI_PROJECT_DIR}/configurations/custom-param-configuration.json"
    AWS_REGION: us-east-2
    TERRAGRUNT_ROLE: arn:aws:iam::318128524537:role/gitlab-runner-parameter-store-role
    ENV_NAME: dev4
  extends: ".provision-configuration:k8s"
  tags:
  - shared-devx
  stage: configure
".config_stage":
  image: registry.gitlab.com/fireblocks/devops/terraform/terraform-runner:v0.5.4
  retry: 2
  rules:
  - if: $CI_CONFIG_MANAGEMENT_ENABLED == "true"
    when: always
  tags:
  - dev-common-runner
  after_script:
  - rm -fr /builds/terraform/
  - echo 'Done!'
  before_script:
  - apt install unzip
  - curl "https://awscli.amazonaws.com/awscli-exe-linux-x86_64.zip" -o "awscliv2.zip"
  - unzip -q awscliv2.zip
  - "./aws/install"
  - cd /builds/
  - |
    yq --version || (echo "please install yq" && exit 1)
    json_list="["
    if [[ -f "${CUSTOM_PARAM_LIST}" ]]; then
      for custom_config in $(cat $CUSTOM_PARAM_LIST | jq -c '.[]'); do
        config_prefix=$(echo $custom_config | jq -r '.prefix' | envsubst)
        config_path=$(echo $custom_config | jq -r '.path' | envsubst)
        if yq -e $config_path; then
          json_list="${json_list}
          {
            \"prefix\": \"${config_prefix}\",
            \"path\": \"${config_path}\"
          },"
        fi
      done
    else
      if [ -f $COMMON_FILE_PATH ]; then
        json_list="${json_list}
        {
          \"prefix\": \"/${ENV_NAME}/${SERVICE_NAME}/common\",
          \"path\": \"${COMMON_FILE_PATH}\"
        },"
      fi
      if yq -e $ENV_FILE_PATH; then
        json_list="${json_list}
        {
          \"prefix\": \"/${ENV_NAME}/${SERVICE_NAME}\",
          \"path\": \"${ENV_FILE_PATH}\"
        },"
      fi
    fi
    json_list="${json_list%?}]"
    export PARAMS_LIST=${json_list}
    echo "PARAMS_LIST: ${PARAMS_LIST}"
  - rm -fr /builds/terraform/
  - git clone https://gitlab-ci-token:${CI_JOB_TOKEN}@gitlab.com/fireblocks/devops/terraform.git
  - cd /builds/terraform
  - "$(python3 switch-devx-env.py us-prod-legacy)"
  - echo ${TERRAGRUNT_PROJECT}
  - cd ${TERRAGRUNT_PROJECT}
  script:
  - echo ${SERVICE_NAME} ${IMAGE_TAG} ${CI_ENVIRONMENT_NAME}
  - terragrunt apply --auto-approve --terragrunt-non-interactive --var "parameter_files=${PARAMS_LIST}"
  variables:
    TERRAGRUNT_PROJECT: "/builds/terraform/terragrunt/devx/parameter-store"
    COMMON_FILE_PATH: "${CI_PROJECT_DIR}/configurations/common/parameters.yaml"
    ENV_FILE_PATH: "${CI_PROJECT_DIR}/configurations/${ENV_NAME}/parameters.yaml"
    CUSTOM_PARAM_LIST: "${CI_PROJECT_DIR}/configurations/custom-param-configuration.json"
    AWS_REGION: us-east-2
    ENV_NAME: stage
  extends: ".provision-configuration:legacy"
".config_stage_k8s":
  image: registry.gitlab.com/fireblocks/devops/terraform/terraform-runner:v0.5.4
  retry: 2
  rules:
  - if: $CI_CONFIG_MANAGEMENT_ENABLED == "true"
    when: on_success
  after_script:
  - rm -fr /builds/terraform/
  - echo 'Done!'
  before_script:
  - cd /builds/
  - |
    yq --version || (echo "please install yq" && exit 1)
    json_list="["
    if [[ -f "${CUSTOM_PARAM_LIST}" ]]; then
      for custom_config in $(cat $CUSTOM_PARAM_LIST | jq -c '.[]'); do
        config_prefix=$(echo $custom_config | jq -r '.prefix' | envsubst)
        config_path=$(echo $custom_config | jq -r '.path' | envsubst)
        if yq -e $config_path; then
          json_list="${json_list}
          {
            \"prefix\": \"${config_prefix}\",
            \"path\": \"${config_path}\"
          },"
        fi
      done
    else
      if [ -f $COMMON_FILE_PATH ]; then
        json_list="${json_list}
        {
          \"prefix\": \"/${ENV_NAME}/${SERVICE_NAME}/common\",
          \"path\": \"${COMMON_FILE_PATH}\"
        },"
      fi
      if yq -e $ENV_FILE_PATH; then
        json_list="${json_list}
        {
          \"prefix\": \"/${ENV_NAME}/${SERVICE_NAME}\",
          \"path\": \"${ENV_FILE_PATH}\"
        },"
      fi
    fi
    json_list="${json_list%?}]"
    export PARAMS_LIST=${json_list}
    echo "PARAMS_LIST: ${PARAMS_LIST}"
  - rm -fr /builds/terraform/
  - git clone https://gitlab-ci-token:${CI_JOB_TOKEN}@gitlab.com/fireblocks/devops/terraform.git
  - "$(assume-role.sh ${TERRAGRUNT_ROLE} gitlab-runner)"
  - cd /builds/terraform
  - "$(python3 switch-devx-env.py ${TERRAFORM_ENV_NAME})"
  - echo ${TERRAGRUNT_PROJECT}
  - cd ${TERRAGRUNT_PROJECT}
  script:
  - echo ${SERVICE_NAME} ${IMAGE_TAG} ${CI_ENVIRONMENT_NAME}
  - terragrunt apply --auto-approve --terragrunt-non-interactive --var "parameter_files=${PARAMS_LIST}"
  variables:
    TERRAGRUNT_PROJECT: "/builds/terraform/terragrunt/devx/parameter-store"
    TERRAFORM_ENV_NAME: "${ENV_NAME}"
    COMMON_FILE_PATH: "${CI_PROJECT_DIR}/configurations/common/parameters.yaml"
    ENV_FILE_PATH: "${CI_PROJECT_DIR}/configurations/${ENV_NAME}/parameters.yaml"
    CUSTOM_PARAM_LIST: "${CI_PROJECT_DIR}/configurations/custom-param-configuration.json"
    AWS_REGION: us-east-2
    ENV_NAME: stage
    TERRAGRUNT_ROLE: arn:aws:iam::508935315618:role/gitlab-runner-parameter-store-role
  extends: ".provision-configuration:k8s"
  tags:
  - shared-stage
".config_pre1":
  image: registry.gitlab.com/fireblocks/devops/terraform/terraform-runner:v0.5.4
  retry: 2
  rules:
  - if: $CI_CONFIG_MANAGEMENT_ENABLED == "true"
    when: always
  tags:
  - dev-common-runner
  after_script:
  - rm -fr /builds/terraform/
  - echo 'Done!'
  before_script:
  - apt install unzip
  - curl "https://awscli.amazonaws.com/awscli-exe-linux-x86_64.zip" -o "awscliv2.zip"
  - unzip -q awscliv2.zip
  - "./aws/install"
  - cd /builds/
  - |
    yq --version || (echo "please install yq" && exit 1)
    json_list="["
    if [[ -f "${CUSTOM_PARAM_LIST}" ]]; then
      for custom_config in $(cat $CUSTOM_PARAM_LIST | jq -c '.[]'); do
        config_prefix=$(echo $custom_config | jq -r '.prefix' | envsubst)
        config_path=$(echo $custom_config | jq -r '.path' | envsubst)
        if yq -e $config_path; then
          json_list="${json_list}
          {
            \"prefix\": \"${config_prefix}\",
            \"path\": \"${config_path}\"
          },"
        fi
      done
    else
      if [ -f $COMMON_FILE_PATH ]; then
        json_list="${json_list}
        {
          \"prefix\": \"/${ENV_NAME}/${SERVICE_NAME}/common\",
          \"path\": \"${COMMON_FILE_PATH}\"
        },"
      fi
      if yq -e $ENV_FILE_PATH; then
        json_list="${json_list}
        {
          \"prefix\": \"/${ENV_NAME}/${SERVICE_NAME}\",
          \"path\": \"${ENV_FILE_PATH}\"
        },"
      fi
    fi
    json_list="${json_list%?}]"
    export PARAMS_LIST=${json_list}
    echo "PARAMS_LIST: ${PARAMS_LIST}"
  - rm -fr /builds/terraform/
  - git clone https://gitlab-ci-token:${CI_JOB_TOKEN}@gitlab.com/fireblocks/devops/terraform.git
  - cd /builds/terraform
  - "$(python3 switch-devx-env.py us-prod-legacy)"
  - echo ${TERRAGRUNT_PROJECT}
  - cd ${TERRAGRUNT_PROJECT}
  script:
  - echo ${SERVICE_NAME} ${IMAGE_TAG} ${CI_ENVIRONMENT_NAME}
  - terragrunt apply --auto-approve --terragrunt-non-interactive --var "parameter_files=${PARAMS_LIST}"
  variables:
    TERRAGRUNT_PROJECT: "/builds/terraform/terragrunt/devx/parameter-store"
    COMMON_FILE_PATH: "${CI_PROJECT_DIR}/configurations/common/parameters.yaml"
    ENV_FILE_PATH: "${CI_PROJECT_DIR}/configurations/${ENV_NAME}/parameters.yaml"
    CUSTOM_PARAM_LIST: "${CI_PROJECT_DIR}/configurations/custom-param-configuration.json"
    AWS_REGION: us-east-2
    ENV_NAME: pre1
  extends: ".provision-configuration:legacy"
".config_pre1_k8s":
  image: registry.gitlab.com/fireblocks/devops/terraform/terraform-runner:v0.5.4
  retry: 2
  rules:
  - if: $CI_CONFIG_MANAGEMENT_ENABLED == "true"
    when: on_success
  after_script:
  - rm -fr /builds/terraform/
  - echo 'Done!'
  before_script:
  - cd /builds/
  - |
    yq --version || (echo "please install yq" && exit 1)
    json_list="["
    if [[ -f "${CUSTOM_PARAM_LIST}" ]]; then
      for custom_config in $(cat $CUSTOM_PARAM_LIST | jq -c '.[]'); do
        config_prefix=$(echo $custom_config | jq -r '.prefix' | envsubst)
        config_path=$(echo $custom_config | jq -r '.path' | envsubst)
        if yq -e $config_path; then
          json_list="${json_list}
          {
            \"prefix\": \"${config_prefix}\",
            \"path\": \"${config_path}\"
          },"
        fi
      done
    else
      if [ -f $COMMON_FILE_PATH ]; then
        json_list="${json_list}
        {
          \"prefix\": \"/${ENV_NAME}/${SERVICE_NAME}/common\",
          \"path\": \"${COMMON_FILE_PATH}\"
        },"
      fi
      if yq -e $ENV_FILE_PATH; then
        json_list="${json_list}
        {
          \"prefix\": \"/${ENV_NAME}/${SERVICE_NAME}\",
          \"path\": \"${ENV_FILE_PATH}\"
        },"
      fi
    fi
    json_list="${json_list%?}]"
    export PARAMS_LIST=${json_list}
    echo "PARAMS_LIST: ${PARAMS_LIST}"
  - rm -fr /builds/terraform/
  - git clone https://gitlab-ci-token:${CI_JOB_TOKEN}@gitlab.com/fireblocks/devops/terraform.git
  - "$(assume-role.sh ${TERRAGRUNT_ROLE} gitlab-runner)"
  - cd /builds/terraform
  - "$(python3 switch-devx-env.py ${TERRAFORM_ENV_NAME})"
  - echo ${TERRAGRUNT_PROJECT}
  - cd ${TERRAGRUNT_PROJECT}
  script:
  - echo ${SERVICE_NAME} ${IMAGE_TAG} ${CI_ENVIRONMENT_NAME}
  - terragrunt apply --auto-approve --terragrunt-non-interactive --var "parameter_files=${PARAMS_LIST}"
  variables:
    TERRAGRUNT_PROJECT: "/builds/terraform/terragrunt/devx/parameter-store"
    TERRAFORM_ENV_NAME: "${ENV_NAME}"
    COMMON_FILE_PATH: "${CI_PROJECT_DIR}/configurations/common/parameters.yaml"
    ENV_FILE_PATH: "${CI_PROJECT_DIR}/configurations/${ENV_NAME}/parameters.yaml"
    CUSTOM_PARAM_LIST: "${CI_PROJECT_DIR}/configurations/custom-param-configuration.json"
    AWS_REGION: us-east-2
    ENV_NAME: pre1
    TERRAGRUNT_ROLE: arn:aws:iam::579897745075:role/gitlab-runner-parameter-store-role
  extends: ".provision-configuration:k8s"
  tags:
  - shared-pre1
".config_dev5":
  image: registry.gitlab.com/fireblocks/devops/terraform/terraform-runner:v0.5.4
  retry: 2
  rules:
  - if: $CI_CONFIG_MANAGEMENT_ENABLED == "true"
    when: on_success
  after_script:
  - rm -fr /builds/terraform/
  - echo 'Done!'
  before_script:
  - cd /builds/
  - |
    yq --version || (echo "please install yq" && exit 1)
    json_list="["
    if [[ -f "${CUSTOM_PARAM_LIST}" ]]; then
      for custom_config in $(cat $CUSTOM_PARAM_LIST | jq -c '.[]'); do
        config_prefix=$(echo $custom_config | jq -r '.prefix' | envsubst)
        config_path=$(echo $custom_config | jq -r '.path' | envsubst)
        if yq -e $config_path; then
          json_list="${json_list}
          {
            \"prefix\": \"${config_prefix}\",
            \"path\": \"${config_path}\"
          },"
        fi
      done
    else
      if [ -f $COMMON_FILE_PATH ]; then
        json_list="${json_list}
        {
          \"prefix\": \"/${ENV_NAME}/${SERVICE_NAME}/common\",
          \"path\": \"${COMMON_FILE_PATH}\"
        },"
      fi
      if yq -e $ENV_FILE_PATH; then
        json_list="${json_list}
        {
          \"prefix\": \"/${ENV_NAME}/${SERVICE_NAME}\",
          \"path\": \"${ENV_FILE_PATH}\"
        },"
      fi
    fi
    json_list="${json_list%?}]"
    export PARAMS_LIST=${json_list}
    echo "PARAMS_LIST: ${PARAMS_LIST}"
  - rm -fr /builds/terraform/
  - git clone https://gitlab-ci-token:${CI_JOB_TOKEN}@gitlab.com/fireblocks/devops/terraform.git
  - "$(assume-role.sh ${TERRAGRUNT_ROLE} gitlab-runner)"
  - cd /builds/terraform
  - "$(python3 switch-devx-env.py ${TERRAFORM_ENV_NAME})"
  - echo ${TERRAGRUNT_PROJECT}
  - cd ${TERRAGRUNT_PROJECT}
  script:
  - echo ${SERVICE_NAME} ${IMAGE_TAG} ${CI_ENVIRONMENT_NAME}
  - terragrunt apply --auto-approve --terragrunt-non-interactive --var "parameter_files=${PARAMS_LIST}"
  variables:
    TERRAGRUNT_PROJECT: "/builds/terraform/terragrunt/devx/parameter-store"
    TERRAFORM_ENV_NAME: "${ENV_NAME}"
    COMMON_FILE_PATH: "${CI_PROJECT_DIR}/configurations/common/parameters.yaml"
    ENV_FILE_PATH: "${CI_PROJECT_DIR}/configurations/${ENV_NAME}/parameters.yaml"
    CUSTOM_PARAM_LIST: "${CI_PROJECT_DIR}/configurations/custom-param-configuration.json"
    AWS_REGION: us-east-2
    TERRAGRUNT_ROLE: arn:aws:iam::318128524537:role/gitlab-runner-parameter-store-role
    ENV_NAME: dev5
  extends: ".provision-configuration:k8s"
  tags:
  - shared-devx
  stage: configure
".config_dev6":
  image: registry.gitlab.com/fireblocks/devops/terraform/terraform-runner:v0.5.4
  retry: 2
  rules:
  - if: $CI_CONFIG_MANAGEMENT_ENABLED == "true"
    when: on_success
  after_script:
  - rm -fr /builds/terraform/
  - echo 'Done!'
  before_script:
  - cd /builds/
  - |
    yq --version || (echo "please install yq" && exit 1)
    json_list="["
    if [[ -f "${CUSTOM_PARAM_LIST}" ]]; then
      for custom_config in $(cat $CUSTOM_PARAM_LIST | jq -c '.[]'); do
        config_prefix=$(echo $custom_config | jq -r '.prefix' | envsubst)
        config_path=$(echo $custom_config | jq -r '.path' | envsubst)
        if yq -e $config_path; then
          json_list="${json_list}
          {
            \"prefix\": \"${config_prefix}\",
            \"path\": \"${config_path}\"
          },"
        fi
      done
    else
      if [ -f $COMMON_FILE_PATH ]; then
        json_list="${json_list}
        {
          \"prefix\": \"/${ENV_NAME}/${SERVICE_NAME}/common\",
          \"path\": \"${COMMON_FILE_PATH}\"
        },"
      fi
      if yq -e $ENV_FILE_PATH; then
        json_list="${json_list}
        {
          \"prefix\": \"/${ENV_NAME}/${SERVICE_NAME}\",
          \"path\": \"${ENV_FILE_PATH}\"
        },"
      fi
    fi
    json_list="${json_list%?}]"
    export PARAMS_LIST=${json_list}
    echo "PARAMS_LIST: ${PARAMS_LIST}"
  - rm -fr /builds/terraform/
  - git clone https://gitlab-ci-token:${CI_JOB_TOKEN}@gitlab.com/fireblocks/devops/terraform.git
  - "$(assume-role.sh ${TERRAGRUNT_ROLE} gitlab-runner)"
  - cd /builds/terraform
  - "$(python3 switch-devx-env.py ${TERRAFORM_ENV_NAME})"
  - echo ${TERRAGRUNT_PROJECT}
  - cd ${TERRAGRUNT_PROJECT}
  script:
  - echo ${SERVICE_NAME} ${IMAGE_TAG} ${CI_ENVIRONMENT_NAME}
  - terragrunt apply --auto-approve --terragrunt-non-interactive --var "parameter_files=${PARAMS_LIST}"
  variables:
    TERRAGRUNT_PROJECT: "/builds/terraform/terragrunt/devx/parameter-store"
    TERRAFORM_ENV_NAME: "${ENV_NAME}"
    COMMON_FILE_PATH: "${CI_PROJECT_DIR}/configurations/common/parameters.yaml"
    ENV_FILE_PATH: "${CI_PROJECT_DIR}/configurations/${ENV_NAME}/parameters.yaml"
    CUSTOM_PARAM_LIST: "${CI_PROJECT_DIR}/configurations/custom-param-configuration.json"
    AWS_REGION: us-east-2
    TERRAGRUNT_ROLE: arn:aws:iam::318128524537:role/gitlab-runner-parameter-store-role
    ENV_NAME: dev6
  extends: ".provision-configuration:k8s"
  tags:
  - shared-devx
  stage: configure
".config_dev7":
  image: registry.gitlab.com/fireblocks/devops/terraform/terraform-runner:v0.5.4
  retry: 2
  rules:
  - if: $CI_CONFIG_MANAGEMENT_ENABLED == "true"
    when: on_success
  after_script:
  - rm -fr /builds/terraform/
  - echo 'Done!'
  before_script:
  - cd /builds/
  - |
    yq --version || (echo "please install yq" && exit 1)
    json_list="["
    if [[ -f "${CUSTOM_PARAM_LIST}" ]]; then
      for custom_config in $(cat $CUSTOM_PARAM_LIST | jq -c '.[]'); do
        config_prefix=$(echo $custom_config | jq -r '.prefix' | envsubst)
        config_path=$(echo $custom_config | jq -r '.path' | envsubst)
        if yq -e $config_path; then
          json_list="${json_list}
          {
            \"prefix\": \"${config_prefix}\",
            \"path\": \"${config_path}\"
          },"
        fi
      done
    else
      if [ -f $COMMON_FILE_PATH ]; then
        json_list="${json_list}
        {
          \"prefix\": \"/${ENV_NAME}/${SERVICE_NAME}/common\",
          \"path\": \"${COMMON_FILE_PATH}\"
        },"
      fi
      if yq -e $ENV_FILE_PATH; then
        json_list="${json_list}
        {
          \"prefix\": \"/${ENV_NAME}/${SERVICE_NAME}\",
          \"path\": \"${ENV_FILE_PATH}\"
        },"
      fi
    fi
    json_list="${json_list%?}]"
    export PARAMS_LIST=${json_list}
    echo "PARAMS_LIST: ${PARAMS_LIST}"
  - rm -fr /builds/terraform/
  - git clone https://gitlab-ci-token:${CI_JOB_TOKEN}@gitlab.com/fireblocks/devops/terraform.git
  - "$(assume-role.sh ${TERRAGRUNT_ROLE} gitlab-runner)"
  - cd /builds/terraform
  - "$(python3 switch-devx-env.py ${TERRAFORM_ENV_NAME})"
  - echo ${TERRAGRUNT_PROJECT}
  - cd ${TERRAGRUNT_PROJECT}
  script:
  - echo ${SERVICE_NAME} ${IMAGE_TAG} ${CI_ENVIRONMENT_NAME}
  - terragrunt apply --auto-approve --terragrunt-non-interactive --var "parameter_files=${PARAMS_LIST}"
  variables:
    TERRAGRUNT_PROJECT: "/builds/terraform/terragrunt/devx/parameter-store"
    TERRAFORM_ENV_NAME: "${ENV_NAME}"
    COMMON_FILE_PATH: "${CI_PROJECT_DIR}/configurations/common/parameters.yaml"
    ENV_FILE_PATH: "${CI_PROJECT_DIR}/configurations/${ENV_NAME}/parameters.yaml"
    CUSTOM_PARAM_LIST: "${CI_PROJECT_DIR}/configurations/custom-param-configuration.json"
    AWS_REGION: us-east-2
    TERRAGRUNT_ROLE: arn:aws:iam::318128524537:role/gitlab-runner-parameter-store-role
    ENV_NAME: dev7
  extends: ".provision-configuration:k8s"
  tags:
  - shared-devx
  stage: configure
".config_dev8":
  image: registry.gitlab.com/fireblocks/devops/terraform/terraform-runner:v0.5.4
  retry: 2
  rules:
  - if: $CI_CONFIG_MANAGEMENT_ENABLED == "true"
    when: on_success
  after_script:
  - rm -fr /builds/terraform/
  - echo 'Done!'
  before_script:
  - cd /builds/
  - |
    yq --version || (echo "please install yq" && exit 1)
    json_list="["
    if [[ -f "${CUSTOM_PARAM_LIST}" ]]; then
      for custom_config in $(cat $CUSTOM_PARAM_LIST | jq -c '.[]'); do
        config_prefix=$(echo $custom_config | jq -r '.prefix' | envsubst)
        config_path=$(echo $custom_config | jq -r '.path' | envsubst)
        if yq -e $config_path; then
          json_list="${json_list}
          {
            \"prefix\": \"${config_prefix}\",
            \"path\": \"${config_path}\"
          },"
        fi
      done
    else
      if [ -f $COMMON_FILE_PATH ]; then
        json_list="${json_list}
        {
          \"prefix\": \"/${ENV_NAME}/${SERVICE_NAME}/common\",
          \"path\": \"${COMMON_FILE_PATH}\"
        },"
      fi
      if yq -e $ENV_FILE_PATH; then
        json_list="${json_list}
        {
          \"prefix\": \"/${ENV_NAME}/${SERVICE_NAME}\",
          \"path\": \"${ENV_FILE_PATH}\"
        },"
      fi
    fi
    json_list="${json_list%?}]"
    export PARAMS_LIST=${json_list}
    echo "PARAMS_LIST: ${PARAMS_LIST}"
  - rm -fr /builds/terraform/
  - git clone https://gitlab-ci-token:${CI_JOB_TOKEN}@gitlab.com/fireblocks/devops/terraform.git
  - "$(assume-role.sh ${TERRAGRUNT_ROLE} gitlab-runner)"
  - cd /builds/terraform
  - "$(python3 switch-devx-env.py ${TERRAFORM_ENV_NAME})"
  - echo ${TERRAGRUNT_PROJECT}
  - cd ${TERRAGRUNT_PROJECT}
  script:
  - echo ${SERVICE_NAME} ${IMAGE_TAG} ${CI_ENVIRONMENT_NAME}
  - terragrunt apply --auto-approve --terragrunt-non-interactive --var "parameter_files=${PARAMS_LIST}"
  variables:
    TERRAGRUNT_PROJECT: "/builds/terraform/terragrunt/devx/parameter-store"
    TERRAFORM_ENV_NAME: "${ENV_NAME}"
    COMMON_FILE_PATH: "${CI_PROJECT_DIR}/configurations/common/parameters.yaml"
    ENV_FILE_PATH: "${CI_PROJECT_DIR}/configurations/${ENV_NAME}/parameters.yaml"
    CUSTOM_PARAM_LIST: "${CI_PROJECT_DIR}/configurations/custom-param-configuration.json"
    AWS_REGION: us-east-2
    TERRAGRUNT_ROLE: arn:aws:iam::318128524537:role/gitlab-runner-parameter-store-role
    ENV_NAME: dev8
  extends: ".provision-configuration:k8s"
  tags:
  - shared-devx
  stage: configure
".config_dev9":
  image: registry.gitlab.com/fireblocks/devops/terraform/terraform-runner:v0.5.4
  retry: 2
  rules:
  - if: $CI_CONFIG_MANAGEMENT_ENABLED == "true"
    when: on_success
  after_script:
  - rm -fr /builds/terraform/
  - echo 'Done!'
  before_script:
  - cd /builds/
  - |
    yq --version || (echo "please install yq" && exit 1)
    json_list="["
    if [[ -f "${CUSTOM_PARAM_LIST}" ]]; then
      for custom_config in $(cat $CUSTOM_PARAM_LIST | jq -c '.[]'); do
        config_prefix=$(echo $custom_config | jq -r '.prefix' | envsubst)
        config_path=$(echo $custom_config | jq -r '.path' | envsubst)
        if yq -e $config_path; then
          json_list="${json_list}
          {
            \"prefix\": \"${config_prefix}\",
            \"path\": \"${config_path}\"
          },"
        fi
      done
    else
      if [ -f $COMMON_FILE_PATH ]; then
        json_list="${json_list}
        {
          \"prefix\": \"/${ENV_NAME}/${SERVICE_NAME}/common\",
          \"path\": \"${COMMON_FILE_PATH}\"
        },"
      fi
      if yq -e $ENV_FILE_PATH; then
        json_list="${json_list}
        {
          \"prefix\": \"/${ENV_NAME}/${SERVICE_NAME}\",
          \"path\": \"${ENV_FILE_PATH}\"
        },"
      fi
    fi
    json_list="${json_list%?}]"
    export PARAMS_LIST=${json_list}
    echo "PARAMS_LIST: ${PARAMS_LIST}"
  - rm -fr /builds/terraform/
  - git clone https://gitlab-ci-token:${CI_JOB_TOKEN}@gitlab.com/fireblocks/devops/terraform.git
  - "$(assume-role.sh ${TERRAGRUNT_ROLE} gitlab-runner)"
  - cd /builds/terraform
  - "$(python3 switch-devx-env.py ${TERRAFORM_ENV_NAME})"
  - echo ${TERRAGRUNT_PROJECT}
  - cd ${TERRAGRUNT_PROJECT}
  script:
  - echo ${SERVICE_NAME} ${IMAGE_TAG} ${CI_ENVIRONMENT_NAME}
  - terragrunt apply --auto-approve --terragrunt-non-interactive --var "parameter_files=${PARAMS_LIST}"
  variables:
    TERRAGRUNT_PROJECT: "/builds/terraform/terragrunt/devx/parameter-store"
    TERRAFORM_ENV_NAME: "${ENV_NAME}"
    COMMON_FILE_PATH: "${CI_PROJECT_DIR}/configurations/common/parameters.yaml"
    ENV_FILE_PATH: "${CI_PROJECT_DIR}/configurations/${ENV_NAME}/parameters.yaml"
    CUSTOM_PARAM_LIST: "${CI_PROJECT_DIR}/configurations/custom-param-configuration.json"
    AWS_REGION: us-east-2
    TERRAGRUNT_ROLE: arn:aws:iam::318128524537:role/gitlab-runner-parameter-store-role
    ENV_NAME: dev9
  extends: ".provision-configuration:k8s"
  tags:
  - shared-devx
  stage: configure
".config_dev10":
  image: registry.gitlab.com/fireblocks/devops/terraform/terraform-runner:v0.5.4
  retry: 2
  rules:
  - if: $CI_CONFIG_MANAGEMENT_ENABLED == "true"
    when: on_success
  after_script:
  - rm -fr /builds/terraform/
  - echo 'Done!'
  before_script:
  - cd /builds/
  - |
    yq --version || (echo "please install yq" && exit 1)
    json_list="["
    if [[ -f "${CUSTOM_PARAM_LIST}" ]]; then
      for custom_config in $(cat $CUSTOM_PARAM_LIST | jq -c '.[]'); do
        config_prefix=$(echo $custom_config | jq -r '.prefix' | envsubst)
        config_path=$(echo $custom_config | jq -r '.path' | envsubst)
        if yq -e $config_path; then
          json_list="${json_list}
          {
            \"prefix\": \"${config_prefix}\",
            \"path\": \"${config_path}\"
          },"
        fi
      done
    else
      if [ -f $COMMON_FILE_PATH ]; then
        json_list="${json_list}
        {
          \"prefix\": \"/${ENV_NAME}/${SERVICE_NAME}/common\",
          \"path\": \"${COMMON_FILE_PATH}\"
        },"
      fi
      if yq -e $ENV_FILE_PATH; then
        json_list="${json_list}
        {
          \"prefix\": \"/${ENV_NAME}/${SERVICE_NAME}\",
          \"path\": \"${ENV_FILE_PATH}\"
        },"
      fi
    fi
    json_list="${json_list%?}]"
    export PARAMS_LIST=${json_list}
    echo "PARAMS_LIST: ${PARAMS_LIST}"
  - rm -fr /builds/terraform/
  - git clone https://gitlab-ci-token:${CI_JOB_TOKEN}@gitlab.com/fireblocks/devops/terraform.git
  - "$(assume-role.sh ${TERRAGRUNT_ROLE} gitlab-runner)"
  - cd /builds/terraform
  - "$(python3 switch-devx-env.py ${TERRAFORM_ENV_NAME})"
  - echo ${TERRAGRUNT_PROJECT}
  - cd ${TERRAGRUNT_PROJECT}
  script:
  - echo ${SERVICE_NAME} ${IMAGE_TAG} ${CI_ENVIRONMENT_NAME}
  - terragrunt apply --auto-approve --terragrunt-non-interactive --var "parameter_files=${PARAMS_LIST}"
  variables:
    TERRAGRUNT_PROJECT: "/builds/terraform/terragrunt/devx/parameter-store"
    TERRAFORM_ENV_NAME: "${ENV_NAME}"
    COMMON_FILE_PATH: "${CI_PROJECT_DIR}/configurations/common/parameters.yaml"
    ENV_FILE_PATH: "${CI_PROJECT_DIR}/configurations/${ENV_NAME}/parameters.yaml"
    CUSTOM_PARAM_LIST: "${CI_PROJECT_DIR}/configurations/custom-param-configuration.json"
    AWS_REGION: us-east-2
    TERRAGRUNT_ROLE: arn:aws:iam::318128524537:role/gitlab-runner-parameter-store-role
    ENV_NAME: dev10
  extends: ".provision-configuration:k8s"
  tags:
  - shared-devx
  stage: configure
".config_dev11":
  image: registry.gitlab.com/fireblocks/devops/terraform/terraform-runner:v0.5.4
  retry: 2
  rules:
  - if: $CI_CONFIG_MANAGEMENT_ENABLED == "true"
    when: on_success
  after_script:
  - rm -fr /builds/terraform/
  - echo 'Done!'
  before_script:
  - cd /builds/
  - |
    yq --version || (echo "please install yq" && exit 1)
    json_list="["
    if [[ -f "${CUSTOM_PARAM_LIST}" ]]; then
      for custom_config in $(cat $CUSTOM_PARAM_LIST | jq -c '.[]'); do
        config_prefix=$(echo $custom_config | jq -r '.prefix' | envsubst)
        config_path=$(echo $custom_config | jq -r '.path' | envsubst)
        if yq -e $config_path; then
          json_list="${json_list}
          {
            \"prefix\": \"${config_prefix}\",
            \"path\": \"${config_path}\"
          },"
        fi
      done
    else
      if [ -f $COMMON_FILE_PATH ]; then
        json_list="${json_list}
        {
          \"prefix\": \"/${ENV_NAME}/${SERVICE_NAME}/common\",
          \"path\": \"${COMMON_FILE_PATH}\"
        },"
      fi
      if yq -e $ENV_FILE_PATH; then
        json_list="${json_list}
        {
          \"prefix\": \"/${ENV_NAME}/${SERVICE_NAME}\",
          \"path\": \"${ENV_FILE_PATH}\"
        },"
      fi
    fi
    json_list="${json_list%?}]"
    export PARAMS_LIST=${json_list}
    echo "PARAMS_LIST: ${PARAMS_LIST}"
  - rm -fr /builds/terraform/
  - git clone https://gitlab-ci-token:${CI_JOB_TOKEN}@gitlab.com/fireblocks/devops/terraform.git
  - "$(assume-role.sh ${TERRAGRUNT_ROLE} gitlab-runner)"
  - cd /builds/terraform
  - "$(python3 switch-devx-env.py ${TERRAFORM_ENV_NAME})"
  - echo ${TERRAGRUNT_PROJECT}
  - cd ${TERRAGRUNT_PROJECT}
  script:
  - echo ${SERVICE_NAME} ${IMAGE_TAG} ${CI_ENVIRONMENT_NAME}
  - terragrunt apply --auto-approve --terragrunt-non-interactive --var "parameter_files=${PARAMS_LIST}"
  variables:
    TERRAGRUNT_PROJECT: "/builds/terraform/terragrunt/devx/parameter-store"
    TERRAFORM_ENV_NAME: "${ENV_NAME}"
    COMMON_FILE_PATH: "${CI_PROJECT_DIR}/configurations/common/parameters.yaml"
    ENV_FILE_PATH: "${CI_PROJECT_DIR}/configurations/${ENV_NAME}/parameters.yaml"
    CUSTOM_PARAM_LIST: "${CI_PROJECT_DIR}/configurations/custom-param-configuration.json"
    AWS_REGION: us-east-2
    TERRAGRUNT_ROLE: arn:aws:iam::318128524537:role/gitlab-runner-parameter-store-role
    ENV_NAME: dev11
  extends: ".provision-configuration:k8s"
  tags:
  - shared-devx
  stage: configure
".config_dev12":
  image: registry.gitlab.com/fireblocks/devops/terraform/terraform-runner:v0.5.4
  retry: 2
  rules:
  - if: $CI_CONFIG_MANAGEMENT_ENABLED == "true"
    when: on_success
  after_script:
  - rm -fr /builds/terraform/
  - echo 'Done!'
  before_script:
  - cd /builds/
  - |
    yq --version || (echo "please install yq" && exit 1)
    json_list="["
    if [[ -f "${CUSTOM_PARAM_LIST}" ]]; then
      for custom_config in $(cat $CUSTOM_PARAM_LIST | jq -c '.[]'); do
        config_prefix=$(echo $custom_config | jq -r '.prefix' | envsubst)
        config_path=$(echo $custom_config | jq -r '.path' | envsubst)
        if yq -e $config_path; then
          json_list="${json_list}
          {
            \"prefix\": \"${config_prefix}\",
            \"path\": \"${config_path}\"
          },"
        fi
      done
    else
      if [ -f $COMMON_FILE_PATH ]; then
        json_list="${json_list}
        {
          \"prefix\": \"/${ENV_NAME}/${SERVICE_NAME}/common\",
          \"path\": \"${COMMON_FILE_PATH}\"
        },"
      fi
      if yq -e $ENV_FILE_PATH; then
        json_list="${json_list}
        {
          \"prefix\": \"/${ENV_NAME}/${SERVICE_NAME}\",
          \"path\": \"${ENV_FILE_PATH}\"
        },"
      fi
    fi
    json_list="${json_list%?}]"
    export PARAMS_LIST=${json_list}
    echo "PARAMS_LIST: ${PARAMS_LIST}"
  - rm -fr /builds/terraform/
  - git clone https://gitlab-ci-token:${CI_JOB_TOKEN}@gitlab.com/fireblocks/devops/terraform.git
  - "$(assume-role.sh ${TERRAGRUNT_ROLE} gitlab-runner)"
  - cd /builds/terraform
  - "$(python3 switch-devx-env.py ${TERRAFORM_ENV_NAME})"
  - echo ${TERRAGRUNT_PROJECT}
  - cd ${TERRAGRUNT_PROJECT}
  script:
  - echo ${SERVICE_NAME} ${IMAGE_TAG} ${CI_ENVIRONMENT_NAME}
  - terragrunt apply --auto-approve --terragrunt-non-interactive --var "parameter_files=${PARAMS_LIST}"
  variables:
    TERRAGRUNT_PROJECT: "/builds/terraform/terragrunt/devx/parameter-store"
    TERRAFORM_ENV_NAME: "${ENV_NAME}"
    COMMON_FILE_PATH: "${CI_PROJECT_DIR}/configurations/common/parameters.yaml"
    ENV_FILE_PATH: "${CI_PROJECT_DIR}/configurations/${ENV_NAME}/parameters.yaml"
    CUSTOM_PARAM_LIST: "${CI_PROJECT_DIR}/configurations/custom-param-configuration.json"
    AWS_REGION: us-east-2
    TERRAGRUNT_ROLE: arn:aws:iam::318128524537:role/gitlab-runner-parameter-store-role
    ENV_NAME: dev12
  extends: ".provision-configuration:k8s"
  tags:
  - shared-devx
  stage: configure
".config_dev13":
  image: registry.gitlab.com/fireblocks/devops/terraform/terraform-runner:v0.5.4
  retry: 2
  rules:
  - if: $CI_CONFIG_MANAGEMENT_ENABLED == "true"
    when: on_success
  after_script:
  - rm -fr /builds/terraform/
  - echo 'Done!'
  before_script:
  - cd /builds/
  - |
    yq --version || (echo "please install yq" && exit 1)
    json_list="["
    if [[ -f "${CUSTOM_PARAM_LIST}" ]]; then
      for custom_config in $(cat $CUSTOM_PARAM_LIST | jq -c '.[]'); do
        config_prefix=$(echo $custom_config | jq -r '.prefix' | envsubst)
        config_path=$(echo $custom_config | jq -r '.path' | envsubst)
        if yq -e $config_path; then
          json_list="${json_list}
          {
            \"prefix\": \"${config_prefix}\",
            \"path\": \"${config_path}\"
          },"
        fi
      done
    else
      if [ -f $COMMON_FILE_PATH ]; then
        json_list="${json_list}
        {
          \"prefix\": \"/${ENV_NAME}/${SERVICE_NAME}/common\",
          \"path\": \"${COMMON_FILE_PATH}\"
        },"
      fi
      if yq -e $ENV_FILE_PATH; then
        json_list="${json_list}
        {
          \"prefix\": \"/${ENV_NAME}/${SERVICE_NAME}\",
          \"path\": \"${ENV_FILE_PATH}\"
        },"
      fi
    fi
    json_list="${json_list%?}]"
    export PARAMS_LIST=${json_list}
    echo "PARAMS_LIST: ${PARAMS_LIST}"
  - rm -fr /builds/terraform/
  - git clone https://gitlab-ci-token:${CI_JOB_TOKEN}@gitlab.com/fireblocks/devops/terraform.git
  - "$(assume-role.sh ${TERRAGRUNT_ROLE} gitlab-runner)"
  - cd /builds/terraform
  - "$(python3 switch-devx-env.py ${TERRAFORM_ENV_NAME})"
  - echo ${TERRAGRUNT_PROJECT}
  - cd ${TERRAGRUNT_PROJECT}
  script:
  - echo ${SERVICE_NAME} ${IMAGE_TAG} ${CI_ENVIRONMENT_NAME}
  - terragrunt apply --auto-approve --terragrunt-non-interactive --var "parameter_files=${PARAMS_LIST}"
  variables:
    TERRAGRUNT_PROJECT: "/builds/terraform/terragrunt/devx/parameter-store"
    TERRAFORM_ENV_NAME: "${ENV_NAME}"
    COMMON_FILE_PATH: "${CI_PROJECT_DIR}/configurations/common/parameters.yaml"
    ENV_FILE_PATH: "${CI_PROJECT_DIR}/configurations/${ENV_NAME}/parameters.yaml"
    CUSTOM_PARAM_LIST: "${CI_PROJECT_DIR}/configurations/custom-param-configuration.json"
    AWS_REGION: us-east-2
    TERRAGRUNT_ROLE: arn:aws:iam::318128524537:role/gitlab-runner-parameter-store-role
    ENV_NAME: dev13
  extends: ".provision-configuration:k8s"
  tags:
  - shared-devx
  stage: configure
".config_dev14":
  image: registry.gitlab.com/fireblocks/devops/terraform/terraform-runner:v0.5.4
  retry: 2
  rules:
  - if: $CI_CONFIG_MANAGEMENT_ENABLED == "true"
    when: on_success
  after_script:
  - rm -fr /builds/terraform/
  - echo 'Done!'
  before_script:
  - cd /builds/
  - |
    yq --version || (echo "please install yq" && exit 1)
    json_list="["
    if [[ -f "${CUSTOM_PARAM_LIST}" ]]; then
      for custom_config in $(cat $CUSTOM_PARAM_LIST | jq -c '.[]'); do
        config_prefix=$(echo $custom_config | jq -r '.prefix' | envsubst)
        config_path=$(echo $custom_config | jq -r '.path' | envsubst)
        if yq -e $config_path; then
          json_list="${json_list}
          {
            \"prefix\": \"${config_prefix}\",
            \"path\": \"${config_path}\"
          },"
        fi
      done
    else
      if [ -f $COMMON_FILE_PATH ]; then
        json_list="${json_list}
        {
          \"prefix\": \"/${ENV_NAME}/${SERVICE_NAME}/common\",
          \"path\": \"${COMMON_FILE_PATH}\"
        },"
      fi
      if yq -e $ENV_FILE_PATH; then
        json_list="${json_list}
        {
          \"prefix\": \"/${ENV_NAME}/${SERVICE_NAME}\",
          \"path\": \"${ENV_FILE_PATH}\"
        },"
      fi
    fi
    json_list="${json_list%?}]"
    export PARAMS_LIST=${json_list}
    echo "PARAMS_LIST: ${PARAMS_LIST}"
  - rm -fr /builds/terraform/
  - git clone https://gitlab-ci-token:${CI_JOB_TOKEN}@gitlab.com/fireblocks/devops/terraform.git
  - "$(assume-role.sh ${TERRAGRUNT_ROLE} gitlab-runner)"
  - cd /builds/terraform
  - "$(python3 switch-devx-env.py ${TERRAFORM_ENV_NAME})"
  - echo ${TERRAGRUNT_PROJECT}
  - cd ${TERRAGRUNT_PROJECT}
  script:
  - echo ${SERVICE_NAME} ${IMAGE_TAG} ${CI_ENVIRONMENT_NAME}
  - terragrunt apply --auto-approve --terragrunt-non-interactive --var "parameter_files=${PARAMS_LIST}"
  variables:
    TERRAGRUNT_PROJECT: "/builds/terraform/terragrunt/devx/parameter-store"
    TERRAFORM_ENV_NAME: "${ENV_NAME}"
    COMMON_FILE_PATH: "${CI_PROJECT_DIR}/configurations/common/parameters.yaml"
    ENV_FILE_PATH: "${CI_PROJECT_DIR}/configurations/${ENV_NAME}/parameters.yaml"
    CUSTOM_PARAM_LIST: "${CI_PROJECT_DIR}/configurations/custom-param-configuration.json"
    AWS_REGION: us-east-2
    TERRAGRUNT_ROLE: arn:aws:iam::318128524537:role/gitlab-runner-parameter-store-role
    ENV_NAME: dev14
  extends: ".provision-configuration:k8s"
  tags:
  - shared-devx
  stage: configure
".config_dev15":
  image: registry.gitlab.com/fireblocks/devops/terraform/terraform-runner:v0.5.4
  retry: 2
  rules:
  - if: $CI_CONFIG_MANAGEMENT_ENABLED == "true"
    when: on_success
  after_script:
  - rm -fr /builds/terraform/
  - echo 'Done!'
  before_script:
  - cd /builds/
  - |
    yq --version || (echo "please install yq" && exit 1)
    json_list="["
    if [[ -f "${CUSTOM_PARAM_LIST}" ]]; then
      for custom_config in $(cat $CUSTOM_PARAM_LIST | jq -c '.[]'); do
        config_prefix=$(echo $custom_config | jq -r '.prefix' | envsubst)
        config_path=$(echo $custom_config | jq -r '.path' | envsubst)
        if yq -e $config_path; then
          json_list="${json_list}
          {
            \"prefix\": \"${config_prefix}\",
            \"path\": \"${config_path}\"
          },"
        fi
      done
    else
      if [ -f $COMMON_FILE_PATH ]; then
        json_list="${json_list}
        {
          \"prefix\": \"/${ENV_NAME}/${SERVICE_NAME}/common\",
          \"path\": \"${COMMON_FILE_PATH}\"
        },"
      fi
      if yq -e $ENV_FILE_PATH; then
        json_list="${json_list}
        {
          \"prefix\": \"/${ENV_NAME}/${SERVICE_NAME}\",
          \"path\": \"${ENV_FILE_PATH}\"
        },"
      fi
    fi
    json_list="${json_list%?}]"
    export PARAMS_LIST=${json_list}
    echo "PARAMS_LIST: ${PARAMS_LIST}"
  - rm -fr /builds/terraform/
  - git clone https://gitlab-ci-token:${CI_JOB_TOKEN}@gitlab.com/fireblocks/devops/terraform.git
  - "$(assume-role.sh ${TERRAGRUNT_ROLE} gitlab-runner)"
  - cd /builds/terraform
  - "$(python3 switch-devx-env.py ${TERRAFORM_ENV_NAME})"
  - echo ${TERRAGRUNT_PROJECT}
  - cd ${TERRAGRUNT_PROJECT}
  script:
  - echo ${SERVICE_NAME} ${IMAGE_TAG} ${CI_ENVIRONMENT_NAME}
  - terragrunt apply --auto-approve --terragrunt-non-interactive --var "parameter_files=${PARAMS_LIST}"
  variables:
    TERRAGRUNT_PROJECT: "/builds/terraform/terragrunt/devx/parameter-store"
    TERRAFORM_ENV_NAME: "${ENV_NAME}"
    COMMON_FILE_PATH: "${CI_PROJECT_DIR}/configurations/common/parameters.yaml"
    ENV_FILE_PATH: "${CI_PROJECT_DIR}/configurations/${ENV_NAME}/parameters.yaml"
    CUSTOM_PARAM_LIST: "${CI_PROJECT_DIR}/configurations/custom-param-configuration.json"
    AWS_REGION: us-east-2
    TERRAGRUNT_ROLE: arn:aws:iam::318128524537:role/gitlab-runner-parameter-store-role
    ENV_NAME: dev15
  extends: ".provision-configuration:k8s"
  tags:
  - shared-devx
  stage: configure
".config_prod-us":
  image: registry.gitlab.com/fireblocks/devops/terraform/terraform-runner:v0.5.4
  retry: 2
  rules:
  - if: $CI_CONFIG_MANAGEMENT_ENABLED == "true"
    when: always
  tags:
  - dev-common-runner
  after_script:
  - rm -fr /builds/terraform/
  - echo 'Done!'
  before_script:
  - apt install unzip
  - curl "https://awscli.amazonaws.com/awscli-exe-linux-x86_64.zip" -o "awscliv2.zip"
  - unzip -q awscliv2.zip
  - "./aws/install"
  - cd /builds/
  - |
    yq --version || (echo "please install yq" && exit 1)
    json_list="["
    if [[ -f "${CUSTOM_PARAM_LIST}" ]]; then
      for custom_config in $(cat $CUSTOM_PARAM_LIST | jq -c '.[]'); do
        config_prefix=$(echo $custom_config | jq -r '.prefix' | envsubst)
        config_path=$(echo $custom_config | jq -r '.path' | envsubst)
        if yq -e $config_path; then
          json_list="${json_list}
          {
            \"prefix\": \"${config_prefix}\",
            \"path\": \"${config_path}\"
          },"
        fi
      done
    else
      if [ -f $COMMON_FILE_PATH ]; then
        json_list="${json_list}
        {
          \"prefix\": \"/${ENV_NAME}/${SERVICE_NAME}/common\",
          \"path\": \"${COMMON_FILE_PATH}\"
        },"
      fi
      if yq -e $ENV_FILE_PATH; then
        json_list="${json_list}
        {
          \"prefix\": \"/${ENV_NAME}/${SERVICE_NAME}\",
          \"path\": \"${ENV_FILE_PATH}\"
        },"
      fi
    fi
    json_list="${json_list%?}]"
    export PARAMS_LIST=${json_list}
    echo "PARAMS_LIST: ${PARAMS_LIST}"
  - rm -fr /builds/terraform/
  - git clone https://gitlab-ci-token:${CI_JOB_TOKEN}@gitlab.com/fireblocks/devops/terraform.git
  - cd /builds/terraform
  - "$(python3 switch-devx-env.py us-prod-legacy)"
  - echo ${TERRAGRUNT_PROJECT}
  - cd ${TERRAGRUNT_PROJECT}
  script:
  - echo ${SERVICE_NAME} ${IMAGE_TAG} ${CI_ENVIRONMENT_NAME}
  - terragrunt apply --auto-approve --terragrunt-non-interactive --var "parameter_files=${PARAMS_LIST}"
  variables:
    TERRAGRUNT_PROJECT: "/builds/terraform/terragrunt/devx/parameter-store"
    COMMON_FILE_PATH: "${CI_PROJECT_DIR}/configurations/common/parameters.yaml"
    ENV_FILE_PATH: "${CI_PROJECT_DIR}/configurations/${ENV_NAME}/parameters.yaml"
    CUSTOM_PARAM_LIST: "${CI_PROJECT_DIR}/configurations/custom-param-configuration.json"
    AWS_REGION: us-east-2
    ENV_NAME: prod-us
  extends: ".provision-configuration:legacy"
".config_prod-us_k8s":
  image: registry.gitlab.com/fireblocks/devops/terraform/terraform-runner:v0.5.4
  retry: 2
  rules:
  - if: $CI_CONFIG_MANAGEMENT_ENABLED == "true"
    when: on_success
  after_script:
  - rm -fr /builds/terraform/
  - echo 'Done!'
  before_script:
  - cd /builds/
  - |
    yq --version || (echo "please install yq" && exit 1)
    json_list="["
    if [[ -f "${CUSTOM_PARAM_LIST}" ]]; then
      for custom_config in $(cat $CUSTOM_PARAM_LIST | jq -c '.[]'); do
        config_prefix=$(echo $custom_config | jq -r '.prefix' | envsubst)
        config_path=$(echo $custom_config | jq -r '.path' | envsubst)
        if yq -e $config_path; then
          json_list="${json_list}
          {
            \"prefix\": \"${config_prefix}\",
            \"path\": \"${config_path}\"
          },"
        fi
      done
    else
      if [ -f $COMMON_FILE_PATH ]; then
        json_list="${json_list}
        {
          \"prefix\": \"/${ENV_NAME}/${SERVICE_NAME}/common\",
          \"path\": \"${COMMON_FILE_PATH}\"
        },"
      fi
      if yq -e $ENV_FILE_PATH; then
        json_list="${json_list}
        {
          \"prefix\": \"/${ENV_NAME}/${SERVICE_NAME}\",
          \"path\": \"${ENV_FILE_PATH}\"
        },"
      fi
    fi
    json_list="${json_list%?}]"
    export PARAMS_LIST=${json_list}
    echo "PARAMS_LIST: ${PARAMS_LIST}"
  - rm -fr /builds/terraform/
  - git clone https://gitlab-ci-token:${CI_JOB_TOKEN}@gitlab.com/fireblocks/devops/terraform.git
  - "$(assume-role.sh ${TERRAGRUNT_ROLE} gitlab-runner)"
  - cd /builds/terraform
  - "$(python3 switch-devx-env.py ${TERRAFORM_ENV_NAME})"
  - echo ${TERRAGRUNT_PROJECT}
  - cd ${TERRAGRUNT_PROJECT}
  script:
  - echo ${SERVICE_NAME} ${IMAGE_TAG} ${CI_ENVIRONMENT_NAME}
  - terragrunt apply --auto-approve --terragrunt-non-interactive --var "parameter_files=${PARAMS_LIST}"
  variables:
    TERRAGRUNT_PROJECT: "/builds/terraform/terragrunt/devx/parameter-store"
    TERRAFORM_ENV_NAME: "${ENV_NAME}"
    COMMON_FILE_PATH: "${CI_PROJECT_DIR}/configurations/common/parameters.yaml"
    ENV_FILE_PATH: "${CI_PROJECT_DIR}/configurations/${ENV_NAME}/parameters.yaml"
    CUSTOM_PARAM_LIST: "${CI_PROJECT_DIR}/configurations/custom-param-configuration.json"
    AWS_REGION: us-east-2
    ENV_NAME: prod-us
    TERRAGRUNT_ROLE: arn:aws:iam::808451231866:role/gitlab-runner-parameter-store-role
  extends: ".provision-configuration:k8s"
  tags:
  - shared-us-prod-sso
".config_sandbox":
  image: registry.gitlab.com/fireblocks/devops/terraform/terraform-runner:v0.5.4
  retry: 2
  rules:
  - if: $CI_CONFIG_MANAGEMENT_ENABLED == "true"
    when: on_success
  after_script:
  - rm -fr /builds/terraform/
  - echo 'Done!'
  before_script:
  - cd /builds/
  - |
    yq --version || (echo "please install yq" && exit 1)
    json_list="["
    if [[ -f "${CUSTOM_PARAM_LIST}" ]]; then
      for custom_config in $(cat $CUSTOM_PARAM_LIST | jq -c '.[]'); do
        config_prefix=$(echo $custom_config | jq -r '.prefix' | envsubst)
        config_path=$(echo $custom_config | jq -r '.path' | envsubst)
        if yq -e $config_path; then
          json_list="${json_list}
          {
            \"prefix\": \"${config_prefix}\",
            \"path\": \"${config_path}\"
          },"
        fi
      done
    else
      if [ -f $COMMON_FILE_PATH ]; then
        json_list="${json_list}
        {
          \"prefix\": \"/${ENV_NAME}/${SERVICE_NAME}/common\",
          \"path\": \"${COMMON_FILE_PATH}\"
        },"
      fi
      if yq -e $ENV_FILE_PATH; then
        json_list="${json_list}
        {
          \"prefix\": \"/${ENV_NAME}/${SERVICE_NAME}\",
          \"path\": \"${ENV_FILE_PATH}\"
        },"
      fi
    fi
    json_list="${json_list%?}]"
    export PARAMS_LIST=${json_list}
    echo "PARAMS_LIST: ${PARAMS_LIST}"
  - rm -fr /builds/terraform/
  - git clone https://gitlab-ci-token:${CI_JOB_TOKEN}@gitlab.com/fireblocks/devops/terraform.git
  - "$(assume-role.sh ${TERRAGRUNT_ROLE} gitlab-runner)"
  - cd /builds/terraform
  - "$(python3 switch-devx-env.py ${TERRAFORM_ENV_NAME})"
  - echo ${TERRAGRUNT_PROJECT}
  - cd ${TERRAGRUNT_PROJECT}
  script:
  - echo ${SERVICE_NAME} ${IMAGE_TAG} ${CI_ENVIRONMENT_NAME}
  - terragrunt apply --auto-approve --terragrunt-non-interactive --var "parameter_files=${PARAMS_LIST}"
  variables:
    TERRAGRUNT_PROJECT: "/builds/terraform/terragrunt/devx/parameter-store"
    TERRAFORM_ENV_NAME: "${ENV_NAME}"
    COMMON_FILE_PATH: "${CI_PROJECT_DIR}/configurations/common/parameters.yaml"
    ENV_FILE_PATH: "${CI_PROJECT_DIR}/configurations/${ENV_NAME}/parameters.yaml"
    CUSTOM_PARAM_LIST: "${CI_PROJECT_DIR}/configurations/custom-param-configuration.json"
    AWS_REGION: us-east-2
    TERRAGRUNT_ROLE: arn:aws:iam::751886943440:role/gitlab-runner-parameter-store-role
    ENV_NAME: sandbox
  extends: ".provision-configuration:k8s"
  tags:
  - shared-sandbox
".config_eu-prod-fr":
  image: registry.gitlab.com/fireblocks/devops/terraform/terraform-runner:v0.5.4
  retry: 2
  rules:
  - if: $CI_CONFIG_MANAGEMENT_ENABLED == "true"
    when: on_success
  after_script:
  - rm -fr /builds/terraform/
  - echo 'Done!'
  before_script:
  - cd /builds/
  - |
    yq --version || (echo "please install yq" && exit 1)
    json_list="["
    if [[ -f "${CUSTOM_PARAM_LIST}" ]]; then
      for custom_config in $(cat $CUSTOM_PARAM_LIST | jq -c '.[]'); do
        config_prefix=$(echo $custom_config | jq -r '.prefix' | envsubst)
        config_path=$(echo $custom_config | jq -r '.path' | envsubst)
        if yq -e $config_path; then
          json_list="${json_list}
          {
            \"prefix\": \"${config_prefix}\",
            \"path\": \"${config_path}\"
          },"
        fi
      done
    else
      if [ -f $COMMON_FILE_PATH ]; then
        json_list="${json_list}
        {
          \"prefix\": \"/${ENV_NAME}/${SERVICE_NAME}/common\",
          \"path\": \"${COMMON_FILE_PATH}\"
        },"
      fi
      if yq -e $ENV_FILE_PATH; then
        json_list="${json_list}
        {
          \"prefix\": \"/${ENV_NAME}/${SERVICE_NAME}\",
          \"path\": \"${ENV_FILE_PATH}\"
        },"
      fi
    fi
    json_list="${json_list%?}]"
    export PARAMS_LIST=${json_list}
    echo "PARAMS_LIST: ${PARAMS_LIST}"
  - rm -fr /builds/terraform/
  - git clone https://gitlab-ci-token:${CI_JOB_TOKEN}@gitlab.com/fireblocks/devops/terraform.git
  - "$(assume-role.sh ${TERRAGRUNT_ROLE} gitlab-runner)"
  - cd /builds/terraform
  - "$(python3 switch-devx-env.py ${TERRAFORM_ENV_NAME})"
  - echo ${TERRAGRUNT_PROJECT}
  - cd ${TERRAGRUNT_PROJECT}
  script:
  - echo ${SERVICE_NAME} ${IMAGE_TAG} ${CI_ENVIRONMENT_NAME}
  - terragrunt apply --auto-approve --terragrunt-non-interactive --var "parameter_files=${PARAMS_LIST}"
  variables:
    TERRAGRUNT_PROJECT: "/builds/terraform/terragrunt/devx/parameter-store"
    TERRAFORM_ENV_NAME: eu-prod-fr
    COMMON_FILE_PATH: "${CI_PROJECT_DIR}/configurations/common/parameters.yaml"
    ENV_FILE_PATH: "${CI_PROJECT_DIR}/configurations/${ENV_NAME}/parameters.yaml"
    CUSTOM_PARAM_LIST: "${CI_PROJECT_DIR}/configurations/custom-param-configuration.json"
    AWS_REGION: eu-central-1
    TERRAGRUNT_ROLE: arn:aws:iam::455399297295:role/eu-prod-fr-shell-EKSDevRWAccessRole
    ENV_NAME: eu-prod
  extends: ".provision-configuration:k8s"
  tags:
  - eu-prod-fr
".config_eu2-prod-fr":
  image: registry.gitlab.com/fireblocks/devops/terraform/terraform-runner:v0.5.4
  retry: 2
  rules:
  - if: $CI_CONFIG_MANAGEMENT_ENABLED == "true"
    when: on_success
  after_script:
  - rm -fr /builds/terraform/
  - echo 'Done!'
  before_script:
  - cd /builds/
  - |
    yq --version || (echo "please install yq" && exit 1)
    json_list="["
    if [[ -f "${CUSTOM_PARAM_LIST}" ]]; then
      for custom_config in $(cat $CUSTOM_PARAM_LIST | jq -c '.[]'); do
        config_prefix=$(echo $custom_config | jq -r '.prefix' | envsubst)
        config_path=$(echo $custom_config | jq -r '.path' | envsubst)
        if yq -e $config_path; then
          json_list="${json_list}
          {
            \"prefix\": \"${config_prefix}\",
            \"path\": \"${config_path}\"
          },"
        fi
      done
    else
      if [ -f $COMMON_FILE_PATH ]; then
        json_list="${json_list}
        {
          \"prefix\": \"/${ENV_NAME}/${SERVICE_NAME}/common\",
          \"path\": \"${COMMON_FILE_PATH}\"
        },"
      fi
      if yq -e $ENV_FILE_PATH; then
        json_list="${json_list}
        {
          \"prefix\": \"/${ENV_NAME}/${SERVICE_NAME}\",
          \"path\": \"${ENV_FILE_PATH}\"
        },"
      fi
    fi
    json_list="${json_list%?}]"
    export PARAMS_LIST=${json_list}
    echo "PARAMS_LIST: ${PARAMS_LIST}"
  - rm -fr /builds/terraform/
  - git clone https://gitlab-ci-token:${CI_JOB_TOKEN}@gitlab.com/fireblocks/devops/terraform.git
  - "$(assume-role.sh ${TERRAGRUNT_ROLE} gitlab-runner)"
  - cd /builds/terraform
  - "$(python3 switch-devx-env.py ${TERRAFORM_ENV_NAME})"
  - echo ${TERRAGRUNT_PROJECT}
  - cd ${TERRAGRUNT_PROJECT}
  script:
  - echo ${SERVICE_NAME} ${IMAGE_TAG} ${CI_ENVIRONMENT_NAME}
  - terragrunt apply --auto-approve --terragrunt-non-interactive --var "parameter_files=${PARAMS_LIST}"
  variables:
    TERRAGRUNT_PROJECT: "/builds/terraform/terragrunt/devx/parameter-store"
    TERRAFORM_ENV_NAME: eu2-prod-fr-shell
    COMMON_FILE_PATH: "${CI_PROJECT_DIR}/configurations/common/parameters.yaml"
    ENV_FILE_PATH: "${CI_PROJECT_DIR}/configurations/${ENV_NAME}/parameters.yaml"
    CUSTOM_PARAM_LIST: "${CI_PROJECT_DIR}/configurations/custom-param-configuration.json"
    AWS_REGION: eu-central-1
    TERRAGRUNT_ROLE: arn:aws:iam::803035224331:role/gitlab-runner-parameter-store-role
    ENV_NAME: eu2-prod
  extends: ".provision-configuration:k8s"
  tags:
  - shared-eu2-prod
".config_bnym-dev":
  image: registry.gitlab.com/fireblocks/devops/terraform/terraform-runner:v0.5.4
  retry: 2
  rules:
  - if: $CI_CONFIG_MANAGEMENT_ENABLED == "true"
    when: on_success
  after_script:
  - rm -fr /builds/terraform/
  - echo 'Done!'
  before_script:
  - cd /builds/
  - |
    yq --version || (echo "please install yq" && exit 1)
    json_list="["
    if [[ -f "${CUSTOM_PARAM_LIST}" ]]; then
      for custom_config in $(cat $CUSTOM_PARAM_LIST | jq -c '.[]'); do
        config_prefix=$(echo $custom_config | jq -r '.prefix' | envsubst)
        config_path=$(echo $custom_config | jq -r '.path' | envsubst)
        if yq -e $config_path; then
          json_list="${json_list}
          {
            \"prefix\": \"${config_prefix}\",
            \"path\": \"${config_path}\"
          },"
        fi
      done
    else
      if [ -f $COMMON_FILE_PATH ]; then
        json_list="${json_list}
        {
          \"prefix\": \"/${ENV_NAME}/${SERVICE_NAME}/common\",
          \"path\": \"${COMMON_FILE_PATH}\"
        },"
      fi
      if yq -e $ENV_FILE_PATH; then
        json_list="${json_list}
        {
          \"prefix\": \"/${ENV_NAME}/${SERVICE_NAME}\",
          \"path\": \"${ENV_FILE_PATH}\"
        },"
      fi
    fi
    json_list="${json_list%?}]"
    export PARAMS_LIST=${json_list}
    echo "PARAMS_LIST: ${PARAMS_LIST}"
  - rm -fr /builds/terraform/
  - git clone https://gitlab-ci-token:${CI_JOB_TOKEN}@gitlab.com/fireblocks/devops/terraform.git
  - "$(assume-role.sh ${TERRAGRUNT_ROLE} gitlab-runner)"
  - cd /builds/terraform
  - "$(python3 switch-devx-env.py ${TERRAFORM_ENV_NAME})"
  - echo ${TERRAGRUNT_PROJECT}
  - cd ${TERRAGRUNT_PROJECT}
  script:
  - echo ${SERVICE_NAME} ${IMAGE_TAG} ${CI_ENVIRONMENT_NAME}
  - terragrunt apply --auto-approve --terragrunt-non-interactive --var "parameter_files=${PARAMS_LIST}"
  variables:
    TERRAGRUNT_PROJECT: "/builds/terraform/terragrunt/devx/parameter-store"
    TERRAFORM_ENV_NAME: bnym-dev-shell
    COMMON_FILE_PATH: "${CI_PROJECT_DIR}/configurations/common/parameters.yaml"
    ENV_FILE_PATH: "${CI_PROJECT_DIR}/configurations/${ENV_NAME}/parameters.yaml"
    CUSTOM_PARAM_LIST: "${CI_PROJECT_DIR}/configurations/custom-param-configuration.json"
    AWS_REGION: us-east-2
    TERRAGRUNT_ROLE: arn:aws:iam::414623400063:role/gitlab-runner-parameter-store-role
    ENV_NAME: bnym-dev
  extends: ".provision-configuration:k8s"
  tags:
  - shared-bnym-dev
".config_bnym-prod":
  image: registry.gitlab.com/fireblocks/devops/terraform/terraform-runner:v0.5.4
  retry: 2
  rules:
  - if: $CI_CONFIG_MANAGEMENT_ENABLED == "true"
    when: on_success
  after_script:
  - rm -fr /builds/terraform/
  - echo 'Done!'
  before_script:
  - cd /builds/
  - |
    yq --version || (echo "please install yq" && exit 1)
    json_list="["
    if [[ -f "${CUSTOM_PARAM_LIST}" ]]; then
      for custom_config in $(cat $CUSTOM_PARAM_LIST | jq -c '.[]'); do
        config_prefix=$(echo $custom_config | jq -r '.prefix' | envsubst)
        config_path=$(echo $custom_config | jq -r '.path' | envsubst)
        if yq -e $config_path; then
          json_list="${json_list}
          {
            \"prefix\": \"${config_prefix}\",
            \"path\": \"${config_path}\"
          },"
        fi
      done
    else
      if [ -f $COMMON_FILE_PATH ]; then
        json_list="${json_list}
        {
          \"prefix\": \"/${ENV_NAME}/${SERVICE_NAME}/common\",
          \"path\": \"${COMMON_FILE_PATH}\"
        },"
      fi
      if yq -e $ENV_FILE_PATH; then
        json_list="${json_list}
        {
          \"prefix\": \"/${ENV_NAME}/${SERVICE_NAME}\",
          \"path\": \"${ENV_FILE_PATH}\"
        },"
      fi
    fi
    json_list="${json_list%?}]"
    export PARAMS_LIST=${json_list}
    echo "PARAMS_LIST: ${PARAMS_LIST}"
  - rm -fr /builds/terraform/
  - git clone https://gitlab-ci-token:${CI_JOB_TOKEN}@gitlab.com/fireblocks/devops/terraform.git
  - "$(assume-role.sh ${TERRAGRUNT_ROLE} gitlab-runner)"
  - cd /builds/terraform
  - "$(python3 switch-devx-env.py ${TERRAFORM_ENV_NAME})"
  - echo ${TERRAGRUNT_PROJECT}
  - cd ${TERRAGRUNT_PROJECT}
  script:
  - echo ${SERVICE_NAME} ${IMAGE_TAG} ${CI_ENVIRONMENT_NAME}
  - terragrunt apply --auto-approve --terragrunt-non-interactive --var "parameter_files=${PARAMS_LIST}"
  variables:
    TERRAGRUNT_PROJECT: "/builds/terraform/terragrunt/devx/parameter-store"
    TERRAFORM_ENV_NAME: bnym-prod-shell
    COMMON_FILE_PATH: "${CI_PROJECT_DIR}/configurations/common/parameters.yaml"
    ENV_FILE_PATH: "${CI_PROJECT_DIR}/configurations/${ENV_NAME}/parameters.yaml"
    CUSTOM_PARAM_LIST: "${CI_PROJECT_DIR}/configurations/custom-param-configuration.json"
    AWS_REGION: us-east-2
    TERRAGRUNT_ROLE: arn:aws:iam::296106167418:role/gitlab-runner-parameter-store-role
    ENV_NAME: bnym-prod
  extends: ".provision-configuration:k8s"
  tags:
  - shared-bnym-prod
".publish_resources":
  stage: configure
  retry:
    max: 2
    when:
    - script_failure
  tags:
  - "${GITLAB_RUNNER_TAG}"
  before_script:
  - printf "%s:%s\n" DESTINATION_REPO "$DESTINATION_REPO" DESTINATION_PROJECT_ID "$DESTINATION_PROJECT_ID"
    SOURCE_PATH "$SOURCE_PATH" DESTINATION_PATH "$DESTINATION_PATH" STATE_BRANCH "$STATE_BRANCH"
    GITLAB_API_URL "$GITLAB_API_URL"
  - |
    if [ ! -d "$SOURCE_PATH" ]; then
      echo "$SOURCE_PATH directory does not exist. Exiting job successfully."
      exit 0
    fi
    echo "$SOURCE_PATH directory exists. Continuing with deployment."
  - - apk update
    - apk add curl jq yq py3-pip
    - pip3 install --upgrade pip
    - pip3 install yamllint
    - pip3 install yamale --break-system-packages
    - npm install -g ajv-cli
    - echo "Configuring Git"
    - echo "https://argocd-ci-push:${ARGOCD_GITLAB_ACCESS_TOKEN}@gitlab.com" > ~/.git-credentials
    - git remote set-url origin https://argocd-ci-push:${ARGOCD_GITLAB_ACCESS_TOKEN}@gitlab.com/fireblocks/devops/iac/argocd.git
    - git config --global user.email "devops@fireblocks.com"
    - git config --global user.name "argocd-ci-push"
    - git config --global credential.helper store
    - touch .npmrc
    - npm config set --location=user @fireblocks:registry https://gitlab.com/api/v4/packages/npm/
    - npm config set --location=user '//gitlab.com/api/v4/packages/npm/:_authToken'
      "${NPM_REG_TOKEN}"
    - npm config set --location=user '//gitlab.com/api/v4/projects/20565764/packages/npm/:_authToken'
      "${NPM_REG_TOKEN}"
    - echo "@fireblocks:registry=https://gitlab.com/api/v4/packages/npm/">>.npmrc
    - echo "//gitlab.com/api/v4/packages/npm/:_authToken=${NPM_REG_TOKEN}">>.npmrc
    - echo "//gitlab.com/api/v4/projects/20565764/packages/npm/:_authToken=${NPM_REG_TOKEN}">>.npmrc
    - yarn global add @fireblocks/fb-cli
  script:
  - - echo "Self Service User Guide - https://fireblocks.atlassian.net/wiki/spaces/RD/pages/1413218873/Self+Service+User+Guide"
    - SVC_NAME=$([ "$SERVICE_NAME" ] && echo $SERVICE_NAME || echo $CI_PROJECT_NAME)
    - echo "Verifying deployment folder for ${SVC_NAME} service"
    - git clone ${DESTINATION_REPO} mono_repo
    - cd mono_repo
    - git fetch --all
    - git checkout ${STATE_BRANCH}
    - git pull origin ${STATE_BRANCH} --no-rebase
    - cd ../${SOURCE_PATH}
    - |
      # Define the paths
      values_file="values.yaml"

      # Check for values.yaml in the deployment folder
      if [ ! -f "$values_file" ]; then
          echo "Error: The values.yaml file is missing in the ${SOURCE_PATH} folder."
          exit 1
      fi

      echo "Success: All required files are present"
    - |
      # Directory to check
      DIR_TO_CHECK="overrides/"

      # List of allowed files
      ALLOWED_PATTERN=$(printf "|%s" "nonprod-tier.yaml" "prod-tier.yaml" "iac-dev.yaml" "localstack.yaml" "dev1.yaml" "dev2.yaml" "dev3.yaml" "dev4.yaml" "dev5.yaml" "dev6.yaml" "dev7.yaml" "dev8.yaml" "dev9.yaml" "dev10.yaml" "dev11.yaml" "dev11.yaml" "dev12.yaml" "dev13.yaml" "dev14.yaml" "dev15.yaml" "pre1.yaml" "stage.yaml" "sandbox.yaml" "eu-prod.yaml" "eu2-prod.yaml" "bnym-dev.yaml" "bnym-prod.yaml" "us-prod.yaml" | cut -c 2-)

      # Flag to track if there are disallowed files
      DISALLOWED_FOUND=false

      # Check for files in the directory that are not in the allowed list
      for file in "$DIR_TO_CHECK"/*; do
        # Get the base name of the file
        filename=$(basename "$file")

        # Check if the filename is in the allowed list
        if [[ ! $filename =~ ^($ALLOWED_PATTERN)$ ]]; then
          echo "Disallowed file found: $filename"
          DISALLOWED_FOUND=true
        fi
      done

      # Final output
      if $DISALLOWED_FOUND; then
        echo "Some files are not allowed."
        exit 1
      else
        echo "All files are allowed."
      fi
    - echo "Linting deployment yaml files"
    - cp ../mono_repo/services/schema/*.yaml .
    - cp ../mono_repo/services/schema/appconfig_schema.json .
    - cp ../mono_repo/services/schema/main_appconfig.json appconfig.json
    - cp ../mono_repo/services/schema/yamllint_rules.yaml yamllint_rules.yaml
    - yamllint --list-files **/*.yaml *.yaml
    - yamllint -s **/*.yaml *.yaml -c yamllint_rules.yaml
    - echo "Validating deployment yaml schema"
    - yamale -s base_values_schema.yaml values.yaml
    - yamale -s tier_values_schema.yaml overrides/prod-tier.yaml
    - yamale -s tier_values_schema.yaml overrides/nonprod-tier.yaml
    - |
      # Iterate over all yaml files in the overrides folder
      for file in overrides/*.yaml; do
          # Extract the filename from the path
          filename=$(basename -- "$file")

          # Check if the file is not prod-tier.yaml or nonprod-tier.yaml
          if [[ "$filename" != "prod-tier.yaml" ]] && [[ "$filename" != "nonprod-tier.yaml" ]]; then
              # Run yamale command on the file
              yamale -s env_values_schema.yaml "$file"
          fi
      done
    - "# Iterate over all yaml files in the overrides folder - validate_resources.sh\nif
      [[ -v ENGINE && \"$ENGINE\" == \"argocd\" ]]; then\n  export CD_INFRA_PROJECT_ID=61508954\n
      \ curl --header \"PRIVATE-TOKEN: $CD_CPU_RAM_REQUEST_LIMIT_READ_ONLY\"  \"https://gitlab.com/api/v4/projects/$CD_INFRA_PROJECT_ID/repository/files/ci-infra%2Fscripts%2Fvalidate_resources.sh/raw?ref=main\"
      -o \"$CI_PROJECT_DIR/validate_resources.sh\"\n  echo \"chmod +x $CI_PROJECT_DIR/validate_resources.sh\"
      \n  chmod +x \"$CI_PROJECT_DIR/validate_resources.sh\"\n  echo \"Searching for
      environments values files...\" \n  ENV_FILES_LIST=$(yamllint --list-files **/*.yaml
      *.yaml | grep -vE 'env_values_schema\\.yaml|tier_values_schema\\.yaml|base_values_schema\\.yaml|yamllint_rules\\.yaml|.*prod-tier\\.yaml|values.yaml'
      || true)\n  if [[ -n \"$ENV_FILES_LIST\" ]]; then\n    echo \"Found environments
      values files\"\n    while IFS= read -r file; do\n      filename=$(basename --
      \"$file\")\n      if [[ \"$filename\" =~ ^(dev[1-9]|dev10|stage|pre1).yaml$
      ]]; then\n        tier_file=\"overrides/nonprod-tier.yaml\"\n      else\n        tier_file=\"overrides/prod-tier.yaml\"
      \ \n      fi\n      echo \"values.yaml <-- $tier_file <-- $file\"\n      yq
      eval-all '. as $item ireduce ({}; . * $item)' values.yaml \"$tier_file\" \"$file\"
      | bash \"$CI_PROJECT_DIR/validate_resources.sh\" -\n    done <<< \"$ENV_FILES_LIST\"\n
      \ else\n    echo \"No environments values files were found. Continuing to the
      tier files.\"\n  fi\necho \"values.yaml <-- overrides/nonprod-tier.yaml\"\nyq
      eval-all '. as $item ireduce ({}; . * $item)' values.yaml overrides/nonprod-tier.yaml
      | bash \"$CI_PROJECT_DIR/validate_resources.sh\" -\necho \"values.yaml <-- overrides/prod-tier.yaml\"
      \nyq eval-all '. as $item ireduce ({}; . * $item)' values.yaml overrides/prod-tier.yaml
      | bash \"$CI_PROJECT_DIR/validate_resources.sh\" -\nelse\n  echo \"Skipping
      resource validation: ENGINE is not set to 'argocd'.\"\nfi\n"
    - ajv validate -s appconfig_schema.json -d appconfig.json
    - echo "Resources verified successfully"
    - echo "Validate filter_policy if exists - should be a valid JSON object"
    - fb deployment:validate . --filter-policy
  - cd ../mono_repo
  - ENV_DESTINATION_PATH=$(echo "${DESTINATION_PATH}/${SVC_NAME}/${ENV}")
  - echo "Copying ${SOURCE_PATH} folder from ${SVC_NAME} service to argocd mono repo
    destination folder at ${ENV_DESTINATION_PATH}"
  - mkdir -pv ${ENV_DESTINATION_PATH}/overrides
  - rm ${ENV_DESTINATION_PATH}/overrides/${ENV}.yaml || true
  - cp  ../${SOURCE_PATH}/values.yaml ${ENV_DESTINATION_PATH}
  - cp ../${SOURCE_PATH}/overrides/${ENV}.yaml  ${ENV_DESTINATION_PATH}/overrides
    || true
  - cp ../${SOURCE_PATH}/overrides/*-tier.yaml  ${ENV_DESTINATION_PATH}/overrides
    || true
  - if [ ! -f ${ENV_DESTINATION_PATH}/appconfig.json ]; then cp ../mono_repo/services/schema/main_appconfig.json
    ${ENV_DESTINATION_PATH}/appconfig.json; fi
  - git status
  - echo "Adding changes to Git"
  - git add ${DESTINATION_PATH}
  - git status
  - COUNT=$(git diff --numstat ${STATE_BRANCH} | awk '{added += $1; deleted += $2}
    END {print added + deleted}')
  - |
    if [ "$COUNT" -eq 0 ]; then
      echo "No changes detected under ${CI_PROJECT_NAME}/${SOURCE_PATH}, exiting"
      exit 0
    fi
  - echo "Committing changes"
  - git commit -m "${CI_JOB_NAME}"
  - echo "Pushing changes to remote"
  - git pull --rebase
  - git status
  - "MAX_RETRIES=3\nINITIAL_DELAY=5\nsuccess=false\n\nfor attempt in $(seq 1 $MAX_RETRIES);
    do\n  if git push; then\n    echo -e \"\\e[32mPush successful\\e[0m\"\n    success=true\n
    \   break\n  else\n    echo -e \"\\e[33mPush failed, retrying ($attempt/$MAX_RETRIES)...\\e[0m\"\n
    \   git pull --rebase\n    \n    # Calculate backoff delay (5s, then 10s, then
    20s)\n    BACKOFF_DELAY=$((INITIAL_DELAY * 2**(attempt-1)))\n    echo \"Waiting
    ${BACKOFF_DELAY} seconds before next attempt...\"\n    sleep $BACKOFF_DELAY\n
    \ fi\ndone\n\nif [ \"$success\" != \"true\" ]; then\n  echo -e \"\\e[31mFailed
    to push after $MAX_RETRIES attempts\\e[0m\"\n  exit 1\nfi\n"
  - git status
  - echo "Resources published to argocd mono repo"
  variables:
    DESTINATION_REPO: https://gitlab.com/fireblocks/devops/iac/argocd.git
    DESTINATION_PROJECT_ID: 50521873
    SOURCE_PATH: deployment
    DESTINATION_PATH: services/shell
    STATE_BRANCH: main
    GITLAB_API_URL: https://gitlab.com/api/v4/projects
    TEMPLATE_REF: "$TEMPLATE_REF"
".argocd_sync_resources":
  stage: configure
  retry:
    max: 2
    when:
    - script_failure
  tags:
  - "${GITLAB_RUNNER_TAG}"
  before_script:
  - echo "Install yq & jq from deploy-stage.yml"
  - apk update
  - apk add jq
  - apk add yq
  - |
    if [ ! -d "$SOURCE_PATH" ]; then
      echo "$SOURCE_PATH directory does not exist. Exiting job successfully."
      exit 0
    fi
    echo "$SOURCE_PATH directory exists. Continuing with deployment."
  - apk update
  - apk add curl
  - curl -sSL -o argocd-linux-amd64 https://github.com/argoproj/argo-cd/releases/download/v2.14.9/argocd-linux-amd64
  - install -m 555 argocd-linux-amd64 /usr/local/bin/argocd
  - rm argocd-linux-amd64
  - argocd version --client
  script:
  - echo "Self Service User Guide - https://fireblocks.atlassian.net/wiki/spaces/RD/pages/1413218873/Self+Service+User+Guide"
  - SVC_NAME=$([ "$SERVICE_NAME" ] && echo $SERVICE_NAME || echo $CI_PROJECT_NAME)
  - echo "Syncing resources for ${SVC_NAME} service"
  - ARGOCD_APP_NAME=$(echo "${SVC_NAME}-${ENV}")
  - echo "Refreshing ${ARGOCD_APP_NAME} application"
  - argocd app get ${ARGOCD_APP_NAME} -owide --refresh --insecure --auth-token ${ARGOCD_AUTH_TOKEN}
    --server ${ARGOCD_SERVER}
  - echo "Syncing ${ARGOCD_APP_NAME} application"
  - |
    if [[ "$STRATEGY" == "canary" ]]; then
      argocd app sync --resource '!*:Rollout:*' --resource '!*:Service:*' --prune ${ARGOCD_APP_NAME} --insecure --auth-token ${ARGOCD_AUTH_TOKEN} --server ${ARGOCD_SERVER}
    elif [[ "$STRATEGY" == "in_place" ]]; then
      argocd app sync --resource '!*:Deployment:*' --resource '!*:Service:*' --prune ${ARGOCD_APP_NAME} --insecure --auth-token ${ARGOCD_AUTH_TOKEN} --server ${ARGOCD_SERVER}
    else
      argocd app sync --prune ${ARGOCD_APP_NAME} --insecure --auth-token ${ARGOCD_AUTH_TOKEN} --server ${ARGOCD_SERVER}
    fi
  - echo "Waiting for ${ARGOCD_APP_NAME} application to be synced and healthy"
  - |
    resources_to_sync=$(argocd app get ${ARGOCD_APP_NAME} --insecure --auth-token ${ARGOCD_AUTH_TOKEN} --server ${ARGOCD_SERVER} -o json | jq -r 'select(.status.resources != null) | .status.resources[] | select(.health.status and .kind != "Deployment" and .kind != "Rollout" and .kind != "Ingress" and .kind != "Service") | "\(.group // ""):\(.kind):\(.name)"')
    if [ "x${resources_to_sync}" == "x" ]; then
        echo "There are no resources to sync"
    else
        echo ${resources_to_sync}
        for resource in ${resources_to_sync}; do
            argocd app wait ${ARGOCD_APP_NAME} --resource $resource --health --sync --timeout 600 --loglevel debug --insecure --auth-token ${ARGOCD_AUTH_TOKEN} --server ${ARGOCD_SERVER}
        done
    fi
  variables:
    SOURCE_PATH: deployment
".publish_resources_dev":
  stage: configure
  retry:
    max: 2
    when:
    - script_failure
  tags:
  - "${GITLAB_RUNNER_TAG}"
  before_script:
  - printf "%s:%s\n" DESTINATION_REPO "$DESTINATION_REPO" DESTINATION_PROJECT_ID "$DESTINATION_PROJECT_ID"
    SOURCE_PATH "$SOURCE_PATH" DESTINATION_PATH "$DESTINATION_PATH" STATE_BRANCH "$STATE_BRANCH"
    GITLAB_API_URL "$GITLAB_API_URL"
  - |
    if [ ! -d "$SOURCE_PATH" ]; then
      echo "$SOURCE_PATH directory does not exist. Exiting job successfully."
      exit 0
    fi
    echo "$SOURCE_PATH directory exists. Continuing with deployment."
  - - apk update
    - apk add curl jq yq py3-pip
    - pip3 install --upgrade pip
    - pip3 install yamllint
    - pip3 install yamale --break-system-packages
    - npm install -g ajv-cli
    - echo "Configuring Git"
    - echo "https://argocd-ci-push:${ARGOCD_GITLAB_ACCESS_TOKEN}@gitlab.com" > ~/.git-credentials
    - git remote set-url origin https://argocd-ci-push:${ARGOCD_GITLAB_ACCESS_TOKEN}@gitlab.com/fireblocks/devops/iac/argocd.git
    - git config --global user.email "devops@fireblocks.com"
    - git config --global user.name "argocd-ci-push"
    - git config --global credential.helper store
    - touch .npmrc
    - npm config set --location=user @fireblocks:registry https://gitlab.com/api/v4/packages/npm/
    - npm config set --location=user '//gitlab.com/api/v4/packages/npm/:_authToken'
      "${NPM_REG_TOKEN}"
    - npm config set --location=user '//gitlab.com/api/v4/projects/20565764/packages/npm/:_authToken'
      "${NPM_REG_TOKEN}"
    - echo "@fireblocks:registry=https://gitlab.com/api/v4/packages/npm/">>.npmrc
    - echo "//gitlab.com/api/v4/packages/npm/:_authToken=${NPM_REG_TOKEN}">>.npmrc
    - echo "//gitlab.com/api/v4/projects/20565764/packages/npm/:_authToken=${NPM_REG_TOKEN}">>.npmrc
    - yarn global add @fireblocks/fb-cli
  script:
  - - echo "Self Service User Guide - https://fireblocks.atlassian.net/wiki/spaces/RD/pages/1413218873/Self+Service+User+Guide"
    - SVC_NAME=$([ "$SERVICE_NAME" ] && echo $SERVICE_NAME || echo $CI_PROJECT_NAME)
    - echo "Verifying deployment folder for ${SVC_NAME} service"
    - git clone ${DESTINATION_REPO} mono_repo
    - cd mono_repo
    - git fetch --all
    - git checkout ${STATE_BRANCH}
    - git pull origin ${STATE_BRANCH} --no-rebase
    - cd ../${SOURCE_PATH}
    - |
      # Define the paths
      values_file="values.yaml"

      # Check for values.yaml in the deployment folder
      if [ ! -f "$values_file" ]; then
          echo "Error: The values.yaml file is missing in the ${SOURCE_PATH} folder."
          exit 1
      fi

      echo "Success: All required files are present"
    - |
      # Directory to check
      DIR_TO_CHECK="overrides/"

      # List of allowed files
      ALLOWED_PATTERN=$(printf "|%s" "nonprod-tier.yaml" "prod-tier.yaml" "iac-dev.yaml" "localstack.yaml" "dev1.yaml" "dev2.yaml" "dev3.yaml" "dev4.yaml" "dev5.yaml" "dev6.yaml" "dev7.yaml" "dev8.yaml" "dev9.yaml" "dev10.yaml" "dev11.yaml" "dev11.yaml" "dev12.yaml" "dev13.yaml" "dev14.yaml" "dev15.yaml" "pre1.yaml" "stage.yaml" "sandbox.yaml" "eu-prod.yaml" "eu2-prod.yaml" "bnym-dev.yaml" "bnym-prod.yaml" "us-prod.yaml" | cut -c 2-)

      # Flag to track if there are disallowed files
      DISALLOWED_FOUND=false

      # Check for files in the directory that are not in the allowed list
      for file in "$DIR_TO_CHECK"/*; do
        # Get the base name of the file
        filename=$(basename "$file")

        # Check if the filename is in the allowed list
        if [[ ! $filename =~ ^($ALLOWED_PATTERN)$ ]]; then
          echo "Disallowed file found: $filename"
          DISALLOWED_FOUND=true
        fi
      done

      # Final output
      if $DISALLOWED_FOUND; then
        echo "Some files are not allowed."
        exit 1
      else
        echo "All files are allowed."
      fi
    - echo "Linting deployment yaml files"
    - cp ../mono_repo/services/schema/*.yaml .
    - cp ../mono_repo/services/schema/appconfig_schema.json .
    - cp ../mono_repo/services/schema/main_appconfig.json appconfig.json
    - cp ../mono_repo/services/schema/yamllint_rules.yaml yamllint_rules.yaml
    - yamllint --list-files **/*.yaml *.yaml
    - yamllint -s **/*.yaml *.yaml -c yamllint_rules.yaml
    - echo "Validating deployment yaml schema"
    - yamale -s base_values_schema.yaml values.yaml
    - yamale -s tier_values_schema.yaml overrides/prod-tier.yaml
    - yamale -s tier_values_schema.yaml overrides/nonprod-tier.yaml
    - |
      # Iterate over all yaml files in the overrides folder
      for file in overrides/*.yaml; do
          # Extract the filename from the path
          filename=$(basename -- "$file")

          # Check if the file is not prod-tier.yaml or nonprod-tier.yaml
          if [[ "$filename" != "prod-tier.yaml" ]] && [[ "$filename" != "nonprod-tier.yaml" ]]; then
              # Run yamale command on the file
              yamale -s env_values_schema.yaml "$file"
          fi
      done
    - "# Iterate over all yaml files in the overrides folder - validate_resources.sh\nif
      [[ -v ENGINE && \"$ENGINE\" == \"argocd\" ]]; then\n  export CD_INFRA_PROJECT_ID=61508954\n
      \ curl --header \"PRIVATE-TOKEN: $CD_CPU_RAM_REQUEST_LIMIT_READ_ONLY\"  \"https://gitlab.com/api/v4/projects/$CD_INFRA_PROJECT_ID/repository/files/ci-infra%2Fscripts%2Fvalidate_resources.sh/raw?ref=main\"
      -o \"$CI_PROJECT_DIR/validate_resources.sh\"\n  echo \"chmod +x $CI_PROJECT_DIR/validate_resources.sh\"
      \n  chmod +x \"$CI_PROJECT_DIR/validate_resources.sh\"\n  echo \"Searching for
      environments values files...\" \n  ENV_FILES_LIST=$(yamllint --list-files **/*.yaml
      *.yaml | grep -vE 'env_values_schema\\.yaml|tier_values_schema\\.yaml|base_values_schema\\.yaml|yamllint_rules\\.yaml|.*prod-tier\\.yaml|values.yaml'
      || true)\n  if [[ -n \"$ENV_FILES_LIST\" ]]; then\n    echo \"Found environments
      values files\"\n    while IFS= read -r file; do\n      filename=$(basename --
      \"$file\")\n      if [[ \"$filename\" =~ ^(dev[1-9]|dev10|stage|pre1).yaml$
      ]]; then\n        tier_file=\"overrides/nonprod-tier.yaml\"\n      else\n        tier_file=\"overrides/prod-tier.yaml\"
      \ \n      fi\n      echo \"values.yaml <-- $tier_file <-- $file\"\n      yq
      eval-all '. as $item ireduce ({}; . * $item)' values.yaml \"$tier_file\" \"$file\"
      | bash \"$CI_PROJECT_DIR/validate_resources.sh\" -\n    done <<< \"$ENV_FILES_LIST\"\n
      \ else\n    echo \"No environments values files were found. Continuing to the
      tier files.\"\n  fi\necho \"values.yaml <-- overrides/nonprod-tier.yaml\"\nyq
      eval-all '. as $item ireduce ({}; . * $item)' values.yaml overrides/nonprod-tier.yaml
      | bash \"$CI_PROJECT_DIR/validate_resources.sh\" -\necho \"values.yaml <-- overrides/prod-tier.yaml\"
      \nyq eval-all '. as $item ireduce ({}; . * $item)' values.yaml overrides/prod-tier.yaml
      | bash \"$CI_PROJECT_DIR/validate_resources.sh\" -\nelse\n  echo \"Skipping
      resource validation: ENGINE is not set to 'argocd'.\"\nfi\n"
    - ajv validate -s appconfig_schema.json -d appconfig.json
    - echo "Resources verified successfully"
    - echo "Validate filter_policy if exists - should be a valid JSON object"
    - fb deployment:validate . --filter-policy
  - cd ../mono_repo
  - ENV_DESTINATION_PATH=$(echo "${DESTINATION_PATH}/${SVC_NAME}/${ENV}")
  - echo "Copying ${SOURCE_PATH} folder from ${SVC_NAME} service to argocd mono repo
    destination folder at ${ENV_DESTINATION_PATH}"
  - mkdir -pv ${ENV_DESTINATION_PATH}/overrides
  - rm ${ENV_DESTINATION_PATH}/overrides/${ENV}.yaml || true
  - cp  ../${SOURCE_PATH}/values.yaml ${ENV_DESTINATION_PATH}
  - cp ../${SOURCE_PATH}/overrides/${ENV}.yaml  ${ENV_DESTINATION_PATH}/overrides
    || true
  - cp ../${SOURCE_PATH}/overrides/*-tier.yaml  ${ENV_DESTINATION_PATH}/overrides
    || true
  - if [ ! -f ${ENV_DESTINATION_PATH}/appconfig.json ]; then cp ../mono_repo/services/schema/main_appconfig.json
    ${ENV_DESTINATION_PATH}/appconfig.json; fi
  - git status
  - echo "Adding changes to Git"
  - git add ${DESTINATION_PATH}
  - git status
  - COUNT=$(git diff --numstat ${STATE_BRANCH} | awk '{added += $1; deleted += $2}
    END {print added + deleted}')
  - |
    if [ "$COUNT" -eq 0 ]; then
      echo "No changes detected under ${CI_PROJECT_NAME}/${SOURCE_PATH}, exiting"
      exit 0
    fi
  - echo "Committing changes"
  - git commit -m "${CI_JOB_NAME}"
  - echo "Pushing changes to remote"
  - git pull --rebase
  - git status
  - "MAX_RETRIES=3\nINITIAL_DELAY=5\nsuccess=false\n\nfor attempt in $(seq 1 $MAX_RETRIES);
    do\n  if git push; then\n    echo -e \"\\e[32mPush successful\\e[0m\"\n    success=true\n
    \   break\n  else\n    echo -e \"\\e[33mPush failed, retrying ($attempt/$MAX_RETRIES)...\\e[0m\"\n
    \   git pull --rebase\n    \n    # Calculate backoff delay (5s, then 10s, then
    20s)\n    BACKOFF_DELAY=$((INITIAL_DELAY * 2**(attempt-1)))\n    echo \"Waiting
    ${BACKOFF_DELAY} seconds before next attempt...\"\n    sleep $BACKOFF_DELAY\n
    \ fi\ndone\n\nif [ \"$success\" != \"true\" ]; then\n  echo -e \"\\e[31mFailed
    to push after $MAX_RETRIES attempts\\e[0m\"\n  exit 1\nfi\n"
  - git status
  - echo "Resources published to argocd mono repo"
  variables:
    DESTINATION_REPO: https://gitlab.com/fireblocks/devops/iac/argocd.git
    DESTINATION_PROJECT_ID: 50521873
    SOURCE_PATH: deployment
    DESTINATION_PATH: services/shell
    STATE_BRANCH: main
    GITLAB_API_URL: https://gitlab.com/api/v4/projects
    TEMPLATE_REF: "$TEMPLATE_REF"
    GITLAB_RUNNER_TAG: devx-application-gitlab-runner
  extends:
  - ".publish_resources"
".publish_resources_prod":
  stage: configure
  retry:
    max: 2
    when:
    - script_failure
  tags:
  - "${GITLAB_RUNNER_TAG}"
  before_script:
  - printf "%s:%s\n" DESTINATION_REPO "$DESTINATION_REPO" DESTINATION_PROJECT_ID "$DESTINATION_PROJECT_ID"
    SOURCE_PATH "$SOURCE_PATH" DESTINATION_PATH "$DESTINATION_PATH" STATE_BRANCH "$STATE_BRANCH"
    GITLAB_API_URL "$GITLAB_API_URL"
  - |
    if [ ! -d "$SOURCE_PATH" ]; then
      echo "$SOURCE_PATH directory does not exist. Exiting job successfully."
      exit 0
    fi
    echo "$SOURCE_PATH directory exists. Continuing with deployment."
  - - apk update
    - apk add curl jq yq py3-pip
    - pip3 install --upgrade pip
    - pip3 install yamllint
    - pip3 install yamale --break-system-packages
    - npm install -g ajv-cli
    - echo "Configuring Git"
    - echo "https://argocd-ci-push:${ARGOCD_GITLAB_ACCESS_TOKEN}@gitlab.com" > ~/.git-credentials
    - git remote set-url origin https://argocd-ci-push:${ARGOCD_GITLAB_ACCESS_TOKEN}@gitlab.com/fireblocks/devops/iac/argocd.git
    - git config --global user.email "devops@fireblocks.com"
    - git config --global user.name "argocd-ci-push"
    - git config --global credential.helper store
    - touch .npmrc
    - npm config set --location=user @fireblocks:registry https://gitlab.com/api/v4/packages/npm/
    - npm config set --location=user '//gitlab.com/api/v4/packages/npm/:_authToken'
      "${NPM_REG_TOKEN}"
    - npm config set --location=user '//gitlab.com/api/v4/projects/20565764/packages/npm/:_authToken'
      "${NPM_REG_TOKEN}"
    - echo "@fireblocks:registry=https://gitlab.com/api/v4/packages/npm/">>.npmrc
    - echo "//gitlab.com/api/v4/packages/npm/:_authToken=${NPM_REG_TOKEN}">>.npmrc
    - echo "//gitlab.com/api/v4/projects/20565764/packages/npm/:_authToken=${NPM_REG_TOKEN}">>.npmrc
    - yarn global add @fireblocks/fb-cli
  script:
  - - echo "Self Service User Guide - https://fireblocks.atlassian.net/wiki/spaces/RD/pages/1413218873/Self+Service+User+Guide"
    - SVC_NAME=$([ "$SERVICE_NAME" ] && echo $SERVICE_NAME || echo $CI_PROJECT_NAME)
    - echo "Verifying deployment folder for ${SVC_NAME} service"
    - git clone ${DESTINATION_REPO} mono_repo
    - cd mono_repo
    - git fetch --all
    - git checkout ${STATE_BRANCH}
    - git pull origin ${STATE_BRANCH} --no-rebase
    - cd ../${SOURCE_PATH}
    - |
      # Define the paths
      values_file="values.yaml"

      # Check for values.yaml in the deployment folder
      if [ ! -f "$values_file" ]; then
          echo "Error: The values.yaml file is missing in the ${SOURCE_PATH} folder."
          exit 1
      fi

      echo "Success: All required files are present"
    - |
      # Directory to check
      DIR_TO_CHECK="overrides/"

      # List of allowed files
      ALLOWED_PATTERN=$(printf "|%s" "nonprod-tier.yaml" "prod-tier.yaml" "iac-dev.yaml" "localstack.yaml" "dev1.yaml" "dev2.yaml" "dev3.yaml" "dev4.yaml" "dev5.yaml" "dev6.yaml" "dev7.yaml" "dev8.yaml" "dev9.yaml" "dev10.yaml" "dev11.yaml" "dev11.yaml" "dev12.yaml" "dev13.yaml" "dev14.yaml" "dev15.yaml" "pre1.yaml" "stage.yaml" "sandbox.yaml" "eu-prod.yaml" "eu2-prod.yaml" "bnym-dev.yaml" "bnym-prod.yaml" "us-prod.yaml" | cut -c 2-)

      # Flag to track if there are disallowed files
      DISALLOWED_FOUND=false

      # Check for files in the directory that are not in the allowed list
      for file in "$DIR_TO_CHECK"/*; do
        # Get the base name of the file
        filename=$(basename "$file")

        # Check if the filename is in the allowed list
        if [[ ! $filename =~ ^($ALLOWED_PATTERN)$ ]]; then
          echo "Disallowed file found: $filename"
          DISALLOWED_FOUND=true
        fi
      done

      # Final output
      if $DISALLOWED_FOUND; then
        echo "Some files are not allowed."
        exit 1
      else
        echo "All files are allowed."
      fi
    - echo "Linting deployment yaml files"
    - cp ../mono_repo/services/schema/*.yaml .
    - cp ../mono_repo/services/schema/appconfig_schema.json .
    - cp ../mono_repo/services/schema/main_appconfig.json appconfig.json
    - cp ../mono_repo/services/schema/yamllint_rules.yaml yamllint_rules.yaml
    - yamllint --list-files **/*.yaml *.yaml
    - yamllint -s **/*.yaml *.yaml -c yamllint_rules.yaml
    - echo "Validating deployment yaml schema"
    - yamale -s base_values_schema.yaml values.yaml
    - yamale -s tier_values_schema.yaml overrides/prod-tier.yaml
    - yamale -s tier_values_schema.yaml overrides/nonprod-tier.yaml
    - |
      # Iterate over all yaml files in the overrides folder
      for file in overrides/*.yaml; do
          # Extract the filename from the path
          filename=$(basename -- "$file")

          # Check if the file is not prod-tier.yaml or nonprod-tier.yaml
          if [[ "$filename" != "prod-tier.yaml" ]] && [[ "$filename" != "nonprod-tier.yaml" ]]; then
              # Run yamale command on the file
              yamale -s env_values_schema.yaml "$file"
          fi
      done
    - "# Iterate over all yaml files in the overrides folder - validate_resources.sh\nif
      [[ -v ENGINE && \"$ENGINE\" == \"argocd\" ]]; then\n  export CD_INFRA_PROJECT_ID=61508954\n
      \ curl --header \"PRIVATE-TOKEN: $CD_CPU_RAM_REQUEST_LIMIT_READ_ONLY\"  \"https://gitlab.com/api/v4/projects/$CD_INFRA_PROJECT_ID/repository/files/ci-infra%2Fscripts%2Fvalidate_resources.sh/raw?ref=main\"
      -o \"$CI_PROJECT_DIR/validate_resources.sh\"\n  echo \"chmod +x $CI_PROJECT_DIR/validate_resources.sh\"
      \n  chmod +x \"$CI_PROJECT_DIR/validate_resources.sh\"\n  echo \"Searching for
      environments values files...\" \n  ENV_FILES_LIST=$(yamllint --list-files **/*.yaml
      *.yaml | grep -vE 'env_values_schema\\.yaml|tier_values_schema\\.yaml|base_values_schema\\.yaml|yamllint_rules\\.yaml|.*prod-tier\\.yaml|values.yaml'
      || true)\n  if [[ -n \"$ENV_FILES_LIST\" ]]; then\n    echo \"Found environments
      values files\"\n    while IFS= read -r file; do\n      filename=$(basename --
      \"$file\")\n      if [[ \"$filename\" =~ ^(dev[1-9]|dev10|stage|pre1).yaml$
      ]]; then\n        tier_file=\"overrides/nonprod-tier.yaml\"\n      else\n        tier_file=\"overrides/prod-tier.yaml\"
      \ \n      fi\n      echo \"values.yaml <-- $tier_file <-- $file\"\n      yq
      eval-all '. as $item ireduce ({}; . * $item)' values.yaml \"$tier_file\" \"$file\"
      | bash \"$CI_PROJECT_DIR/validate_resources.sh\" -\n    done <<< \"$ENV_FILES_LIST\"\n
      \ else\n    echo \"No environments values files were found. Continuing to the
      tier files.\"\n  fi\necho \"values.yaml <-- overrides/nonprod-tier.yaml\"\nyq
      eval-all '. as $item ireduce ({}; . * $item)' values.yaml overrides/nonprod-tier.yaml
      | bash \"$CI_PROJECT_DIR/validate_resources.sh\" -\necho \"values.yaml <-- overrides/prod-tier.yaml\"
      \nyq eval-all '. as $item ireduce ({}; . * $item)' values.yaml overrides/prod-tier.yaml
      | bash \"$CI_PROJECT_DIR/validate_resources.sh\" -\nelse\n  echo \"Skipping
      resource validation: ENGINE is not set to 'argocd'.\"\nfi\n"
    - ajv validate -s appconfig_schema.json -d appconfig.json
    - echo "Resources verified successfully"
    - echo "Validate filter_policy if exists - should be a valid JSON object"
    - fb deployment:validate . --filter-policy
  - cd ../mono_repo
  - ENV_DESTINATION_PATH=$(echo "${DESTINATION_PATH}/${SVC_NAME}/${ENV}")
  - echo "Copying ${SOURCE_PATH} folder from ${SVC_NAME} service to argocd mono repo
    destination folder at ${ENV_DESTINATION_PATH}"
  - mkdir -pv ${ENV_DESTINATION_PATH}/overrides
  - rm ${ENV_DESTINATION_PATH}/overrides/${ENV}.yaml || true
  - cp  ../${SOURCE_PATH}/values.yaml ${ENV_DESTINATION_PATH}
  - cp ../${SOURCE_PATH}/overrides/${ENV}.yaml  ${ENV_DESTINATION_PATH}/overrides
    || true
  - cp ../${SOURCE_PATH}/overrides/*-tier.yaml  ${ENV_DESTINATION_PATH}/overrides
    || true
  - if [ ! -f ${ENV_DESTINATION_PATH}/appconfig.json ]; then cp ../mono_repo/services/schema/main_appconfig.json
    ${ENV_DESTINATION_PATH}/appconfig.json; fi
  - git status
  - echo "Adding changes to Git"
  - git add ${DESTINATION_PATH}
  - git status
  - COUNT=$(git diff --numstat ${STATE_BRANCH} | awk '{added += $1; deleted += $2}
    END {print added + deleted}')
  - |
    if [ "$COUNT" -eq 0 ]; then
      echo "No changes detected under ${CI_PROJECT_NAME}/${SOURCE_PATH}, exiting"
      exit 0
    fi
  - echo "Committing changes"
  - git commit -m "${CI_JOB_NAME}"
  - echo "Pushing changes to remote"
  - git pull --rebase
  - git status
  - "MAX_RETRIES=3\nINITIAL_DELAY=5\nsuccess=false\n\nfor attempt in $(seq 1 $MAX_RETRIES);
    do\n  if git push; then\n    echo -e \"\\e[32mPush successful\\e[0m\"\n    success=true\n
    \   break\n  else\n    echo -e \"\\e[33mPush failed, retrying ($attempt/$MAX_RETRIES)...\\e[0m\"\n
    \   git pull --rebase\n    \n    # Calculate backoff delay (5s, then 10s, then
    20s)\n    BACKOFF_DELAY=$((INITIAL_DELAY * 2**(attempt-1)))\n    echo \"Waiting
    ${BACKOFF_DELAY} seconds before next attempt...\"\n    sleep $BACKOFF_DELAY\n
    \ fi\ndone\n\nif [ \"$success\" != \"true\" ]; then\n  echo -e \"\\e[31mFailed
    to push after $MAX_RETRIES attempts\\e[0m\"\n  exit 1\nfi\n"
  - git status
  - echo "Resources published to argocd mono repo"
  variables:
    DESTINATION_REPO: https://gitlab.com/fireblocks/devops/iac/argocd.git
    DESTINATION_PROJECT_ID: 50521873
    SOURCE_PATH: deployment
    DESTINATION_PATH: services/shell
    STATE_BRANCH: main
    GITLAB_API_URL: https://gitlab.com/api/v4/projects
    TEMPLATE_REF: "$TEMPLATE_REF"
    GITLAB_RUNNER_TAG: devx-application-gitlab-runner
  extends:
  - ".publish_resources"
".argocd_sync_resources_dev":
  stage: configure
  retry:
    max: 2
    when:
    - script_failure
  tags:
  - "${GITLAB_RUNNER_TAG}"
  before_script:
  - echo "Install yq & jq from deploy-stage.yml"
  - apk update
  - apk add jq
  - apk add yq
  - |
    if [ ! -d "$SOURCE_PATH" ]; then
      echo "$SOURCE_PATH directory does not exist. Exiting job successfully."
      exit 0
    fi
    echo "$SOURCE_PATH directory exists. Continuing with deployment."
  - apk update
  - apk add curl
  - curl -sSL -o argocd-linux-amd64 https://github.com/argoproj/argo-cd/releases/download/v2.14.9/argocd-linux-amd64
  - install -m 555 argocd-linux-amd64 /usr/local/bin/argocd
  - rm argocd-linux-amd64
  - argocd version --client
  script:
  - echo "Self Service User Guide - https://fireblocks.atlassian.net/wiki/spaces/RD/pages/1413218873/Self+Service+User+Guide"
  - SVC_NAME=$([ "$SERVICE_NAME" ] && echo $SERVICE_NAME || echo $CI_PROJECT_NAME)
  - echo "Syncing resources for ${SVC_NAME} service"
  - ARGOCD_APP_NAME=$(echo "${SVC_NAME}-${ENV}")
  - echo "Refreshing ${ARGOCD_APP_NAME} application"
  - argocd app get ${ARGOCD_APP_NAME} -owide --refresh --insecure --auth-token ${ARGOCD_AUTH_TOKEN}
    --server ${ARGOCD_SERVER}
  - echo "Syncing ${ARGOCD_APP_NAME} application"
  - |
    if [[ "$STRATEGY" == "canary" ]]; then
      argocd app sync --resource '!*:Rollout:*' --resource '!*:Service:*' --prune ${ARGOCD_APP_NAME} --insecure --auth-token ${ARGOCD_AUTH_TOKEN} --server ${ARGOCD_SERVER}
    elif [[ "$STRATEGY" == "in_place" ]]; then
      argocd app sync --resource '!*:Deployment:*' --resource '!*:Service:*' --prune ${ARGOCD_APP_NAME} --insecure --auth-token ${ARGOCD_AUTH_TOKEN} --server ${ARGOCD_SERVER}
    else
      argocd app sync --prune ${ARGOCD_APP_NAME} --insecure --auth-token ${ARGOCD_AUTH_TOKEN} --server ${ARGOCD_SERVER}
    fi
  - echo "Waiting for ${ARGOCD_APP_NAME} application to be synced and healthy"
  - |
    resources_to_sync=$(argocd app get ${ARGOCD_APP_NAME} --insecure --auth-token ${ARGOCD_AUTH_TOKEN} --server ${ARGOCD_SERVER} -o json | jq -r 'select(.status.resources != null) | .status.resources[] | select(.health.status and .kind != "Deployment" and .kind != "Rollout" and .kind != "Ingress" and .kind != "Service") | "\(.group // ""):\(.kind):\(.name)"')
    if [ "x${resources_to_sync}" == "x" ]; then
        echo "There are no resources to sync"
    else
        echo ${resources_to_sync}
        for resource in ${resources_to_sync}; do
            argocd app wait ${ARGOCD_APP_NAME} --resource $resource --health --sync --timeout 600 --loglevel debug --insecure --auth-token ${ARGOCD_AUTH_TOKEN} --server ${ARGOCD_SERVER}
        done
    fi
  variables:
    SOURCE_PATH: deployment
    GITLAB_RUNNER_TAG: devx-application-gitlab-runner
    ARGOCD_SERVER: "${ARGOCD_NONPROD_SERVER}"
    ARGOCD_AUTH_TOKEN: "${ARGOCD_NONPROD_SHELL_AUTH_TOKEN}"
  extends:
  - ".argocd_sync_resources"
".argocd_sync_resources_prod":
  stage: configure
  retry:
    max: 2
    when:
    - script_failure
  tags:
  - "${GITLAB_RUNNER_TAG}"
  before_script:
  - echo "Install yq & jq from deploy-stage.yml"
  - apk update
  - apk add jq
  - apk add yq
  - |
    if [ ! -d "$SOURCE_PATH" ]; then
      echo "$SOURCE_PATH directory does not exist. Exiting job successfully."
      exit 0
    fi
    echo "$SOURCE_PATH directory exists. Continuing with deployment."
  - apk update
  - apk add curl
  - curl -sSL -o argocd-linux-amd64 https://github.com/argoproj/argo-cd/releases/download/v2.14.9/argocd-linux-amd64
  - install -m 555 argocd-linux-amd64 /usr/local/bin/argocd
  - rm argocd-linux-amd64
  - argocd version --client
  script:
  - echo "Self Service User Guide - https://fireblocks.atlassian.net/wiki/spaces/RD/pages/1413218873/Self+Service+User+Guide"
  - SVC_NAME=$([ "$SERVICE_NAME" ] && echo $SERVICE_NAME || echo $CI_PROJECT_NAME)
  - echo "Syncing resources for ${SVC_NAME} service"
  - ARGOCD_APP_NAME=$(echo "${SVC_NAME}-${ENV}")
  - echo "Refreshing ${ARGOCD_APP_NAME} application"
  - argocd app get ${ARGOCD_APP_NAME} -owide --refresh --insecure --auth-token ${ARGOCD_AUTH_TOKEN}
    --server ${ARGOCD_SERVER}
  - echo "Syncing ${ARGOCD_APP_NAME} application"
  - |
    if [[ "$STRATEGY" == "canary" ]]; then
      argocd app sync --resource '!*:Rollout:*' --resource '!*:Service:*' --prune ${ARGOCD_APP_NAME} --insecure --auth-token ${ARGOCD_AUTH_TOKEN} --server ${ARGOCD_SERVER}
    elif [[ "$STRATEGY" == "in_place" ]]; then
      argocd app sync --resource '!*:Deployment:*' --resource '!*:Service:*' --prune ${ARGOCD_APP_NAME} --insecure --auth-token ${ARGOCD_AUTH_TOKEN} --server ${ARGOCD_SERVER}
    else
      argocd app sync --prune ${ARGOCD_APP_NAME} --insecure --auth-token ${ARGOCD_AUTH_TOKEN} --server ${ARGOCD_SERVER}
    fi
  - echo "Waiting for ${ARGOCD_APP_NAME} application to be synced and healthy"
  - |
    resources_to_sync=$(argocd app get ${ARGOCD_APP_NAME} --insecure --auth-token ${ARGOCD_AUTH_TOKEN} --server ${ARGOCD_SERVER} -o json | jq -r 'select(.status.resources != null) | .status.resources[] | select(.health.status and .kind != "Deployment" and .kind != "Rollout" and .kind != "Ingress" and .kind != "Service") | "\(.group // ""):\(.kind):\(.name)"')
    if [ "x${resources_to_sync}" == "x" ]; then
        echo "There are no resources to sync"
    else
        echo ${resources_to_sync}
        for resource in ${resources_to_sync}; do
            argocd app wait ${ARGOCD_APP_NAME} --resource $resource --health --sync --timeout 600 --loglevel debug --insecure --auth-token ${ARGOCD_AUTH_TOKEN} --server ${ARGOCD_SERVER}
        done
    fi
  variables:
    SOURCE_PATH: deployment
    GITLAB_RUNNER_TAG: devx-application-gitlab-runner
    ARGOCD_SERVER: "${ARGOCD_PROD_SERVER}"
    ARGOCD_AUTH_TOKEN: "${ARGOCD_PROD_SHELL_AUTH_TOKEN}"
  extends:
  - ".argocd_sync_resources"
".env_status_check_pre1":
  image: registry.gitlab.com/fireblocks/shell/infra/images/node-infra-20
  stage: configure
  allow_failure: true
  when: always
  needs: []
  retry: 2
  tags:
  - shell-application-gitlab-runner
  before_script:
  - touch .npmrc
  - npm config set --location=user @fireblocks:registry https://gitlab.com/api/v4/packages/npm/
  - npm config set --location=user '//gitlab.com/api/v4/packages/npm/:_authToken'
    "${NPM_REG_TOKEN}"
  - npm config set --location=user '//gitlab.com/api/v4/projects/20565764/packages/npm/:_authToken'
    "${NPM_REG_TOKEN}"
  - echo "@fireblocks:registry=https://gitlab.com/api/v4/packages/npm/">>.npmrc
  - echo "//gitlab.com/api/v4/packages/npm/:_authToken=${NPM_REG_TOKEN}">>.npmrc
  - echo "//gitlab.com/api/v4/projects/20565764/packages/npm/:_authToken=${NPM_REG_TOKEN}">>.npmrc
  - yarn global add @fireblocks/fb-cli
  script:
  - echo "Checking last integration tests and e2e jobs status in ${env}"
  - fb check-env-status --env=${env} --crashOnFail=true
  - echo "The environment ${env} is stable and ready for deployment"
  rules:
  - if: "$CI_COMMIT_BRANCH"
    when: manual
  - when: never
  extends: ".env-status-check"
  variables:
    env: pre1
".publish_resources_localstack":
  stage: configure
  retry:
    max: 2
    when:
    - script_failure
  tags:
  - "${GITLAB_RUNNER_TAG}"
  before_script:
  - printf "%s:%s\n" DESTINATION_REPO "$DESTINATION_REPO" DESTINATION_PROJECT_ID "$DESTINATION_PROJECT_ID"
    SOURCE_PATH "$SOURCE_PATH" DESTINATION_PATH "$DESTINATION_PATH" STATE_BRANCH "$STATE_BRANCH"
    GITLAB_API_URL "$GITLAB_API_URL"
  - |
    if [ ! -d "$SOURCE_PATH" ]; then
      echo "$SOURCE_PATH directory does not exist. Exiting job successfully."
      exit 0
    fi
    echo "$SOURCE_PATH directory exists. Continuing with deployment."
  - - apk update
    - apk add curl jq yq py3-pip
    - pip3 install --upgrade pip
    - pip3 install yamllint
    - pip3 install yamale --break-system-packages
    - npm install -g ajv-cli
    - echo "Configuring Git"
    - echo "https://argocd-ci-push:${ARGOCD_GITLAB_ACCESS_TOKEN}@gitlab.com" > ~/.git-credentials
    - git remote set-url origin https://argocd-ci-push:${ARGOCD_GITLAB_ACCESS_TOKEN}@gitlab.com/fireblocks/devops/iac/argocd.git
    - git config --global user.email "devops@fireblocks.com"
    - git config --global user.name "argocd-ci-push"
    - git config --global credential.helper store
    - touch .npmrc
    - npm config set --location=user @fireblocks:registry https://gitlab.com/api/v4/packages/npm/
    - npm config set --location=user '//gitlab.com/api/v4/packages/npm/:_authToken'
      "${NPM_REG_TOKEN}"
    - npm config set --location=user '//gitlab.com/api/v4/projects/20565764/packages/npm/:_authToken'
      "${NPM_REG_TOKEN}"
    - echo "@fireblocks:registry=https://gitlab.com/api/v4/packages/npm/">>.npmrc
    - echo "//gitlab.com/api/v4/packages/npm/:_authToken=${NPM_REG_TOKEN}">>.npmrc
    - echo "//gitlab.com/api/v4/projects/20565764/packages/npm/:_authToken=${NPM_REG_TOKEN}">>.npmrc
    - yarn global add @fireblocks/fb-cli
  script:
  - - echo "Self Service User Guide - https://fireblocks.atlassian.net/wiki/spaces/RD/pages/1413218873/Self+Service+User+Guide"
    - SVC_NAME=$([ "$SERVICE_NAME" ] && echo $SERVICE_NAME || echo $CI_PROJECT_NAME)
    - echo "Verifying deployment folder for ${SVC_NAME} service"
    - git clone ${DESTINATION_REPO} mono_repo
    - cd mono_repo
    - git fetch --all
    - git checkout ${STATE_BRANCH}
    - git pull origin ${STATE_BRANCH} --no-rebase
    - cd ../${SOURCE_PATH}
    - |
      # Define the paths
      values_file="values.yaml"

      # Check for values.yaml in the deployment folder
      if [ ! -f "$values_file" ]; then
          echo "Error: The values.yaml file is missing in the ${SOURCE_PATH} folder."
          exit 1
      fi

      echo "Success: All required files are present"
    - |
      # Directory to check
      DIR_TO_CHECK="overrides/"

      # List of allowed files
      ALLOWED_PATTERN=$(printf "|%s" "nonprod-tier.yaml" "prod-tier.yaml" "iac-dev.yaml" "localstack.yaml" "dev1.yaml" "dev2.yaml" "dev3.yaml" "dev4.yaml" "dev5.yaml" "dev6.yaml" "dev7.yaml" "dev8.yaml" "dev9.yaml" "dev10.yaml" "dev11.yaml" "dev11.yaml" "dev12.yaml" "dev13.yaml" "dev14.yaml" "dev15.yaml" "pre1.yaml" "stage.yaml" "sandbox.yaml" "eu-prod.yaml" "eu2-prod.yaml" "bnym-dev.yaml" "bnym-prod.yaml" "us-prod.yaml" | cut -c 2-)

      # Flag to track if there are disallowed files
      DISALLOWED_FOUND=false

      # Check for files in the directory that are not in the allowed list
      for file in "$DIR_TO_CHECK"/*; do
        # Get the base name of the file
        filename=$(basename "$file")

        # Check if the filename is in the allowed list
        if [[ ! $filename =~ ^($ALLOWED_PATTERN)$ ]]; then
          echo "Disallowed file found: $filename"
          DISALLOWED_FOUND=true
        fi
      done

      # Final output
      if $DISALLOWED_FOUND; then
        echo "Some files are not allowed."
        exit 1
      else
        echo "All files are allowed."
      fi
    - echo "Linting deployment yaml files"
    - cp ../mono_repo/services/schema/*.yaml .
    - cp ../mono_repo/services/schema/appconfig_schema.json .
    - cp ../mono_repo/services/schema/main_appconfig.json appconfig.json
    - cp ../mono_repo/services/schema/yamllint_rules.yaml yamllint_rules.yaml
    - yamllint --list-files **/*.yaml *.yaml
    - yamllint -s **/*.yaml *.yaml -c yamllint_rules.yaml
    - echo "Validating deployment yaml schema"
    - yamale -s base_values_schema.yaml values.yaml
    - yamale -s tier_values_schema.yaml overrides/prod-tier.yaml
    - yamale -s tier_values_schema.yaml overrides/nonprod-tier.yaml
    - |
      # Iterate over all yaml files in the overrides folder
      for file in overrides/*.yaml; do
          # Extract the filename from the path
          filename=$(basename -- "$file")

          # Check if the file is not prod-tier.yaml or nonprod-tier.yaml
          if [[ "$filename" != "prod-tier.yaml" ]] && [[ "$filename" != "nonprod-tier.yaml" ]]; then
              # Run yamale command on the file
              yamale -s env_values_schema.yaml "$file"
          fi
      done
    - "# Iterate over all yaml files in the overrides folder - validate_resources.sh\nif
      [[ -v ENGINE && \"$ENGINE\" == \"argocd\" ]]; then\n  export CD_INFRA_PROJECT_ID=61508954\n
      \ curl --header \"PRIVATE-TOKEN: $CD_CPU_RAM_REQUEST_LIMIT_READ_ONLY\"  \"https://gitlab.com/api/v4/projects/$CD_INFRA_PROJECT_ID/repository/files/ci-infra%2Fscripts%2Fvalidate_resources.sh/raw?ref=main\"
      -o \"$CI_PROJECT_DIR/validate_resources.sh\"\n  echo \"chmod +x $CI_PROJECT_DIR/validate_resources.sh\"
      \n  chmod +x \"$CI_PROJECT_DIR/validate_resources.sh\"\n  echo \"Searching for
      environments values files...\" \n  ENV_FILES_LIST=$(yamllint --list-files **/*.yaml
      *.yaml | grep -vE 'env_values_schema\\.yaml|tier_values_schema\\.yaml|base_values_schema\\.yaml|yamllint_rules\\.yaml|.*prod-tier\\.yaml|values.yaml'
      || true)\n  if [[ -n \"$ENV_FILES_LIST\" ]]; then\n    echo \"Found environments
      values files\"\n    while IFS= read -r file; do\n      filename=$(basename --
      \"$file\")\n      if [[ \"$filename\" =~ ^(dev[1-9]|dev10|stage|pre1).yaml$
      ]]; then\n        tier_file=\"overrides/nonprod-tier.yaml\"\n      else\n        tier_file=\"overrides/prod-tier.yaml\"
      \ \n      fi\n      echo \"values.yaml <-- $tier_file <-- $file\"\n      yq
      eval-all '. as $item ireduce ({}; . * $item)' values.yaml \"$tier_file\" \"$file\"
      | bash \"$CI_PROJECT_DIR/validate_resources.sh\" -\n    done <<< \"$ENV_FILES_LIST\"\n
      \ else\n    echo \"No environments values files were found. Continuing to the
      tier files.\"\n  fi\necho \"values.yaml <-- overrides/nonprod-tier.yaml\"\nyq
      eval-all '. as $item ireduce ({}; . * $item)' values.yaml overrides/nonprod-tier.yaml
      | bash \"$CI_PROJECT_DIR/validate_resources.sh\" -\necho \"values.yaml <-- overrides/prod-tier.yaml\"
      \nyq eval-all '. as $item ireduce ({}; . * $item)' values.yaml overrides/prod-tier.yaml
      | bash \"$CI_PROJECT_DIR/validate_resources.sh\" -\nelse\n  echo \"Skipping
      resource validation: ENGINE is not set to 'argocd'.\"\nfi\n"
    - ajv validate -s appconfig_schema.json -d appconfig.json
    - echo "Resources verified successfully"
    - echo "Validate filter_policy if exists - should be a valid JSON object"
    - fb deployment:validate . --filter-policy
  - cd ../mono_repo
  - ENV_DESTINATION_PATH=$(echo "${DESTINATION_PATH}/${SVC_NAME}/${ENV}")
  - echo "Copying ${SOURCE_PATH} folder from ${SVC_NAME} service to argocd mono repo
    destination folder at ${ENV_DESTINATION_PATH}"
  - mkdir -pv ${ENV_DESTINATION_PATH}/overrides
  - rm ${ENV_DESTINATION_PATH}/overrides/${ENV}.yaml || true
  - cp  ../${SOURCE_PATH}/values.yaml ${ENV_DESTINATION_PATH}
  - cp ../${SOURCE_PATH}/overrides/${ENV}.yaml  ${ENV_DESTINATION_PATH}/overrides
    || true
  - cp ../${SOURCE_PATH}/overrides/*-tier.yaml  ${ENV_DESTINATION_PATH}/overrides
    || true
  - if [ ! -f ${ENV_DESTINATION_PATH}/appconfig.json ]; then cp ../mono_repo/services/schema/main_appconfig.json
    ${ENV_DESTINATION_PATH}/appconfig.json; fi
  - git status
  - echo "Adding changes to Git"
  - git add ${DESTINATION_PATH}
  - git status
  - COUNT=$(git diff --numstat ${STATE_BRANCH} | awk '{added += $1; deleted += $2}
    END {print added + deleted}')
  - |
    if [ "$COUNT" -eq 0 ]; then
      echo "No changes detected under ${CI_PROJECT_NAME}/${SOURCE_PATH}, exiting"
      exit 0
    fi
  - echo "Committing changes"
  - git commit -m "${CI_JOB_NAME}"
  - echo "Pushing changes to remote"
  - git pull --rebase
  - git status
  - "MAX_RETRIES=3\nINITIAL_DELAY=5\nsuccess=false\n\nfor attempt in $(seq 1 $MAX_RETRIES);
    do\n  if git push; then\n    echo -e \"\\e[32mPush successful\\e[0m\"\n    success=true\n
    \   break\n  else\n    echo -e \"\\e[33mPush failed, retrying ($attempt/$MAX_RETRIES)...\\e[0m\"\n
    \   git pull --rebase\n    \n    # Calculate backoff delay (5s, then 10s, then
    20s)\n    BACKOFF_DELAY=$((INITIAL_DELAY * 2**(attempt-1)))\n    echo \"Waiting
    ${BACKOFF_DELAY} seconds before next attempt...\"\n    sleep $BACKOFF_DELAY\n
    \ fi\ndone\n\nif [ \"$success\" != \"true\" ]; then\n  echo -e \"\\e[31mFailed
    to push after $MAX_RETRIES attempts\\e[0m\"\n  exit 1\nfi\n"
  - git status
  - echo "Resources published to argocd mono repo"
  variables:
    DESTINATION_REPO: https://gitlab.com/fireblocks/devops/iac/argocd.git
    DESTINATION_PROJECT_ID: 50521873
    SOURCE_PATH: deployment
    DESTINATION_PATH: services/shell
    STATE_BRANCH: main
    GITLAB_API_URL: https://gitlab.com/api/v4/projects
    TEMPLATE_REF: "$TEMPLATE_REF"
    GITLAB_RUNNER_TAG: devx-application-gitlab-runner
    ENV: localstack
  extends: ".publish_resources_dev"
".publish_resources_dev1":
  stage: configure
  retry:
    max: 2
    when:
    - script_failure
  tags:
  - "${GITLAB_RUNNER_TAG}"
  before_script:
  - printf "%s:%s\n" DESTINATION_REPO "$DESTINATION_REPO" DESTINATION_PROJECT_ID "$DESTINATION_PROJECT_ID"
    SOURCE_PATH "$SOURCE_PATH" DESTINATION_PATH "$DESTINATION_PATH" STATE_BRANCH "$STATE_BRANCH"
    GITLAB_API_URL "$GITLAB_API_URL"
  - |
    if [ ! -d "$SOURCE_PATH" ]; then
      echo "$SOURCE_PATH directory does not exist. Exiting job successfully."
      exit 0
    fi
    echo "$SOURCE_PATH directory exists. Continuing with deployment."
  - - apk update
    - apk add curl jq yq py3-pip
    - pip3 install --upgrade pip
    - pip3 install yamllint
    - pip3 install yamale --break-system-packages
    - npm install -g ajv-cli
    - echo "Configuring Git"
    - echo "https://argocd-ci-push:${ARGOCD_GITLAB_ACCESS_TOKEN}@gitlab.com" > ~/.git-credentials
    - git remote set-url origin https://argocd-ci-push:${ARGOCD_GITLAB_ACCESS_TOKEN}@gitlab.com/fireblocks/devops/iac/argocd.git
    - git config --global user.email "devops@fireblocks.com"
    - git config --global user.name "argocd-ci-push"
    - git config --global credential.helper store
    - touch .npmrc
    - npm config set --location=user @fireblocks:registry https://gitlab.com/api/v4/packages/npm/
    - npm config set --location=user '//gitlab.com/api/v4/packages/npm/:_authToken'
      "${NPM_REG_TOKEN}"
    - npm config set --location=user '//gitlab.com/api/v4/projects/20565764/packages/npm/:_authToken'
      "${NPM_REG_TOKEN}"
    - echo "@fireblocks:registry=https://gitlab.com/api/v4/packages/npm/">>.npmrc
    - echo "//gitlab.com/api/v4/packages/npm/:_authToken=${NPM_REG_TOKEN}">>.npmrc
    - echo "//gitlab.com/api/v4/projects/20565764/packages/npm/:_authToken=${NPM_REG_TOKEN}">>.npmrc
    - yarn global add @fireblocks/fb-cli
  script:
  - - echo "Self Service User Guide - https://fireblocks.atlassian.net/wiki/spaces/RD/pages/1413218873/Self+Service+User+Guide"
    - SVC_NAME=$([ "$SERVICE_NAME" ] && echo $SERVICE_NAME || echo $CI_PROJECT_NAME)
    - echo "Verifying deployment folder for ${SVC_NAME} service"
    - git clone ${DESTINATION_REPO} mono_repo
    - cd mono_repo
    - git fetch --all
    - git checkout ${STATE_BRANCH}
    - git pull origin ${STATE_BRANCH} --no-rebase
    - cd ../${SOURCE_PATH}
    - |
      # Define the paths
      values_file="values.yaml"

      # Check for values.yaml in the deployment folder
      if [ ! -f "$values_file" ]; then
          echo "Error: The values.yaml file is missing in the ${SOURCE_PATH} folder."
          exit 1
      fi

      echo "Success: All required files are present"
    - |
      # Directory to check
      DIR_TO_CHECK="overrides/"

      # List of allowed files
      ALLOWED_PATTERN=$(printf "|%s" "nonprod-tier.yaml" "prod-tier.yaml" "iac-dev.yaml" "localstack.yaml" "dev1.yaml" "dev2.yaml" "dev3.yaml" "dev4.yaml" "dev5.yaml" "dev6.yaml" "dev7.yaml" "dev8.yaml" "dev9.yaml" "dev10.yaml" "dev11.yaml" "dev11.yaml" "dev12.yaml" "dev13.yaml" "dev14.yaml" "dev15.yaml" "pre1.yaml" "stage.yaml" "sandbox.yaml" "eu-prod.yaml" "eu2-prod.yaml" "bnym-dev.yaml" "bnym-prod.yaml" "us-prod.yaml" | cut -c 2-)

      # Flag to track if there are disallowed files
      DISALLOWED_FOUND=false

      # Check for files in the directory that are not in the allowed list
      for file in "$DIR_TO_CHECK"/*; do
        # Get the base name of the file
        filename=$(basename "$file")

        # Check if the filename is in the allowed list
        if [[ ! $filename =~ ^($ALLOWED_PATTERN)$ ]]; then
          echo "Disallowed file found: $filename"
          DISALLOWED_FOUND=true
        fi
      done

      # Final output
      if $DISALLOWED_FOUND; then
        echo "Some files are not allowed."
        exit 1
      else
        echo "All files are allowed."
      fi
    - echo "Linting deployment yaml files"
    - cp ../mono_repo/services/schema/*.yaml .
    - cp ../mono_repo/services/schema/appconfig_schema.json .
    - cp ../mono_repo/services/schema/main_appconfig.json appconfig.json
    - cp ../mono_repo/services/schema/yamllint_rules.yaml yamllint_rules.yaml
    - yamllint --list-files **/*.yaml *.yaml
    - yamllint -s **/*.yaml *.yaml -c yamllint_rules.yaml
    - echo "Validating deployment yaml schema"
    - yamale -s base_values_schema.yaml values.yaml
    - yamale -s tier_values_schema.yaml overrides/prod-tier.yaml
    - yamale -s tier_values_schema.yaml overrides/nonprod-tier.yaml
    - |
      # Iterate over all yaml files in the overrides folder
      for file in overrides/*.yaml; do
          # Extract the filename from the path
          filename=$(basename -- "$file")

          # Check if the file is not prod-tier.yaml or nonprod-tier.yaml
          if [[ "$filename" != "prod-tier.yaml" ]] && [[ "$filename" != "nonprod-tier.yaml" ]]; then
              # Run yamale command on the file
              yamale -s env_values_schema.yaml "$file"
          fi
      done
    - "# Iterate over all yaml files in the overrides folder - validate_resources.sh\nif
      [[ -v ENGINE && \"$ENGINE\" == \"argocd\" ]]; then\n  export CD_INFRA_PROJECT_ID=61508954\n
      \ curl --header \"PRIVATE-TOKEN: $CD_CPU_RAM_REQUEST_LIMIT_READ_ONLY\"  \"https://gitlab.com/api/v4/projects/$CD_INFRA_PROJECT_ID/repository/files/ci-infra%2Fscripts%2Fvalidate_resources.sh/raw?ref=main\"
      -o \"$CI_PROJECT_DIR/validate_resources.sh\"\n  echo \"chmod +x $CI_PROJECT_DIR/validate_resources.sh\"
      \n  chmod +x \"$CI_PROJECT_DIR/validate_resources.sh\"\n  echo \"Searching for
      environments values files...\" \n  ENV_FILES_LIST=$(yamllint --list-files **/*.yaml
      *.yaml | grep -vE 'env_values_schema\\.yaml|tier_values_schema\\.yaml|base_values_schema\\.yaml|yamllint_rules\\.yaml|.*prod-tier\\.yaml|values.yaml'
      || true)\n  if [[ -n \"$ENV_FILES_LIST\" ]]; then\n    echo \"Found environments
      values files\"\n    while IFS= read -r file; do\n      filename=$(basename --
      \"$file\")\n      if [[ \"$filename\" =~ ^(dev[1-9]|dev10|stage|pre1).yaml$
      ]]; then\n        tier_file=\"overrides/nonprod-tier.yaml\"\n      else\n        tier_file=\"overrides/prod-tier.yaml\"
      \ \n      fi\n      echo \"values.yaml <-- $tier_file <-- $file\"\n      yq
      eval-all '. as $item ireduce ({}; . * $item)' values.yaml \"$tier_file\" \"$file\"
      | bash \"$CI_PROJECT_DIR/validate_resources.sh\" -\n    done <<< \"$ENV_FILES_LIST\"\n
      \ else\n    echo \"No environments values files were found. Continuing to the
      tier files.\"\n  fi\necho \"values.yaml <-- overrides/nonprod-tier.yaml\"\nyq
      eval-all '. as $item ireduce ({}; . * $item)' values.yaml overrides/nonprod-tier.yaml
      | bash \"$CI_PROJECT_DIR/validate_resources.sh\" -\necho \"values.yaml <-- overrides/prod-tier.yaml\"
      \nyq eval-all '. as $item ireduce ({}; . * $item)' values.yaml overrides/prod-tier.yaml
      | bash \"$CI_PROJECT_DIR/validate_resources.sh\" -\nelse\n  echo \"Skipping
      resource validation: ENGINE is not set to 'argocd'.\"\nfi\n"
    - ajv validate -s appconfig_schema.json -d appconfig.json
    - echo "Resources verified successfully"
    - echo "Validate filter_policy if exists - should be a valid JSON object"
    - fb deployment:validate . --filter-policy
  - cd ../mono_repo
  - ENV_DESTINATION_PATH=$(echo "${DESTINATION_PATH}/${SVC_NAME}/${ENV}")
  - echo "Copying ${SOURCE_PATH} folder from ${SVC_NAME} service to argocd mono repo
    destination folder at ${ENV_DESTINATION_PATH}"
  - mkdir -pv ${ENV_DESTINATION_PATH}/overrides
  - rm ${ENV_DESTINATION_PATH}/overrides/${ENV}.yaml || true
  - cp  ../${SOURCE_PATH}/values.yaml ${ENV_DESTINATION_PATH}
  - cp ../${SOURCE_PATH}/overrides/${ENV}.yaml  ${ENV_DESTINATION_PATH}/overrides
    || true
  - cp ../${SOURCE_PATH}/overrides/*-tier.yaml  ${ENV_DESTINATION_PATH}/overrides
    || true
  - if [ ! -f ${ENV_DESTINATION_PATH}/appconfig.json ]; then cp ../mono_repo/services/schema/main_appconfig.json
    ${ENV_DESTINATION_PATH}/appconfig.json; fi
  - git status
  - echo "Adding changes to Git"
  - git add ${DESTINATION_PATH}
  - git status
  - COUNT=$(git diff --numstat ${STATE_BRANCH} | awk '{added += $1; deleted += $2}
    END {print added + deleted}')
  - |
    if [ "$COUNT" -eq 0 ]; then
      echo "No changes detected under ${CI_PROJECT_NAME}/${SOURCE_PATH}, exiting"
      exit 0
    fi
  - echo "Committing changes"
  - git commit -m "${CI_JOB_NAME}"
  - echo "Pushing changes to remote"
  - git pull --rebase
  - git status
  - "MAX_RETRIES=3\nINITIAL_DELAY=5\nsuccess=false\n\nfor attempt in $(seq 1 $MAX_RETRIES);
    do\n  if git push; then\n    echo -e \"\\e[32mPush successful\\e[0m\"\n    success=true\n
    \   break\n  else\n    echo -e \"\\e[33mPush failed, retrying ($attempt/$MAX_RETRIES)...\\e[0m\"\n
    \   git pull --rebase\n    \n    # Calculate backoff delay (5s, then 10s, then
    20s)\n    BACKOFF_DELAY=$((INITIAL_DELAY * 2**(attempt-1)))\n    echo \"Waiting
    ${BACKOFF_DELAY} seconds before next attempt...\"\n    sleep $BACKOFF_DELAY\n
    \ fi\ndone\n\nif [ \"$success\" != \"true\" ]; then\n  echo -e \"\\e[31mFailed
    to push after $MAX_RETRIES attempts\\e[0m\"\n  exit 1\nfi\n"
  - git status
  - echo "Resources published to argocd mono repo"
  variables:
    DESTINATION_REPO: https://gitlab.com/fireblocks/devops/iac/argocd.git
    DESTINATION_PROJECT_ID: 50521873
    SOURCE_PATH: deployment
    DESTINATION_PATH: services/shell
    STATE_BRANCH: main
    GITLAB_API_URL: https://gitlab.com/api/v4/projects
    TEMPLATE_REF: "$TEMPLATE_REF"
    GITLAB_RUNNER_TAG: devx-application-gitlab-runner
    ENV: dev1
  extends: ".publish_resources_dev"
".publish_resources_dev2":
  stage: configure
  retry:
    max: 2
    when:
    - script_failure
  tags:
  - "${GITLAB_RUNNER_TAG}"
  before_script:
  - printf "%s:%s\n" DESTINATION_REPO "$DESTINATION_REPO" DESTINATION_PROJECT_ID "$DESTINATION_PROJECT_ID"
    SOURCE_PATH "$SOURCE_PATH" DESTINATION_PATH "$DESTINATION_PATH" STATE_BRANCH "$STATE_BRANCH"
    GITLAB_API_URL "$GITLAB_API_URL"
  - |
    if [ ! -d "$SOURCE_PATH" ]; then
      echo "$SOURCE_PATH directory does not exist. Exiting job successfully."
      exit 0
    fi
    echo "$SOURCE_PATH directory exists. Continuing with deployment."
  - - apk update
    - apk add curl jq yq py3-pip
    - pip3 install --upgrade pip
    - pip3 install yamllint
    - pip3 install yamale --break-system-packages
    - npm install -g ajv-cli
    - echo "Configuring Git"
    - echo "https://argocd-ci-push:${ARGOCD_GITLAB_ACCESS_TOKEN}@gitlab.com" > ~/.git-credentials
    - git remote set-url origin https://argocd-ci-push:${ARGOCD_GITLAB_ACCESS_TOKEN}@gitlab.com/fireblocks/devops/iac/argocd.git
    - git config --global user.email "devops@fireblocks.com"
    - git config --global user.name "argocd-ci-push"
    - git config --global credential.helper store
    - touch .npmrc
    - npm config set --location=user @fireblocks:registry https://gitlab.com/api/v4/packages/npm/
    - npm config set --location=user '//gitlab.com/api/v4/packages/npm/:_authToken'
      "${NPM_REG_TOKEN}"
    - npm config set --location=user '//gitlab.com/api/v4/projects/20565764/packages/npm/:_authToken'
      "${NPM_REG_TOKEN}"
    - echo "@fireblocks:registry=https://gitlab.com/api/v4/packages/npm/">>.npmrc
    - echo "//gitlab.com/api/v4/packages/npm/:_authToken=${NPM_REG_TOKEN}">>.npmrc
    - echo "//gitlab.com/api/v4/projects/20565764/packages/npm/:_authToken=${NPM_REG_TOKEN}">>.npmrc
    - yarn global add @fireblocks/fb-cli
  script:
  - - echo "Self Service User Guide - https://fireblocks.atlassian.net/wiki/spaces/RD/pages/1413218873/Self+Service+User+Guide"
    - SVC_NAME=$([ "$SERVICE_NAME" ] && echo $SERVICE_NAME || echo $CI_PROJECT_NAME)
    - echo "Verifying deployment folder for ${SVC_NAME} service"
    - git clone ${DESTINATION_REPO} mono_repo
    - cd mono_repo
    - git fetch --all
    - git checkout ${STATE_BRANCH}
    - git pull origin ${STATE_BRANCH} --no-rebase
    - cd ../${SOURCE_PATH}
    - |
      # Define the paths
      values_file="values.yaml"

      # Check for values.yaml in the deployment folder
      if [ ! -f "$values_file" ]; then
          echo "Error: The values.yaml file is missing in the ${SOURCE_PATH} folder."
          exit 1
      fi

      echo "Success: All required files are present"
    - |
      # Directory to check
      DIR_TO_CHECK="overrides/"

      # List of allowed files
      ALLOWED_PATTERN=$(printf "|%s" "nonprod-tier.yaml" "prod-tier.yaml" "iac-dev.yaml" "localstack.yaml" "dev1.yaml" "dev2.yaml" "dev3.yaml" "dev4.yaml" "dev5.yaml" "dev6.yaml" "dev7.yaml" "dev8.yaml" "dev9.yaml" "dev10.yaml" "dev11.yaml" "dev11.yaml" "dev12.yaml" "dev13.yaml" "dev14.yaml" "dev15.yaml" "pre1.yaml" "stage.yaml" "sandbox.yaml" "eu-prod.yaml" "eu2-prod.yaml" "bnym-dev.yaml" "bnym-prod.yaml" "us-prod.yaml" | cut -c 2-)

      # Flag to track if there are disallowed files
      DISALLOWED_FOUND=false

      # Check for files in the directory that are not in the allowed list
      for file in "$DIR_TO_CHECK"/*; do
        # Get the base name of the file
        filename=$(basename "$file")

        # Check if the filename is in the allowed list
        if [[ ! $filename =~ ^($ALLOWED_PATTERN)$ ]]; then
          echo "Disallowed file found: $filename"
          DISALLOWED_FOUND=true
        fi
      done

      # Final output
      if $DISALLOWED_FOUND; then
        echo "Some files are not allowed."
        exit 1
      else
        echo "All files are allowed."
      fi
    - echo "Linting deployment yaml files"
    - cp ../mono_repo/services/schema/*.yaml .
    - cp ../mono_repo/services/schema/appconfig_schema.json .
    - cp ../mono_repo/services/schema/main_appconfig.json appconfig.json
    - cp ../mono_repo/services/schema/yamllint_rules.yaml yamllint_rules.yaml
    - yamllint --list-files **/*.yaml *.yaml
    - yamllint -s **/*.yaml *.yaml -c yamllint_rules.yaml
    - echo "Validating deployment yaml schema"
    - yamale -s base_values_schema.yaml values.yaml
    - yamale -s tier_values_schema.yaml overrides/prod-tier.yaml
    - yamale -s tier_values_schema.yaml overrides/nonprod-tier.yaml
    - |
      # Iterate over all yaml files in the overrides folder
      for file in overrides/*.yaml; do
          # Extract the filename from the path
          filename=$(basename -- "$file")

          # Check if the file is not prod-tier.yaml or nonprod-tier.yaml
          if [[ "$filename" != "prod-tier.yaml" ]] && [[ "$filename" != "nonprod-tier.yaml" ]]; then
              # Run yamale command on the file
              yamale -s env_values_schema.yaml "$file"
          fi
      done
    - "# Iterate over all yaml files in the overrides folder - validate_resources.sh\nif
      [[ -v ENGINE && \"$ENGINE\" == \"argocd\" ]]; then\n  export CD_INFRA_PROJECT_ID=61508954\n
      \ curl --header \"PRIVATE-TOKEN: $CD_CPU_RAM_REQUEST_LIMIT_READ_ONLY\"  \"https://gitlab.com/api/v4/projects/$CD_INFRA_PROJECT_ID/repository/files/ci-infra%2Fscripts%2Fvalidate_resources.sh/raw?ref=main\"
      -o \"$CI_PROJECT_DIR/validate_resources.sh\"\n  echo \"chmod +x $CI_PROJECT_DIR/validate_resources.sh\"
      \n  chmod +x \"$CI_PROJECT_DIR/validate_resources.sh\"\n  echo \"Searching for
      environments values files...\" \n  ENV_FILES_LIST=$(yamllint --list-files **/*.yaml
      *.yaml | grep -vE 'env_values_schema\\.yaml|tier_values_schema\\.yaml|base_values_schema\\.yaml|yamllint_rules\\.yaml|.*prod-tier\\.yaml|values.yaml'
      || true)\n  if [[ -n \"$ENV_FILES_LIST\" ]]; then\n    echo \"Found environments
      values files\"\n    while IFS= read -r file; do\n      filename=$(basename --
      \"$file\")\n      if [[ \"$filename\" =~ ^(dev[1-9]|dev10|stage|pre1).yaml$
      ]]; then\n        tier_file=\"overrides/nonprod-tier.yaml\"\n      else\n        tier_file=\"overrides/prod-tier.yaml\"
      \ \n      fi\n      echo \"values.yaml <-- $tier_file <-- $file\"\n      yq
      eval-all '. as $item ireduce ({}; . * $item)' values.yaml \"$tier_file\" \"$file\"
      | bash \"$CI_PROJECT_DIR/validate_resources.sh\" -\n    done <<< \"$ENV_FILES_LIST\"\n
      \ else\n    echo \"No environments values files were found. Continuing to the
      tier files.\"\n  fi\necho \"values.yaml <-- overrides/nonprod-tier.yaml\"\nyq
      eval-all '. as $item ireduce ({}; . * $item)' values.yaml overrides/nonprod-tier.yaml
      | bash \"$CI_PROJECT_DIR/validate_resources.sh\" -\necho \"values.yaml <-- overrides/prod-tier.yaml\"
      \nyq eval-all '. as $item ireduce ({}; . * $item)' values.yaml overrides/prod-tier.yaml
      | bash \"$CI_PROJECT_DIR/validate_resources.sh\" -\nelse\n  echo \"Skipping
      resource validation: ENGINE is not set to 'argocd'.\"\nfi\n"
    - ajv validate -s appconfig_schema.json -d appconfig.json
    - echo "Resources verified successfully"
    - echo "Validate filter_policy if exists - should be a valid JSON object"
    - fb deployment:validate . --filter-policy
  - cd ../mono_repo
  - ENV_DESTINATION_PATH=$(echo "${DESTINATION_PATH}/${SVC_NAME}/${ENV}")
  - echo "Copying ${SOURCE_PATH} folder from ${SVC_NAME} service to argocd mono repo
    destination folder at ${ENV_DESTINATION_PATH}"
  - mkdir -pv ${ENV_DESTINATION_PATH}/overrides
  - rm ${ENV_DESTINATION_PATH}/overrides/${ENV}.yaml || true
  - cp  ../${SOURCE_PATH}/values.yaml ${ENV_DESTINATION_PATH}
  - cp ../${SOURCE_PATH}/overrides/${ENV}.yaml  ${ENV_DESTINATION_PATH}/overrides
    || true
  - cp ../${SOURCE_PATH}/overrides/*-tier.yaml  ${ENV_DESTINATION_PATH}/overrides
    || true
  - if [ ! -f ${ENV_DESTINATION_PATH}/appconfig.json ]; then cp ../mono_repo/services/schema/main_appconfig.json
    ${ENV_DESTINATION_PATH}/appconfig.json; fi
  - git status
  - echo "Adding changes to Git"
  - git add ${DESTINATION_PATH}
  - git status
  - COUNT=$(git diff --numstat ${STATE_BRANCH} | awk '{added += $1; deleted += $2}
    END {print added + deleted}')
  - |
    if [ "$COUNT" -eq 0 ]; then
      echo "No changes detected under ${CI_PROJECT_NAME}/${SOURCE_PATH}, exiting"
      exit 0
    fi
  - echo "Committing changes"
  - git commit -m "${CI_JOB_NAME}"
  - echo "Pushing changes to remote"
  - git pull --rebase
  - git status
  - "MAX_RETRIES=3\nINITIAL_DELAY=5\nsuccess=false\n\nfor attempt in $(seq 1 $MAX_RETRIES);
    do\n  if git push; then\n    echo -e \"\\e[32mPush successful\\e[0m\"\n    success=true\n
    \   break\n  else\n    echo -e \"\\e[33mPush failed, retrying ($attempt/$MAX_RETRIES)...\\e[0m\"\n
    \   git pull --rebase\n    \n    # Calculate backoff delay (5s, then 10s, then
    20s)\n    BACKOFF_DELAY=$((INITIAL_DELAY * 2**(attempt-1)))\n    echo \"Waiting
    ${BACKOFF_DELAY} seconds before next attempt...\"\n    sleep $BACKOFF_DELAY\n
    \ fi\ndone\n\nif [ \"$success\" != \"true\" ]; then\n  echo -e \"\\e[31mFailed
    to push after $MAX_RETRIES attempts\\e[0m\"\n  exit 1\nfi\n"
  - git status
  - echo "Resources published to argocd mono repo"
  variables:
    DESTINATION_REPO: https://gitlab.com/fireblocks/devops/iac/argocd.git
    DESTINATION_PROJECT_ID: 50521873
    SOURCE_PATH: deployment
    DESTINATION_PATH: services/shell
    STATE_BRANCH: main
    GITLAB_API_URL: https://gitlab.com/api/v4/projects
    TEMPLATE_REF: "$TEMPLATE_REF"
    GITLAB_RUNNER_TAG: devx-application-gitlab-runner
    ENV: dev2
  extends: ".publish_resources_dev"
".publish_resources_dev3":
  stage: configure
  retry:
    max: 2
    when:
    - script_failure
  tags:
  - "${GITLAB_RUNNER_TAG}"
  before_script:
  - printf "%s:%s\n" DESTINATION_REPO "$DESTINATION_REPO" DESTINATION_PROJECT_ID "$DESTINATION_PROJECT_ID"
    SOURCE_PATH "$SOURCE_PATH" DESTINATION_PATH "$DESTINATION_PATH" STATE_BRANCH "$STATE_BRANCH"
    GITLAB_API_URL "$GITLAB_API_URL"
  - |
    if [ ! -d "$SOURCE_PATH" ]; then
      echo "$SOURCE_PATH directory does not exist. Exiting job successfully."
      exit 0
    fi
    echo "$SOURCE_PATH directory exists. Continuing with deployment."
  - - apk update
    - apk add curl jq yq py3-pip
    - pip3 install --upgrade pip
    - pip3 install yamllint
    - pip3 install yamale --break-system-packages
    - npm install -g ajv-cli
    - echo "Configuring Git"
    - echo "https://argocd-ci-push:${ARGOCD_GITLAB_ACCESS_TOKEN}@gitlab.com" > ~/.git-credentials
    - git remote set-url origin https://argocd-ci-push:${ARGOCD_GITLAB_ACCESS_TOKEN}@gitlab.com/fireblocks/devops/iac/argocd.git
    - git config --global user.email "devops@fireblocks.com"
    - git config --global user.name "argocd-ci-push"
    - git config --global credential.helper store
    - touch .npmrc
    - npm config set --location=user @fireblocks:registry https://gitlab.com/api/v4/packages/npm/
    - npm config set --location=user '//gitlab.com/api/v4/packages/npm/:_authToken'
      "${NPM_REG_TOKEN}"
    - npm config set --location=user '//gitlab.com/api/v4/projects/20565764/packages/npm/:_authToken'
      "${NPM_REG_TOKEN}"
    - echo "@fireblocks:registry=https://gitlab.com/api/v4/packages/npm/">>.npmrc
    - echo "//gitlab.com/api/v4/packages/npm/:_authToken=${NPM_REG_TOKEN}">>.npmrc
    - echo "//gitlab.com/api/v4/projects/20565764/packages/npm/:_authToken=${NPM_REG_TOKEN}">>.npmrc
    - yarn global add @fireblocks/fb-cli
  script:
  - - echo "Self Service User Guide - https://fireblocks.atlassian.net/wiki/spaces/RD/pages/1413218873/Self+Service+User+Guide"
    - SVC_NAME=$([ "$SERVICE_NAME" ] && echo $SERVICE_NAME || echo $CI_PROJECT_NAME)
    - echo "Verifying deployment folder for ${SVC_NAME} service"
    - git clone ${DESTINATION_REPO} mono_repo
    - cd mono_repo
    - git fetch --all
    - git checkout ${STATE_BRANCH}
    - git pull origin ${STATE_BRANCH} --no-rebase
    - cd ../${SOURCE_PATH}
    - |
      # Define the paths
      values_file="values.yaml"

      # Check for values.yaml in the deployment folder
      if [ ! -f "$values_file" ]; then
          echo "Error: The values.yaml file is missing in the ${SOURCE_PATH} folder."
          exit 1
      fi

      echo "Success: All required files are present"
    - |
      # Directory to check
      DIR_TO_CHECK="overrides/"

      # List of allowed files
      ALLOWED_PATTERN=$(printf "|%s" "nonprod-tier.yaml" "prod-tier.yaml" "iac-dev.yaml" "localstack.yaml" "dev1.yaml" "dev2.yaml" "dev3.yaml" "dev4.yaml" "dev5.yaml" "dev6.yaml" "dev7.yaml" "dev8.yaml" "dev9.yaml" "dev10.yaml" "dev11.yaml" "dev11.yaml" "dev12.yaml" "dev13.yaml" "dev14.yaml" "dev15.yaml" "pre1.yaml" "stage.yaml" "sandbox.yaml" "eu-prod.yaml" "eu2-prod.yaml" "bnym-dev.yaml" "bnym-prod.yaml" "us-prod.yaml" | cut -c 2-)

      # Flag to track if there are disallowed files
      DISALLOWED_FOUND=false

      # Check for files in the directory that are not in the allowed list
      for file in "$DIR_TO_CHECK"/*; do
        # Get the base name of the file
        filename=$(basename "$file")

        # Check if the filename is in the allowed list
        if [[ ! $filename =~ ^($ALLOWED_PATTERN)$ ]]; then
          echo "Disallowed file found: $filename"
          DISALLOWED_FOUND=true
        fi
      done

      # Final output
      if $DISALLOWED_FOUND; then
        echo "Some files are not allowed."
        exit 1
      else
        echo "All files are allowed."
      fi
    - echo "Linting deployment yaml files"
    - cp ../mono_repo/services/schema/*.yaml .
    - cp ../mono_repo/services/schema/appconfig_schema.json .
    - cp ../mono_repo/services/schema/main_appconfig.json appconfig.json
    - cp ../mono_repo/services/schema/yamllint_rules.yaml yamllint_rules.yaml
    - yamllint --list-files **/*.yaml *.yaml
    - yamllint -s **/*.yaml *.yaml -c yamllint_rules.yaml
    - echo "Validating deployment yaml schema"
    - yamale -s base_values_schema.yaml values.yaml
    - yamale -s tier_values_schema.yaml overrides/prod-tier.yaml
    - yamale -s tier_values_schema.yaml overrides/nonprod-tier.yaml
    - |
      # Iterate over all yaml files in the overrides folder
      for file in overrides/*.yaml; do
          # Extract the filename from the path
          filename=$(basename -- "$file")

          # Check if the file is not prod-tier.yaml or nonprod-tier.yaml
          if [[ "$filename" != "prod-tier.yaml" ]] && [[ "$filename" != "nonprod-tier.yaml" ]]; then
              # Run yamale command on the file
              yamale -s env_values_schema.yaml "$file"
          fi
      done
    - "# Iterate over all yaml files in the overrides folder - validate_resources.sh\nif
      [[ -v ENGINE && \"$ENGINE\" == \"argocd\" ]]; then\n  export CD_INFRA_PROJECT_ID=61508954\n
      \ curl --header \"PRIVATE-TOKEN: $CD_CPU_RAM_REQUEST_LIMIT_READ_ONLY\"  \"https://gitlab.com/api/v4/projects/$CD_INFRA_PROJECT_ID/repository/files/ci-infra%2Fscripts%2Fvalidate_resources.sh/raw?ref=main\"
      -o \"$CI_PROJECT_DIR/validate_resources.sh\"\n  echo \"chmod +x $CI_PROJECT_DIR/validate_resources.sh\"
      \n  chmod +x \"$CI_PROJECT_DIR/validate_resources.sh\"\n  echo \"Searching for
      environments values files...\" \n  ENV_FILES_LIST=$(yamllint --list-files **/*.yaml
      *.yaml | grep -vE 'env_values_schema\\.yaml|tier_values_schema\\.yaml|base_values_schema\\.yaml|yamllint_rules\\.yaml|.*prod-tier\\.yaml|values.yaml'
      || true)\n  if [[ -n \"$ENV_FILES_LIST\" ]]; then\n    echo \"Found environments
      values files\"\n    while IFS= read -r file; do\n      filename=$(basename --
      \"$file\")\n      if [[ \"$filename\" =~ ^(dev[1-9]|dev10|stage|pre1).yaml$
      ]]; then\n        tier_file=\"overrides/nonprod-tier.yaml\"\n      else\n        tier_file=\"overrides/prod-tier.yaml\"
      \ \n      fi\n      echo \"values.yaml <-- $tier_file <-- $file\"\n      yq
      eval-all '. as $item ireduce ({}; . * $item)' values.yaml \"$tier_file\" \"$file\"
      | bash \"$CI_PROJECT_DIR/validate_resources.sh\" -\n    done <<< \"$ENV_FILES_LIST\"\n
      \ else\n    echo \"No environments values files were found. Continuing to the
      tier files.\"\n  fi\necho \"values.yaml <-- overrides/nonprod-tier.yaml\"\nyq
      eval-all '. as $item ireduce ({}; . * $item)' values.yaml overrides/nonprod-tier.yaml
      | bash \"$CI_PROJECT_DIR/validate_resources.sh\" -\necho \"values.yaml <-- overrides/prod-tier.yaml\"
      \nyq eval-all '. as $item ireduce ({}; . * $item)' values.yaml overrides/prod-tier.yaml
      | bash \"$CI_PROJECT_DIR/validate_resources.sh\" -\nelse\n  echo \"Skipping
      resource validation: ENGINE is not set to 'argocd'.\"\nfi\n"
    - ajv validate -s appconfig_schema.json -d appconfig.json
    - echo "Resources verified successfully"
    - echo "Validate filter_policy if exists - should be a valid JSON object"
    - fb deployment:validate . --filter-policy
  - cd ../mono_repo
  - ENV_DESTINATION_PATH=$(echo "${DESTINATION_PATH}/${SVC_NAME}/${ENV}")
  - echo "Copying ${SOURCE_PATH} folder from ${SVC_NAME} service to argocd mono repo
    destination folder at ${ENV_DESTINATION_PATH}"
  - mkdir -pv ${ENV_DESTINATION_PATH}/overrides
  - rm ${ENV_DESTINATION_PATH}/overrides/${ENV}.yaml || true
  - cp  ../${SOURCE_PATH}/values.yaml ${ENV_DESTINATION_PATH}
  - cp ../${SOURCE_PATH}/overrides/${ENV}.yaml  ${ENV_DESTINATION_PATH}/overrides
    || true
  - cp ../${SOURCE_PATH}/overrides/*-tier.yaml  ${ENV_DESTINATION_PATH}/overrides
    || true
  - if [ ! -f ${ENV_DESTINATION_PATH}/appconfig.json ]; then cp ../mono_repo/services/schema/main_appconfig.json
    ${ENV_DESTINATION_PATH}/appconfig.json; fi
  - git status
  - echo "Adding changes to Git"
  - git add ${DESTINATION_PATH}
  - git status
  - COUNT=$(git diff --numstat ${STATE_BRANCH} | awk '{added += $1; deleted += $2}
    END {print added + deleted}')
  - |
    if [ "$COUNT" -eq 0 ]; then
      echo "No changes detected under ${CI_PROJECT_NAME}/${SOURCE_PATH}, exiting"
      exit 0
    fi
  - echo "Committing changes"
  - git commit -m "${CI_JOB_NAME}"
  - echo "Pushing changes to remote"
  - git pull --rebase
  - git status
  - "MAX_RETRIES=3\nINITIAL_DELAY=5\nsuccess=false\n\nfor attempt in $(seq 1 $MAX_RETRIES);
    do\n  if git push; then\n    echo -e \"\\e[32mPush successful\\e[0m\"\n    success=true\n
    \   break\n  else\n    echo -e \"\\e[33mPush failed, retrying ($attempt/$MAX_RETRIES)...\\e[0m\"\n
    \   git pull --rebase\n    \n    # Calculate backoff delay (5s, then 10s, then
    20s)\n    BACKOFF_DELAY=$((INITIAL_DELAY * 2**(attempt-1)))\n    echo \"Waiting
    ${BACKOFF_DELAY} seconds before next attempt...\"\n    sleep $BACKOFF_DELAY\n
    \ fi\ndone\n\nif [ \"$success\" != \"true\" ]; then\n  echo -e \"\\e[31mFailed
    to push after $MAX_RETRIES attempts\\e[0m\"\n  exit 1\nfi\n"
  - git status
  - echo "Resources published to argocd mono repo"
  variables:
    DESTINATION_REPO: https://gitlab.com/fireblocks/devops/iac/argocd.git
    DESTINATION_PROJECT_ID: 50521873
    SOURCE_PATH: deployment
    DESTINATION_PATH: services/shell
    STATE_BRANCH: main
    GITLAB_API_URL: https://gitlab.com/api/v4/projects
    TEMPLATE_REF: "$TEMPLATE_REF"
    GITLAB_RUNNER_TAG: devx-application-gitlab-runner
    ENV: dev3
  extends: ".publish_resources_dev"
".publish_resources_dev4":
  stage: configure
  retry:
    max: 2
    when:
    - script_failure
  tags:
  - "${GITLAB_RUNNER_TAG}"
  before_script:
  - printf "%s:%s\n" DESTINATION_REPO "$DESTINATION_REPO" DESTINATION_PROJECT_ID "$DESTINATION_PROJECT_ID"
    SOURCE_PATH "$SOURCE_PATH" DESTINATION_PATH "$DESTINATION_PATH" STATE_BRANCH "$STATE_BRANCH"
    GITLAB_API_URL "$GITLAB_API_URL"
  - |
    if [ ! -d "$SOURCE_PATH" ]; then
      echo "$SOURCE_PATH directory does not exist. Exiting job successfully."
      exit 0
    fi
    echo "$SOURCE_PATH directory exists. Continuing with deployment."
  - - apk update
    - apk add curl jq yq py3-pip
    - pip3 install --upgrade pip
    - pip3 install yamllint
    - pip3 install yamale --break-system-packages
    - npm install -g ajv-cli
    - echo "Configuring Git"
    - echo "https://argocd-ci-push:${ARGOCD_GITLAB_ACCESS_TOKEN}@gitlab.com" > ~/.git-credentials
    - git remote set-url origin https://argocd-ci-push:${ARGOCD_GITLAB_ACCESS_TOKEN}@gitlab.com/fireblocks/devops/iac/argocd.git
    - git config --global user.email "devops@fireblocks.com"
    - git config --global user.name "argocd-ci-push"
    - git config --global credential.helper store
    - touch .npmrc
    - npm config set --location=user @fireblocks:registry https://gitlab.com/api/v4/packages/npm/
    - npm config set --location=user '//gitlab.com/api/v4/packages/npm/:_authToken'
      "${NPM_REG_TOKEN}"
    - npm config set --location=user '//gitlab.com/api/v4/projects/20565764/packages/npm/:_authToken'
      "${NPM_REG_TOKEN}"
    - echo "@fireblocks:registry=https://gitlab.com/api/v4/packages/npm/">>.npmrc
    - echo "//gitlab.com/api/v4/packages/npm/:_authToken=${NPM_REG_TOKEN}">>.npmrc
    - echo "//gitlab.com/api/v4/projects/20565764/packages/npm/:_authToken=${NPM_REG_TOKEN}">>.npmrc
    - yarn global add @fireblocks/fb-cli
  script:
  - - echo "Self Service User Guide - https://fireblocks.atlassian.net/wiki/spaces/RD/pages/1413218873/Self+Service+User+Guide"
    - SVC_NAME=$([ "$SERVICE_NAME" ] && echo $SERVICE_NAME || echo $CI_PROJECT_NAME)
    - echo "Verifying deployment folder for ${SVC_NAME} service"
    - git clone ${DESTINATION_REPO} mono_repo
    - cd mono_repo
    - git fetch --all
    - git checkout ${STATE_BRANCH}
    - git pull origin ${STATE_BRANCH} --no-rebase
    - cd ../${SOURCE_PATH}
    - |
      # Define the paths
      values_file="values.yaml"

      # Check for values.yaml in the deployment folder
      if [ ! -f "$values_file" ]; then
          echo "Error: The values.yaml file is missing in the ${SOURCE_PATH} folder."
          exit 1
      fi

      echo "Success: All required files are present"
    - |
      # Directory to check
      DIR_TO_CHECK="overrides/"

      # List of allowed files
      ALLOWED_PATTERN=$(printf "|%s" "nonprod-tier.yaml" "prod-tier.yaml" "iac-dev.yaml" "localstack.yaml" "dev1.yaml" "dev2.yaml" "dev3.yaml" "dev4.yaml" "dev5.yaml" "dev6.yaml" "dev7.yaml" "dev8.yaml" "dev9.yaml" "dev10.yaml" "dev11.yaml" "dev11.yaml" "dev12.yaml" "dev13.yaml" "dev14.yaml" "dev15.yaml" "pre1.yaml" "stage.yaml" "sandbox.yaml" "eu-prod.yaml" "eu2-prod.yaml" "bnym-dev.yaml" "bnym-prod.yaml" "us-prod.yaml" | cut -c 2-)

      # Flag to track if there are disallowed files
      DISALLOWED_FOUND=false

      # Check for files in the directory that are not in the allowed list
      for file in "$DIR_TO_CHECK"/*; do
        # Get the base name of the file
        filename=$(basename "$file")

        # Check if the filename is in the allowed list
        if [[ ! $filename =~ ^($ALLOWED_PATTERN)$ ]]; then
          echo "Disallowed file found: $filename"
          DISALLOWED_FOUND=true
        fi
      done

      # Final output
      if $DISALLOWED_FOUND; then
        echo "Some files are not allowed."
        exit 1
      else
        echo "All files are allowed."
      fi
    - echo "Linting deployment yaml files"
    - cp ../mono_repo/services/schema/*.yaml .
    - cp ../mono_repo/services/schema/appconfig_schema.json .
    - cp ../mono_repo/services/schema/main_appconfig.json appconfig.json
    - cp ../mono_repo/services/schema/yamllint_rules.yaml yamllint_rules.yaml
    - yamllint --list-files **/*.yaml *.yaml
    - yamllint -s **/*.yaml *.yaml -c yamllint_rules.yaml
    - echo "Validating deployment yaml schema"
    - yamale -s base_values_schema.yaml values.yaml
    - yamale -s tier_values_schema.yaml overrides/prod-tier.yaml
    - yamale -s tier_values_schema.yaml overrides/nonprod-tier.yaml
    - |
      # Iterate over all yaml files in the overrides folder
      for file in overrides/*.yaml; do
          # Extract the filename from the path
          filename=$(basename -- "$file")

          # Check if the file is not prod-tier.yaml or nonprod-tier.yaml
          if [[ "$filename" != "prod-tier.yaml" ]] && [[ "$filename" != "nonprod-tier.yaml" ]]; then
              # Run yamale command on the file
              yamale -s env_values_schema.yaml "$file"
          fi
      done
    - "# Iterate over all yaml files in the overrides folder - validate_resources.sh\nif
      [[ -v ENGINE && \"$ENGINE\" == \"argocd\" ]]; then\n  export CD_INFRA_PROJECT_ID=61508954\n
      \ curl --header \"PRIVATE-TOKEN: $CD_CPU_RAM_REQUEST_LIMIT_READ_ONLY\"  \"https://gitlab.com/api/v4/projects/$CD_INFRA_PROJECT_ID/repository/files/ci-infra%2Fscripts%2Fvalidate_resources.sh/raw?ref=main\"
      -o \"$CI_PROJECT_DIR/validate_resources.sh\"\n  echo \"chmod +x $CI_PROJECT_DIR/validate_resources.sh\"
      \n  chmod +x \"$CI_PROJECT_DIR/validate_resources.sh\"\n  echo \"Searching for
      environments values files...\" \n  ENV_FILES_LIST=$(yamllint --list-files **/*.yaml
      *.yaml | grep -vE 'env_values_schema\\.yaml|tier_values_schema\\.yaml|base_values_schema\\.yaml|yamllint_rules\\.yaml|.*prod-tier\\.yaml|values.yaml'
      || true)\n  if [[ -n \"$ENV_FILES_LIST\" ]]; then\n    echo \"Found environments
      values files\"\n    while IFS= read -r file; do\n      filename=$(basename --
      \"$file\")\n      if [[ \"$filename\" =~ ^(dev[1-9]|dev10|stage|pre1).yaml$
      ]]; then\n        tier_file=\"overrides/nonprod-tier.yaml\"\n      else\n        tier_file=\"overrides/prod-tier.yaml\"
      \ \n      fi\n      echo \"values.yaml <-- $tier_file <-- $file\"\n      yq
      eval-all '. as $item ireduce ({}; . * $item)' values.yaml \"$tier_file\" \"$file\"
      | bash \"$CI_PROJECT_DIR/validate_resources.sh\" -\n    done <<< \"$ENV_FILES_LIST\"\n
      \ else\n    echo \"No environments values files were found. Continuing to the
      tier files.\"\n  fi\necho \"values.yaml <-- overrides/nonprod-tier.yaml\"\nyq
      eval-all '. as $item ireduce ({}; . * $item)' values.yaml overrides/nonprod-tier.yaml
      | bash \"$CI_PROJECT_DIR/validate_resources.sh\" -\necho \"values.yaml <-- overrides/prod-tier.yaml\"
      \nyq eval-all '. as $item ireduce ({}; . * $item)' values.yaml overrides/prod-tier.yaml
      | bash \"$CI_PROJECT_DIR/validate_resources.sh\" -\nelse\n  echo \"Skipping
      resource validation: ENGINE is not set to 'argocd'.\"\nfi\n"
    - ajv validate -s appconfig_schema.json -d appconfig.json
    - echo "Resources verified successfully"
    - echo "Validate filter_policy if exists - should be a valid JSON object"
    - fb deployment:validate . --filter-policy
  - cd ../mono_repo
  - ENV_DESTINATION_PATH=$(echo "${DESTINATION_PATH}/${SVC_NAME}/${ENV}")
  - echo "Copying ${SOURCE_PATH} folder from ${SVC_NAME} service to argocd mono repo
    destination folder at ${ENV_DESTINATION_PATH}"
  - mkdir -pv ${ENV_DESTINATION_PATH}/overrides
  - rm ${ENV_DESTINATION_PATH}/overrides/${ENV}.yaml || true
  - cp  ../${SOURCE_PATH}/values.yaml ${ENV_DESTINATION_PATH}
  - cp ../${SOURCE_PATH}/overrides/${ENV}.yaml  ${ENV_DESTINATION_PATH}/overrides
    || true
  - cp ../${SOURCE_PATH}/overrides/*-tier.yaml  ${ENV_DESTINATION_PATH}/overrides
    || true
  - if [ ! -f ${ENV_DESTINATION_PATH}/appconfig.json ]; then cp ../mono_repo/services/schema/main_appconfig.json
    ${ENV_DESTINATION_PATH}/appconfig.json; fi
  - git status
  - echo "Adding changes to Git"
  - git add ${DESTINATION_PATH}
  - git status
  - COUNT=$(git diff --numstat ${STATE_BRANCH} | awk '{added += $1; deleted += $2}
    END {print added + deleted}')
  - |
    if [ "$COUNT" -eq 0 ]; then
      echo "No changes detected under ${CI_PROJECT_NAME}/${SOURCE_PATH}, exiting"
      exit 0
    fi
  - echo "Committing changes"
  - git commit -m "${CI_JOB_NAME}"
  - echo "Pushing changes to remote"
  - git pull --rebase
  - git status
  - "MAX_RETRIES=3\nINITIAL_DELAY=5\nsuccess=false\n\nfor attempt in $(seq 1 $MAX_RETRIES);
    do\n  if git push; then\n    echo -e \"\\e[32mPush successful\\e[0m\"\n    success=true\n
    \   break\n  else\n    echo -e \"\\e[33mPush failed, retrying ($attempt/$MAX_RETRIES)...\\e[0m\"\n
    \   git pull --rebase\n    \n    # Calculate backoff delay (5s, then 10s, then
    20s)\n    BACKOFF_DELAY=$((INITIAL_DELAY * 2**(attempt-1)))\n    echo \"Waiting
    ${BACKOFF_DELAY} seconds before next attempt...\"\n    sleep $BACKOFF_DELAY\n
    \ fi\ndone\n\nif [ \"$success\" != \"true\" ]; then\n  echo -e \"\\e[31mFailed
    to push after $MAX_RETRIES attempts\\e[0m\"\n  exit 1\nfi\n"
  - git status
  - echo "Resources published to argocd mono repo"
  variables:
    DESTINATION_REPO: https://gitlab.com/fireblocks/devops/iac/argocd.git
    DESTINATION_PROJECT_ID: 50521873
    SOURCE_PATH: deployment
    DESTINATION_PATH: services/shell
    STATE_BRANCH: main
    GITLAB_API_URL: https://gitlab.com/api/v4/projects
    TEMPLATE_REF: "$TEMPLATE_REF"
    GITLAB_RUNNER_TAG: devx-application-gitlab-runner
    ENV: dev4
  extends: ".publish_resources_dev"
".publish_resources_stage":
  stage: configure
  retry:
    max: 2
    when:
    - script_failure
  tags:
  - "${GITLAB_RUNNER_TAG}"
  before_script:
  - printf "%s:%s\n" DESTINATION_REPO "$DESTINATION_REPO" DESTINATION_PROJECT_ID "$DESTINATION_PROJECT_ID"
    SOURCE_PATH "$SOURCE_PATH" DESTINATION_PATH "$DESTINATION_PATH" STATE_BRANCH "$STATE_BRANCH"
    GITLAB_API_URL "$GITLAB_API_URL"
  - |
    if [ ! -d "$SOURCE_PATH" ]; then
      echo "$SOURCE_PATH directory does not exist. Exiting job successfully."
      exit 0
    fi
    echo "$SOURCE_PATH directory exists. Continuing with deployment."
  - - apk update
    - apk add curl jq yq py3-pip
    - pip3 install --upgrade pip
    - pip3 install yamllint
    - pip3 install yamale --break-system-packages
    - npm install -g ajv-cli
    - echo "Configuring Git"
    - echo "https://argocd-ci-push:${ARGOCD_GITLAB_ACCESS_TOKEN}@gitlab.com" > ~/.git-credentials
    - git remote set-url origin https://argocd-ci-push:${ARGOCD_GITLAB_ACCESS_TOKEN}@gitlab.com/fireblocks/devops/iac/argocd.git
    - git config --global user.email "devops@fireblocks.com"
    - git config --global user.name "argocd-ci-push"
    - git config --global credential.helper store
    - touch .npmrc
    - npm config set --location=user @fireblocks:registry https://gitlab.com/api/v4/packages/npm/
    - npm config set --location=user '//gitlab.com/api/v4/packages/npm/:_authToken'
      "${NPM_REG_TOKEN}"
    - npm config set --location=user '//gitlab.com/api/v4/projects/20565764/packages/npm/:_authToken'
      "${NPM_REG_TOKEN}"
    - echo "@fireblocks:registry=https://gitlab.com/api/v4/packages/npm/">>.npmrc
    - echo "//gitlab.com/api/v4/packages/npm/:_authToken=${NPM_REG_TOKEN}">>.npmrc
    - echo "//gitlab.com/api/v4/projects/20565764/packages/npm/:_authToken=${NPM_REG_TOKEN}">>.npmrc
    - yarn global add @fireblocks/fb-cli
  script:
  - - echo "Self Service User Guide - https://fireblocks.atlassian.net/wiki/spaces/RD/pages/1413218873/Self+Service+User+Guide"
    - SVC_NAME=$([ "$SERVICE_NAME" ] && echo $SERVICE_NAME || echo $CI_PROJECT_NAME)
    - echo "Verifying deployment folder for ${SVC_NAME} service"
    - git clone ${DESTINATION_REPO} mono_repo
    - cd mono_repo
    - git fetch --all
    - git checkout ${STATE_BRANCH}
    - git pull origin ${STATE_BRANCH} --no-rebase
    - cd ../${SOURCE_PATH}
    - |
      # Define the paths
      values_file="values.yaml"

      # Check for values.yaml in the deployment folder
      if [ ! -f "$values_file" ]; then
          echo "Error: The values.yaml file is missing in the ${SOURCE_PATH} folder."
          exit 1
      fi

      echo "Success: All required files are present"
    - |
      # Directory to check
      DIR_TO_CHECK="overrides/"

      # List of allowed files
      ALLOWED_PATTERN=$(printf "|%s" "nonprod-tier.yaml" "prod-tier.yaml" "iac-dev.yaml" "localstack.yaml" "dev1.yaml" "dev2.yaml" "dev3.yaml" "dev4.yaml" "dev5.yaml" "dev6.yaml" "dev7.yaml" "dev8.yaml" "dev9.yaml" "dev10.yaml" "dev11.yaml" "dev11.yaml" "dev12.yaml" "dev13.yaml" "dev14.yaml" "dev15.yaml" "pre1.yaml" "stage.yaml" "sandbox.yaml" "eu-prod.yaml" "eu2-prod.yaml" "bnym-dev.yaml" "bnym-prod.yaml" "us-prod.yaml" | cut -c 2-)

      # Flag to track if there are disallowed files
      DISALLOWED_FOUND=false

      # Check for files in the directory that are not in the allowed list
      for file in "$DIR_TO_CHECK"/*; do
        # Get the base name of the file
        filename=$(basename "$file")

        # Check if the filename is in the allowed list
        if [[ ! $filename =~ ^($ALLOWED_PATTERN)$ ]]; then
          echo "Disallowed file found: $filename"
          DISALLOWED_FOUND=true
        fi
      done

      # Final output
      if $DISALLOWED_FOUND; then
        echo "Some files are not allowed."
        exit 1
      else
        echo "All files are allowed."
      fi
    - echo "Linting deployment yaml files"
    - cp ../mono_repo/services/schema/*.yaml .
    - cp ../mono_repo/services/schema/appconfig_schema.json .
    - cp ../mono_repo/services/schema/main_appconfig.json appconfig.json
    - cp ../mono_repo/services/schema/yamllint_rules.yaml yamllint_rules.yaml
    - yamllint --list-files **/*.yaml *.yaml
    - yamllint -s **/*.yaml *.yaml -c yamllint_rules.yaml
    - echo "Validating deployment yaml schema"
    - yamale -s base_values_schema.yaml values.yaml
    - yamale -s tier_values_schema.yaml overrides/prod-tier.yaml
    - yamale -s tier_values_schema.yaml overrides/nonprod-tier.yaml
    - |
      # Iterate over all yaml files in the overrides folder
      for file in overrides/*.yaml; do
          # Extract the filename from the path
          filename=$(basename -- "$file")

          # Check if the file is not prod-tier.yaml or nonprod-tier.yaml
          if [[ "$filename" != "prod-tier.yaml" ]] && [[ "$filename" != "nonprod-tier.yaml" ]]; then
              # Run yamale command on the file
              yamale -s env_values_schema.yaml "$file"
          fi
      done
    - "# Iterate over all yaml files in the overrides folder - validate_resources.sh\nif
      [[ -v ENGINE && \"$ENGINE\" == \"argocd\" ]]; then\n  export CD_INFRA_PROJECT_ID=61508954\n
      \ curl --header \"PRIVATE-TOKEN: $CD_CPU_RAM_REQUEST_LIMIT_READ_ONLY\"  \"https://gitlab.com/api/v4/projects/$CD_INFRA_PROJECT_ID/repository/files/ci-infra%2Fscripts%2Fvalidate_resources.sh/raw?ref=main\"
      -o \"$CI_PROJECT_DIR/validate_resources.sh\"\n  echo \"chmod +x $CI_PROJECT_DIR/validate_resources.sh\"
      \n  chmod +x \"$CI_PROJECT_DIR/validate_resources.sh\"\n  echo \"Searching for
      environments values files...\" \n  ENV_FILES_LIST=$(yamllint --list-files **/*.yaml
      *.yaml | grep -vE 'env_values_schema\\.yaml|tier_values_schema\\.yaml|base_values_schema\\.yaml|yamllint_rules\\.yaml|.*prod-tier\\.yaml|values.yaml'
      || true)\n  if [[ -n \"$ENV_FILES_LIST\" ]]; then\n    echo \"Found environments
      values files\"\n    while IFS= read -r file; do\n      filename=$(basename --
      \"$file\")\n      if [[ \"$filename\" =~ ^(dev[1-9]|dev10|stage|pre1).yaml$
      ]]; then\n        tier_file=\"overrides/nonprod-tier.yaml\"\n      else\n        tier_file=\"overrides/prod-tier.yaml\"
      \ \n      fi\n      echo \"values.yaml <-- $tier_file <-- $file\"\n      yq
      eval-all '. as $item ireduce ({}; . * $item)' values.yaml \"$tier_file\" \"$file\"
      | bash \"$CI_PROJECT_DIR/validate_resources.sh\" -\n    done <<< \"$ENV_FILES_LIST\"\n
      \ else\n    echo \"No environments values files were found. Continuing to the
      tier files.\"\n  fi\necho \"values.yaml <-- overrides/nonprod-tier.yaml\"\nyq
      eval-all '. as $item ireduce ({}; . * $item)' values.yaml overrides/nonprod-tier.yaml
      | bash \"$CI_PROJECT_DIR/validate_resources.sh\" -\necho \"values.yaml <-- overrides/prod-tier.yaml\"
      \nyq eval-all '. as $item ireduce ({}; . * $item)' values.yaml overrides/prod-tier.yaml
      | bash \"$CI_PROJECT_DIR/validate_resources.sh\" -\nelse\n  echo \"Skipping
      resource validation: ENGINE is not set to 'argocd'.\"\nfi\n"
    - ajv validate -s appconfig_schema.json -d appconfig.json
    - echo "Resources verified successfully"
    - echo "Validate filter_policy if exists - should be a valid JSON object"
    - fb deployment:validate . --filter-policy
  - cd ../mono_repo
  - ENV_DESTINATION_PATH=$(echo "${DESTINATION_PATH}/${SVC_NAME}/${ENV}")
  - echo "Copying ${SOURCE_PATH} folder from ${SVC_NAME} service to argocd mono repo
    destination folder at ${ENV_DESTINATION_PATH}"
  - mkdir -pv ${ENV_DESTINATION_PATH}/overrides
  - rm ${ENV_DESTINATION_PATH}/overrides/${ENV}.yaml || true
  - cp  ../${SOURCE_PATH}/values.yaml ${ENV_DESTINATION_PATH}
  - cp ../${SOURCE_PATH}/overrides/${ENV}.yaml  ${ENV_DESTINATION_PATH}/overrides
    || true
  - cp ../${SOURCE_PATH}/overrides/*-tier.yaml  ${ENV_DESTINATION_PATH}/overrides
    || true
  - if [ ! -f ${ENV_DESTINATION_PATH}/appconfig.json ]; then cp ../mono_repo/services/schema/main_appconfig.json
    ${ENV_DESTINATION_PATH}/appconfig.json; fi
  - git status
  - echo "Adding changes to Git"
  - git add ${DESTINATION_PATH}
  - git status
  - COUNT=$(git diff --numstat ${STATE_BRANCH} | awk '{added += $1; deleted += $2}
    END {print added + deleted}')
  - |
    if [ "$COUNT" -eq 0 ]; then
      echo "No changes detected under ${CI_PROJECT_NAME}/${SOURCE_PATH}, exiting"
      exit 0
    fi
  - echo "Committing changes"
  - git commit -m "${CI_JOB_NAME}"
  - echo "Pushing changes to remote"
  - git pull --rebase
  - git status
  - "MAX_RETRIES=3\nINITIAL_DELAY=5\nsuccess=false\n\nfor attempt in $(seq 1 $MAX_RETRIES);
    do\n  if git push; then\n    echo -e \"\\e[32mPush successful\\e[0m\"\n    success=true\n
    \   break\n  else\n    echo -e \"\\e[33mPush failed, retrying ($attempt/$MAX_RETRIES)...\\e[0m\"\n
    \   git pull --rebase\n    \n    # Calculate backoff delay (5s, then 10s, then
    20s)\n    BACKOFF_DELAY=$((INITIAL_DELAY * 2**(attempt-1)))\n    echo \"Waiting
    ${BACKOFF_DELAY} seconds before next attempt...\"\n    sleep $BACKOFF_DELAY\n
    \ fi\ndone\n\nif [ \"$success\" != \"true\" ]; then\n  echo -e \"\\e[31mFailed
    to push after $MAX_RETRIES attempts\\e[0m\"\n  exit 1\nfi\n"
  - git status
  - echo "Resources published to argocd mono repo"
  variables:
    DESTINATION_REPO: https://gitlab.com/fireblocks/devops/iac/argocd.git
    DESTINATION_PROJECT_ID: 50521873
    SOURCE_PATH: deployment
    DESTINATION_PATH: services/shell
    STATE_BRANCH: main
    GITLAB_API_URL: https://gitlab.com/api/v4/projects
    TEMPLATE_REF: "$TEMPLATE_REF"
    GITLAB_RUNNER_TAG: stage-application-gitlab-runner
    ENV: stage
  extends: ".publish_resources_dev"
".publish_resources_pre1":
  stage: configure
  retry:
    max: 2
    when:
    - script_failure
  tags:
  - "${GITLAB_RUNNER_TAG}"
  before_script:
  - printf "%s:%s\n" DESTINATION_REPO "$DESTINATION_REPO" DESTINATION_PROJECT_ID "$DESTINATION_PROJECT_ID"
    SOURCE_PATH "$SOURCE_PATH" DESTINATION_PATH "$DESTINATION_PATH" STATE_BRANCH "$STATE_BRANCH"
    GITLAB_API_URL "$GITLAB_API_URL"
  - |
    if [ ! -d "$SOURCE_PATH" ]; then
      echo "$SOURCE_PATH directory does not exist. Exiting job successfully."
      exit 0
    fi
    echo "$SOURCE_PATH directory exists. Continuing with deployment."
  - - apk update
    - apk add curl jq yq py3-pip
    - pip3 install --upgrade pip
    - pip3 install yamllint
    - pip3 install yamale --break-system-packages
    - npm install -g ajv-cli
    - echo "Configuring Git"
    - echo "https://argocd-ci-push:${ARGOCD_GITLAB_ACCESS_TOKEN}@gitlab.com" > ~/.git-credentials
    - git remote set-url origin https://argocd-ci-push:${ARGOCD_GITLAB_ACCESS_TOKEN}@gitlab.com/fireblocks/devops/iac/argocd.git
    - git config --global user.email "devops@fireblocks.com"
    - git config --global user.name "argocd-ci-push"
    - git config --global credential.helper store
    - touch .npmrc
    - npm config set --location=user @fireblocks:registry https://gitlab.com/api/v4/packages/npm/
    - npm config set --location=user '//gitlab.com/api/v4/packages/npm/:_authToken'
      "${NPM_REG_TOKEN}"
    - npm config set --location=user '//gitlab.com/api/v4/projects/20565764/packages/npm/:_authToken'
      "${NPM_REG_TOKEN}"
    - echo "@fireblocks:registry=https://gitlab.com/api/v4/packages/npm/">>.npmrc
    - echo "//gitlab.com/api/v4/packages/npm/:_authToken=${NPM_REG_TOKEN}">>.npmrc
    - echo "//gitlab.com/api/v4/projects/20565764/packages/npm/:_authToken=${NPM_REG_TOKEN}">>.npmrc
    - yarn global add @fireblocks/fb-cli
  script:
  - - echo "Self Service User Guide - https://fireblocks.atlassian.net/wiki/spaces/RD/pages/1413218873/Self+Service+User+Guide"
    - SVC_NAME=$([ "$SERVICE_NAME" ] && echo $SERVICE_NAME || echo $CI_PROJECT_NAME)
    - echo "Verifying deployment folder for ${SVC_NAME} service"
    - git clone ${DESTINATION_REPO} mono_repo
    - cd mono_repo
    - git fetch --all
    - git checkout ${STATE_BRANCH}
    - git pull origin ${STATE_BRANCH} --no-rebase
    - cd ../${SOURCE_PATH}
    - |
      # Define the paths
      values_file="values.yaml"

      # Check for values.yaml in the deployment folder
      if [ ! -f "$values_file" ]; then
          echo "Error: The values.yaml file is missing in the ${SOURCE_PATH} folder."
          exit 1
      fi

      echo "Success: All required files are present"
    - |
      # Directory to check
      DIR_TO_CHECK="overrides/"

      # List of allowed files
      ALLOWED_PATTERN=$(printf "|%s" "nonprod-tier.yaml" "prod-tier.yaml" "iac-dev.yaml" "localstack.yaml" "dev1.yaml" "dev2.yaml" "dev3.yaml" "dev4.yaml" "dev5.yaml" "dev6.yaml" "dev7.yaml" "dev8.yaml" "dev9.yaml" "dev10.yaml" "dev11.yaml" "dev11.yaml" "dev12.yaml" "dev13.yaml" "dev14.yaml" "dev15.yaml" "pre1.yaml" "stage.yaml" "sandbox.yaml" "eu-prod.yaml" "eu2-prod.yaml" "bnym-dev.yaml" "bnym-prod.yaml" "us-prod.yaml" | cut -c 2-)

      # Flag to track if there are disallowed files
      DISALLOWED_FOUND=false

      # Check for files in the directory that are not in the allowed list
      for file in "$DIR_TO_CHECK"/*; do
        # Get the base name of the file
        filename=$(basename "$file")

        # Check if the filename is in the allowed list
        if [[ ! $filename =~ ^($ALLOWED_PATTERN)$ ]]; then
          echo "Disallowed file found: $filename"
          DISALLOWED_FOUND=true
        fi
      done

      # Final output
      if $DISALLOWED_FOUND; then
        echo "Some files are not allowed."
        exit 1
      else
        echo "All files are allowed."
      fi
    - echo "Linting deployment yaml files"
    - cp ../mono_repo/services/schema/*.yaml .
    - cp ../mono_repo/services/schema/appconfig_schema.json .
    - cp ../mono_repo/services/schema/main_appconfig.json appconfig.json
    - cp ../mono_repo/services/schema/yamllint_rules.yaml yamllint_rules.yaml
    - yamllint --list-files **/*.yaml *.yaml
    - yamllint -s **/*.yaml *.yaml -c yamllint_rules.yaml
    - echo "Validating deployment yaml schema"
    - yamale -s base_values_schema.yaml values.yaml
    - yamale -s tier_values_schema.yaml overrides/prod-tier.yaml
    - yamale -s tier_values_schema.yaml overrides/nonprod-tier.yaml
    - |
      # Iterate over all yaml files in the overrides folder
      for file in overrides/*.yaml; do
          # Extract the filename from the path
          filename=$(basename -- "$file")

          # Check if the file is not prod-tier.yaml or nonprod-tier.yaml
          if [[ "$filename" != "prod-tier.yaml" ]] && [[ "$filename" != "nonprod-tier.yaml" ]]; then
              # Run yamale command on the file
              yamale -s env_values_schema.yaml "$file"
          fi
      done
    - "# Iterate over all yaml files in the overrides folder - validate_resources.sh\nif
      [[ -v ENGINE && \"$ENGINE\" == \"argocd\" ]]; then\n  export CD_INFRA_PROJECT_ID=61508954\n
      \ curl --header \"PRIVATE-TOKEN: $CD_CPU_RAM_REQUEST_LIMIT_READ_ONLY\"  \"https://gitlab.com/api/v4/projects/$CD_INFRA_PROJECT_ID/repository/files/ci-infra%2Fscripts%2Fvalidate_resources.sh/raw?ref=main\"
      -o \"$CI_PROJECT_DIR/validate_resources.sh\"\n  echo \"chmod +x $CI_PROJECT_DIR/validate_resources.sh\"
      \n  chmod +x \"$CI_PROJECT_DIR/validate_resources.sh\"\n  echo \"Searching for
      environments values files...\" \n  ENV_FILES_LIST=$(yamllint --list-files **/*.yaml
      *.yaml | grep -vE 'env_values_schema\\.yaml|tier_values_schema\\.yaml|base_values_schema\\.yaml|yamllint_rules\\.yaml|.*prod-tier\\.yaml|values.yaml'
      || true)\n  if [[ -n \"$ENV_FILES_LIST\" ]]; then\n    echo \"Found environments
      values files\"\n    while IFS= read -r file; do\n      filename=$(basename --
      \"$file\")\n      if [[ \"$filename\" =~ ^(dev[1-9]|dev10|stage|pre1).yaml$
      ]]; then\n        tier_file=\"overrides/nonprod-tier.yaml\"\n      else\n        tier_file=\"overrides/prod-tier.yaml\"
      \ \n      fi\n      echo \"values.yaml <-- $tier_file <-- $file\"\n      yq
      eval-all '. as $item ireduce ({}; . * $item)' values.yaml \"$tier_file\" \"$file\"
      | bash \"$CI_PROJECT_DIR/validate_resources.sh\" -\n    done <<< \"$ENV_FILES_LIST\"\n
      \ else\n    echo \"No environments values files were found. Continuing to the
      tier files.\"\n  fi\necho \"values.yaml <-- overrides/nonprod-tier.yaml\"\nyq
      eval-all '. as $item ireduce ({}; . * $item)' values.yaml overrides/nonprod-tier.yaml
      | bash \"$CI_PROJECT_DIR/validate_resources.sh\" -\necho \"values.yaml <-- overrides/prod-tier.yaml\"
      \nyq eval-all '. as $item ireduce ({}; . * $item)' values.yaml overrides/prod-tier.yaml
      | bash \"$CI_PROJECT_DIR/validate_resources.sh\" -\nelse\n  echo \"Skipping
      resource validation: ENGINE is not set to 'argocd'.\"\nfi\n"
    - ajv validate -s appconfig_schema.json -d appconfig.json
    - echo "Resources verified successfully"
    - echo "Validate filter_policy if exists - should be a valid JSON object"
    - fb deployment:validate . --filter-policy
  - cd ../mono_repo
  - ENV_DESTINATION_PATH=$(echo "${DESTINATION_PATH}/${SVC_NAME}/${ENV}")
  - echo "Copying ${SOURCE_PATH} folder from ${SVC_NAME} service to argocd mono repo
    destination folder at ${ENV_DESTINATION_PATH}"
  - mkdir -pv ${ENV_DESTINATION_PATH}/overrides
  - rm ${ENV_DESTINATION_PATH}/overrides/${ENV}.yaml || true
  - cp  ../${SOURCE_PATH}/values.yaml ${ENV_DESTINATION_PATH}
  - cp ../${SOURCE_PATH}/overrides/${ENV}.yaml  ${ENV_DESTINATION_PATH}/overrides
    || true
  - cp ../${SOURCE_PATH}/overrides/*-tier.yaml  ${ENV_DESTINATION_PATH}/overrides
    || true
  - if [ ! -f ${ENV_DESTINATION_PATH}/appconfig.json ]; then cp ../mono_repo/services/schema/main_appconfig.json
    ${ENV_DESTINATION_PATH}/appconfig.json; fi
  - git status
  - echo "Adding changes to Git"
  - git add ${DESTINATION_PATH}
  - git status
  - COUNT=$(git diff --numstat ${STATE_BRANCH} | awk '{added += $1; deleted += $2}
    END {print added + deleted}')
  - |
    if [ "$COUNT" -eq 0 ]; then
      echo "No changes detected under ${CI_PROJECT_NAME}/${SOURCE_PATH}, exiting"
      exit 0
    fi
  - echo "Committing changes"
  - git commit -m "${CI_JOB_NAME}"
  - echo "Pushing changes to remote"
  - git pull --rebase
  - git status
  - "MAX_RETRIES=3\nINITIAL_DELAY=5\nsuccess=false\n\nfor attempt in $(seq 1 $MAX_RETRIES);
    do\n  if git push; then\n    echo -e \"\\e[32mPush successful\\e[0m\"\n    success=true\n
    \   break\n  else\n    echo -e \"\\e[33mPush failed, retrying ($attempt/$MAX_RETRIES)...\\e[0m\"\n
    \   git pull --rebase\n    \n    # Calculate backoff delay (5s, then 10s, then
    20s)\n    BACKOFF_DELAY=$((INITIAL_DELAY * 2**(attempt-1)))\n    echo \"Waiting
    ${BACKOFF_DELAY} seconds before next attempt...\"\n    sleep $BACKOFF_DELAY\n
    \ fi\ndone\n\nif [ \"$success\" != \"true\" ]; then\n  echo -e \"\\e[31mFailed
    to push after $MAX_RETRIES attempts\\e[0m\"\n  exit 1\nfi\n"
  - git status
  - echo "Resources published to argocd mono repo"
  variables:
    DESTINATION_REPO: https://gitlab.com/fireblocks/devops/iac/argocd.git
    DESTINATION_PROJECT_ID: 50521873
    SOURCE_PATH: deployment
    DESTINATION_PATH: services/shell
    STATE_BRANCH: main
    GITLAB_API_URL: https://gitlab.com/api/v4/projects
    TEMPLATE_REF: "$TEMPLATE_REF"
    GITLAB_RUNNER_TAG: pre1-application-gitlab-runner
    ENV: pre1
  extends: ".publish_resources_dev"
".publish_resources_dev5":
  stage: configure
  retry:
    max: 2
    when:
    - script_failure
  tags:
  - "${GITLAB_RUNNER_TAG}"
  before_script:
  - printf "%s:%s\n" DESTINATION_REPO "$DESTINATION_REPO" DESTINATION_PROJECT_ID "$DESTINATION_PROJECT_ID"
    SOURCE_PATH "$SOURCE_PATH" DESTINATION_PATH "$DESTINATION_PATH" STATE_BRANCH "$STATE_BRANCH"
    GITLAB_API_URL "$GITLAB_API_URL"
  - |
    if [ ! -d "$SOURCE_PATH" ]; then
      echo "$SOURCE_PATH directory does not exist. Exiting job successfully."
      exit 0
    fi
    echo "$SOURCE_PATH directory exists. Continuing with deployment."
  - - apk update
    - apk add curl jq yq py3-pip
    - pip3 install --upgrade pip
    - pip3 install yamllint
    - pip3 install yamale --break-system-packages
    - npm install -g ajv-cli
    - echo "Configuring Git"
    - echo "https://argocd-ci-push:${ARGOCD_GITLAB_ACCESS_TOKEN}@gitlab.com" > ~/.git-credentials
    - git remote set-url origin https://argocd-ci-push:${ARGOCD_GITLAB_ACCESS_TOKEN}@gitlab.com/fireblocks/devops/iac/argocd.git
    - git config --global user.email "devops@fireblocks.com"
    - git config --global user.name "argocd-ci-push"
    - git config --global credential.helper store
    - touch .npmrc
    - npm config set --location=user @fireblocks:registry https://gitlab.com/api/v4/packages/npm/
    - npm config set --location=user '//gitlab.com/api/v4/packages/npm/:_authToken'
      "${NPM_REG_TOKEN}"
    - npm config set --location=user '//gitlab.com/api/v4/projects/20565764/packages/npm/:_authToken'
      "${NPM_REG_TOKEN}"
    - echo "@fireblocks:registry=https://gitlab.com/api/v4/packages/npm/">>.npmrc
    - echo "//gitlab.com/api/v4/packages/npm/:_authToken=${NPM_REG_TOKEN}">>.npmrc
    - echo "//gitlab.com/api/v4/projects/20565764/packages/npm/:_authToken=${NPM_REG_TOKEN}">>.npmrc
    - yarn global add @fireblocks/fb-cli
  script:
  - - echo "Self Service User Guide - https://fireblocks.atlassian.net/wiki/spaces/RD/pages/1413218873/Self+Service+User+Guide"
    - SVC_NAME=$([ "$SERVICE_NAME" ] && echo $SERVICE_NAME || echo $CI_PROJECT_NAME)
    - echo "Verifying deployment folder for ${SVC_NAME} service"
    - git clone ${DESTINATION_REPO} mono_repo
    - cd mono_repo
    - git fetch --all
    - git checkout ${STATE_BRANCH}
    - git pull origin ${STATE_BRANCH} --no-rebase
    - cd ../${SOURCE_PATH}
    - |
      # Define the paths
      values_file="values.yaml"

      # Check for values.yaml in the deployment folder
      if [ ! -f "$values_file" ]; then
          echo "Error: The values.yaml file is missing in the ${SOURCE_PATH} folder."
          exit 1
      fi

      echo "Success: All required files are present"
    - |
      # Directory to check
      DIR_TO_CHECK="overrides/"

      # List of allowed files
      ALLOWED_PATTERN=$(printf "|%s" "nonprod-tier.yaml" "prod-tier.yaml" "iac-dev.yaml" "localstack.yaml" "dev1.yaml" "dev2.yaml" "dev3.yaml" "dev4.yaml" "dev5.yaml" "dev6.yaml" "dev7.yaml" "dev8.yaml" "dev9.yaml" "dev10.yaml" "dev11.yaml" "dev11.yaml" "dev12.yaml" "dev13.yaml" "dev14.yaml" "dev15.yaml" "pre1.yaml" "stage.yaml" "sandbox.yaml" "eu-prod.yaml" "eu2-prod.yaml" "bnym-dev.yaml" "bnym-prod.yaml" "us-prod.yaml" | cut -c 2-)

      # Flag to track if there are disallowed files
      DISALLOWED_FOUND=false

      # Check for files in the directory that are not in the allowed list
      for file in "$DIR_TO_CHECK"/*; do
        # Get the base name of the file
        filename=$(basename "$file")

        # Check if the filename is in the allowed list
        if [[ ! $filename =~ ^($ALLOWED_PATTERN)$ ]]; then
          echo "Disallowed file found: $filename"
          DISALLOWED_FOUND=true
        fi
      done

      # Final output
      if $DISALLOWED_FOUND; then
        echo "Some files are not allowed."
        exit 1
      else
        echo "All files are allowed."
      fi
    - echo "Linting deployment yaml files"
    - cp ../mono_repo/services/schema/*.yaml .
    - cp ../mono_repo/services/schema/appconfig_schema.json .
    - cp ../mono_repo/services/schema/main_appconfig.json appconfig.json
    - cp ../mono_repo/services/schema/yamllint_rules.yaml yamllint_rules.yaml
    - yamllint --list-files **/*.yaml *.yaml
    - yamllint -s **/*.yaml *.yaml -c yamllint_rules.yaml
    - echo "Validating deployment yaml schema"
    - yamale -s base_values_schema.yaml values.yaml
    - yamale -s tier_values_schema.yaml overrides/prod-tier.yaml
    - yamale -s tier_values_schema.yaml overrides/nonprod-tier.yaml
    - |
      # Iterate over all yaml files in the overrides folder
      for file in overrides/*.yaml; do
          # Extract the filename from the path
          filename=$(basename -- "$file")

          # Check if the file is not prod-tier.yaml or nonprod-tier.yaml
          if [[ "$filename" != "prod-tier.yaml" ]] && [[ "$filename" != "nonprod-tier.yaml" ]]; then
              # Run yamale command on the file
              yamale -s env_values_schema.yaml "$file"
          fi
      done
    - "# Iterate over all yaml files in the overrides folder - validate_resources.sh\nif
      [[ -v ENGINE && \"$ENGINE\" == \"argocd\" ]]; then\n  export CD_INFRA_PROJECT_ID=61508954\n
      \ curl --header \"PRIVATE-TOKEN: $CD_CPU_RAM_REQUEST_LIMIT_READ_ONLY\"  \"https://gitlab.com/api/v4/projects/$CD_INFRA_PROJECT_ID/repository/files/ci-infra%2Fscripts%2Fvalidate_resources.sh/raw?ref=main\"
      -o \"$CI_PROJECT_DIR/validate_resources.sh\"\n  echo \"chmod +x $CI_PROJECT_DIR/validate_resources.sh\"
      \n  chmod +x \"$CI_PROJECT_DIR/validate_resources.sh\"\n  echo \"Searching for
      environments values files...\" \n  ENV_FILES_LIST=$(yamllint --list-files **/*.yaml
      *.yaml | grep -vE 'env_values_schema\\.yaml|tier_values_schema\\.yaml|base_values_schema\\.yaml|yamllint_rules\\.yaml|.*prod-tier\\.yaml|values.yaml'
      || true)\n  if [[ -n \"$ENV_FILES_LIST\" ]]; then\n    echo \"Found environments
      values files\"\n    while IFS= read -r file; do\n      filename=$(basename --
      \"$file\")\n      if [[ \"$filename\" =~ ^(dev[1-9]|dev10|stage|pre1).yaml$
      ]]; then\n        tier_file=\"overrides/nonprod-tier.yaml\"\n      else\n        tier_file=\"overrides/prod-tier.yaml\"
      \ \n      fi\n      echo \"values.yaml <-- $tier_file <-- $file\"\n      yq
      eval-all '. as $item ireduce ({}; . * $item)' values.yaml \"$tier_file\" \"$file\"
      | bash \"$CI_PROJECT_DIR/validate_resources.sh\" -\n    done <<< \"$ENV_FILES_LIST\"\n
      \ else\n    echo \"No environments values files were found. Continuing to the
      tier files.\"\n  fi\necho \"values.yaml <-- overrides/nonprod-tier.yaml\"\nyq
      eval-all '. as $item ireduce ({}; . * $item)' values.yaml overrides/nonprod-tier.yaml
      | bash \"$CI_PROJECT_DIR/validate_resources.sh\" -\necho \"values.yaml <-- overrides/prod-tier.yaml\"
      \nyq eval-all '. as $item ireduce ({}; . * $item)' values.yaml overrides/prod-tier.yaml
      | bash \"$CI_PROJECT_DIR/validate_resources.sh\" -\nelse\n  echo \"Skipping
      resource validation: ENGINE is not set to 'argocd'.\"\nfi\n"
    - ajv validate -s appconfig_schema.json -d appconfig.json
    - echo "Resources verified successfully"
    - echo "Validate filter_policy if exists - should be a valid JSON object"
    - fb deployment:validate . --filter-policy
  - cd ../mono_repo
  - ENV_DESTINATION_PATH=$(echo "${DESTINATION_PATH}/${SVC_NAME}/${ENV}")
  - echo "Copying ${SOURCE_PATH} folder from ${SVC_NAME} service to argocd mono repo
    destination folder at ${ENV_DESTINATION_PATH}"
  - mkdir -pv ${ENV_DESTINATION_PATH}/overrides
  - rm ${ENV_DESTINATION_PATH}/overrides/${ENV}.yaml || true
  - cp  ../${SOURCE_PATH}/values.yaml ${ENV_DESTINATION_PATH}
  - cp ../${SOURCE_PATH}/overrides/${ENV}.yaml  ${ENV_DESTINATION_PATH}/overrides
    || true
  - cp ../${SOURCE_PATH}/overrides/*-tier.yaml  ${ENV_DESTINATION_PATH}/overrides
    || true
  - if [ ! -f ${ENV_DESTINATION_PATH}/appconfig.json ]; then cp ../mono_repo/services/schema/main_appconfig.json
    ${ENV_DESTINATION_PATH}/appconfig.json; fi
  - git status
  - echo "Adding changes to Git"
  - git add ${DESTINATION_PATH}
  - git status
  - COUNT=$(git diff --numstat ${STATE_BRANCH} | awk '{added += $1; deleted += $2}
    END {print added + deleted}')
  - |
    if [ "$COUNT" -eq 0 ]; then
      echo "No changes detected under ${CI_PROJECT_NAME}/${SOURCE_PATH}, exiting"
      exit 0
    fi
  - echo "Committing changes"
  - git commit -m "${CI_JOB_NAME}"
  - echo "Pushing changes to remote"
  - git pull --rebase
  - git status
  - "MAX_RETRIES=3\nINITIAL_DELAY=5\nsuccess=false\n\nfor attempt in $(seq 1 $MAX_RETRIES);
    do\n  if git push; then\n    echo -e \"\\e[32mPush successful\\e[0m\"\n    success=true\n
    \   break\n  else\n    echo -e \"\\e[33mPush failed, retrying ($attempt/$MAX_RETRIES)...\\e[0m\"\n
    \   git pull --rebase\n    \n    # Calculate backoff delay (5s, then 10s, then
    20s)\n    BACKOFF_DELAY=$((INITIAL_DELAY * 2**(attempt-1)))\n    echo \"Waiting
    ${BACKOFF_DELAY} seconds before next attempt...\"\n    sleep $BACKOFF_DELAY\n
    \ fi\ndone\n\nif [ \"$success\" != \"true\" ]; then\n  echo -e \"\\e[31mFailed
    to push after $MAX_RETRIES attempts\\e[0m\"\n  exit 1\nfi\n"
  - git status
  - echo "Resources published to argocd mono repo"
  variables:
    DESTINATION_REPO: https://gitlab.com/fireblocks/devops/iac/argocd.git
    DESTINATION_PROJECT_ID: 50521873
    SOURCE_PATH: deployment
    DESTINATION_PATH: services/shell
    STATE_BRANCH: main
    GITLAB_API_URL: https://gitlab.com/api/v4/projects
    TEMPLATE_REF: "$TEMPLATE_REF"
    GITLAB_RUNNER_TAG: devx-application-gitlab-runner
    ENV: dev5
  extends: ".publish_resources_dev"
".publish_resources_dev6":
  stage: configure
  retry:
    max: 2
    when:
    - script_failure
  tags:
  - "${GITLAB_RUNNER_TAG}"
  before_script:
  - printf "%s:%s\n" DESTINATION_REPO "$DESTINATION_REPO" DESTINATION_PROJECT_ID "$DESTINATION_PROJECT_ID"
    SOURCE_PATH "$SOURCE_PATH" DESTINATION_PATH "$DESTINATION_PATH" STATE_BRANCH "$STATE_BRANCH"
    GITLAB_API_URL "$GITLAB_API_URL"
  - |
    if [ ! -d "$SOURCE_PATH" ]; then
      echo "$SOURCE_PATH directory does not exist. Exiting job successfully."
      exit 0
    fi
    echo "$SOURCE_PATH directory exists. Continuing with deployment."
  - - apk update
    - apk add curl jq yq py3-pip
    - pip3 install --upgrade pip
    - pip3 install yamllint
    - pip3 install yamale --break-system-packages
    - npm install -g ajv-cli
    - echo "Configuring Git"
    - echo "https://argocd-ci-push:${ARGOCD_GITLAB_ACCESS_TOKEN}@gitlab.com" > ~/.git-credentials
    - git remote set-url origin https://argocd-ci-push:${ARGOCD_GITLAB_ACCESS_TOKEN}@gitlab.com/fireblocks/devops/iac/argocd.git
    - git config --global user.email "devops@fireblocks.com"
    - git config --global user.name "argocd-ci-push"
    - git config --global credential.helper store
    - touch .npmrc
    - npm config set --location=user @fireblocks:registry https://gitlab.com/api/v4/packages/npm/
    - npm config set --location=user '//gitlab.com/api/v4/packages/npm/:_authToken'
      "${NPM_REG_TOKEN}"
    - npm config set --location=user '//gitlab.com/api/v4/projects/20565764/packages/npm/:_authToken'
      "${NPM_REG_TOKEN}"
    - echo "@fireblocks:registry=https://gitlab.com/api/v4/packages/npm/">>.npmrc
    - echo "//gitlab.com/api/v4/packages/npm/:_authToken=${NPM_REG_TOKEN}">>.npmrc
    - echo "//gitlab.com/api/v4/projects/20565764/packages/npm/:_authToken=${NPM_REG_TOKEN}">>.npmrc
    - yarn global add @fireblocks/fb-cli
  script:
  - - echo "Self Service User Guide - https://fireblocks.atlassian.net/wiki/spaces/RD/pages/1413218873/Self+Service+User+Guide"
    - SVC_NAME=$([ "$SERVICE_NAME" ] && echo $SERVICE_NAME || echo $CI_PROJECT_NAME)
    - echo "Verifying deployment folder for ${SVC_NAME} service"
    - git clone ${DESTINATION_REPO} mono_repo
    - cd mono_repo
    - git fetch --all
    - git checkout ${STATE_BRANCH}
    - git pull origin ${STATE_BRANCH} --no-rebase
    - cd ../${SOURCE_PATH}
    - |
      # Define the paths
      values_file="values.yaml"

      # Check for values.yaml in the deployment folder
      if [ ! -f "$values_file" ]; then
          echo "Error: The values.yaml file is missing in the ${SOURCE_PATH} folder."
          exit 1
      fi

      echo "Success: All required files are present"
    - |
      # Directory to check
      DIR_TO_CHECK="overrides/"

      # List of allowed files
      ALLOWED_PATTERN=$(printf "|%s" "nonprod-tier.yaml" "prod-tier.yaml" "iac-dev.yaml" "localstack.yaml" "dev1.yaml" "dev2.yaml" "dev3.yaml" "dev4.yaml" "dev5.yaml" "dev6.yaml" "dev7.yaml" "dev8.yaml" "dev9.yaml" "dev10.yaml" "dev11.yaml" "dev11.yaml" "dev12.yaml" "dev13.yaml" "dev14.yaml" "dev15.yaml" "pre1.yaml" "stage.yaml" "sandbox.yaml" "eu-prod.yaml" "eu2-prod.yaml" "bnym-dev.yaml" "bnym-prod.yaml" "us-prod.yaml" | cut -c 2-)

      # Flag to track if there are disallowed files
      DISALLOWED_FOUND=false

      # Check for files in the directory that are not in the allowed list
      for file in "$DIR_TO_CHECK"/*; do
        # Get the base name of the file
        filename=$(basename "$file")

        # Check if the filename is in the allowed list
        if [[ ! $filename =~ ^($ALLOWED_PATTERN)$ ]]; then
          echo "Disallowed file found: $filename"
          DISALLOWED_FOUND=true
        fi
      done

      # Final output
      if $DISALLOWED_FOUND; then
        echo "Some files are not allowed."
        exit 1
      else
        echo "All files are allowed."
      fi
    - echo "Linting deployment yaml files"
    - cp ../mono_repo/services/schema/*.yaml .
    - cp ../mono_repo/services/schema/appconfig_schema.json .
    - cp ../mono_repo/services/schema/main_appconfig.json appconfig.json
    - cp ../mono_repo/services/schema/yamllint_rules.yaml yamllint_rules.yaml
    - yamllint --list-files **/*.yaml *.yaml
    - yamllint -s **/*.yaml *.yaml -c yamllint_rules.yaml
    - echo "Validating deployment yaml schema"
    - yamale -s base_values_schema.yaml values.yaml
    - yamale -s tier_values_schema.yaml overrides/prod-tier.yaml
    - yamale -s tier_values_schema.yaml overrides/nonprod-tier.yaml
    - |
      # Iterate over all yaml files in the overrides folder
      for file in overrides/*.yaml; do
          # Extract the filename from the path
          filename=$(basename -- "$file")

          # Check if the file is not prod-tier.yaml or nonprod-tier.yaml
          if [[ "$filename" != "prod-tier.yaml" ]] && [[ "$filename" != "nonprod-tier.yaml" ]]; then
              # Run yamale command on the file
              yamale -s env_values_schema.yaml "$file"
          fi
      done
    - "# Iterate over all yaml files in the overrides folder - validate_resources.sh\nif
      [[ -v ENGINE && \"$ENGINE\" == \"argocd\" ]]; then\n  export CD_INFRA_PROJECT_ID=61508954\n
      \ curl --header \"PRIVATE-TOKEN: $CD_CPU_RAM_REQUEST_LIMIT_READ_ONLY\"  \"https://gitlab.com/api/v4/projects/$CD_INFRA_PROJECT_ID/repository/files/ci-infra%2Fscripts%2Fvalidate_resources.sh/raw?ref=main\"
      -o \"$CI_PROJECT_DIR/validate_resources.sh\"\n  echo \"chmod +x $CI_PROJECT_DIR/validate_resources.sh\"
      \n  chmod +x \"$CI_PROJECT_DIR/validate_resources.sh\"\n  echo \"Searching for
      environments values files...\" \n  ENV_FILES_LIST=$(yamllint --list-files **/*.yaml
      *.yaml | grep -vE 'env_values_schema\\.yaml|tier_values_schema\\.yaml|base_values_schema\\.yaml|yamllint_rules\\.yaml|.*prod-tier\\.yaml|values.yaml'
      || true)\n  if [[ -n \"$ENV_FILES_LIST\" ]]; then\n    echo \"Found environments
      values files\"\n    while IFS= read -r file; do\n      filename=$(basename --
      \"$file\")\n      if [[ \"$filename\" =~ ^(dev[1-9]|dev10|stage|pre1).yaml$
      ]]; then\n        tier_file=\"overrides/nonprod-tier.yaml\"\n      else\n        tier_file=\"overrides/prod-tier.yaml\"
      \ \n      fi\n      echo \"values.yaml <-- $tier_file <-- $file\"\n      yq
      eval-all '. as $item ireduce ({}; . * $item)' values.yaml \"$tier_file\" \"$file\"
      | bash \"$CI_PROJECT_DIR/validate_resources.sh\" -\n    done <<< \"$ENV_FILES_LIST\"\n
      \ else\n    echo \"No environments values files were found. Continuing to the
      tier files.\"\n  fi\necho \"values.yaml <-- overrides/nonprod-tier.yaml\"\nyq
      eval-all '. as $item ireduce ({}; . * $item)' values.yaml overrides/nonprod-tier.yaml
      | bash \"$CI_PROJECT_DIR/validate_resources.sh\" -\necho \"values.yaml <-- overrides/prod-tier.yaml\"
      \nyq eval-all '. as $item ireduce ({}; . * $item)' values.yaml overrides/prod-tier.yaml
      | bash \"$CI_PROJECT_DIR/validate_resources.sh\" -\nelse\n  echo \"Skipping
      resource validation: ENGINE is not set to 'argocd'.\"\nfi\n"
    - ajv validate -s appconfig_schema.json -d appconfig.json
    - echo "Resources verified successfully"
    - echo "Validate filter_policy if exists - should be a valid JSON object"
    - fb deployment:validate . --filter-policy
  - cd ../mono_repo
  - ENV_DESTINATION_PATH=$(echo "${DESTINATION_PATH}/${SVC_NAME}/${ENV}")
  - echo "Copying ${SOURCE_PATH} folder from ${SVC_NAME} service to argocd mono repo
    destination folder at ${ENV_DESTINATION_PATH}"
  - mkdir -pv ${ENV_DESTINATION_PATH}/overrides
  - rm ${ENV_DESTINATION_PATH}/overrides/${ENV}.yaml || true
  - cp  ../${SOURCE_PATH}/values.yaml ${ENV_DESTINATION_PATH}
  - cp ../${SOURCE_PATH}/overrides/${ENV}.yaml  ${ENV_DESTINATION_PATH}/overrides
    || true
  - cp ../${SOURCE_PATH}/overrides/*-tier.yaml  ${ENV_DESTINATION_PATH}/overrides
    || true
  - if [ ! -f ${ENV_DESTINATION_PATH}/appconfig.json ]; then cp ../mono_repo/services/schema/main_appconfig.json
    ${ENV_DESTINATION_PATH}/appconfig.json; fi
  - git status
  - echo "Adding changes to Git"
  - git add ${DESTINATION_PATH}
  - git status
  - COUNT=$(git diff --numstat ${STATE_BRANCH} | awk '{added += $1; deleted += $2}
    END {print added + deleted}')
  - |
    if [ "$COUNT" -eq 0 ]; then
      echo "No changes detected under ${CI_PROJECT_NAME}/${SOURCE_PATH}, exiting"
      exit 0
    fi
  - echo "Committing changes"
  - git commit -m "${CI_JOB_NAME}"
  - echo "Pushing changes to remote"
  - git pull --rebase
  - git status
  - "MAX_RETRIES=3\nINITIAL_DELAY=5\nsuccess=false\n\nfor attempt in $(seq 1 $MAX_RETRIES);
    do\n  if git push; then\n    echo -e \"\\e[32mPush successful\\e[0m\"\n    success=true\n
    \   break\n  else\n    echo -e \"\\e[33mPush failed, retrying ($attempt/$MAX_RETRIES)...\\e[0m\"\n
    \   git pull --rebase\n    \n    # Calculate backoff delay (5s, then 10s, then
    20s)\n    BACKOFF_DELAY=$((INITIAL_DELAY * 2**(attempt-1)))\n    echo \"Waiting
    ${BACKOFF_DELAY} seconds before next attempt...\"\n    sleep $BACKOFF_DELAY\n
    \ fi\ndone\n\nif [ \"$success\" != \"true\" ]; then\n  echo -e \"\\e[31mFailed
    to push after $MAX_RETRIES attempts\\e[0m\"\n  exit 1\nfi\n"
  - git status
  - echo "Resources published to argocd mono repo"
  variables:
    DESTINATION_REPO: https://gitlab.com/fireblocks/devops/iac/argocd.git
    DESTINATION_PROJECT_ID: 50521873
    SOURCE_PATH: deployment
    DESTINATION_PATH: services/shell
    STATE_BRANCH: main
    GITLAB_API_URL: https://gitlab.com/api/v4/projects
    TEMPLATE_REF: "$TEMPLATE_REF"
    GITLAB_RUNNER_TAG: devx-application-gitlab-runner
    ENV: dev6
  extends: ".publish_resources_dev"
".publish_resources_dev7":
  stage: configure
  retry:
    max: 2
    when:
    - script_failure
  tags:
  - "${GITLAB_RUNNER_TAG}"
  before_script:
  - printf "%s:%s\n" DESTINATION_REPO "$DESTINATION_REPO" DESTINATION_PROJECT_ID "$DESTINATION_PROJECT_ID"
    SOURCE_PATH "$SOURCE_PATH" DESTINATION_PATH "$DESTINATION_PATH" STATE_BRANCH "$STATE_BRANCH"
    GITLAB_API_URL "$GITLAB_API_URL"
  - |
    if [ ! -d "$SOURCE_PATH" ]; then
      echo "$SOURCE_PATH directory does not exist. Exiting job successfully."
      exit 0
    fi
    echo "$SOURCE_PATH directory exists. Continuing with deployment."
  - - apk update
    - apk add curl jq yq py3-pip
    - pip3 install --upgrade pip
    - pip3 install yamllint
    - pip3 install yamale --break-system-packages
    - npm install -g ajv-cli
    - echo "Configuring Git"
    - echo "https://argocd-ci-push:${ARGOCD_GITLAB_ACCESS_TOKEN}@gitlab.com" > ~/.git-credentials
    - git remote set-url origin https://argocd-ci-push:${ARGOCD_GITLAB_ACCESS_TOKEN}@gitlab.com/fireblocks/devops/iac/argocd.git
    - git config --global user.email "devops@fireblocks.com"
    - git config --global user.name "argocd-ci-push"
    - git config --global credential.helper store
    - touch .npmrc
    - npm config set --location=user @fireblocks:registry https://gitlab.com/api/v4/packages/npm/
    - npm config set --location=user '//gitlab.com/api/v4/packages/npm/:_authToken'
      "${NPM_REG_TOKEN}"
    - npm config set --location=user '//gitlab.com/api/v4/projects/20565764/packages/npm/:_authToken'
      "${NPM_REG_TOKEN}"
    - echo "@fireblocks:registry=https://gitlab.com/api/v4/packages/npm/">>.npmrc
    - echo "//gitlab.com/api/v4/packages/npm/:_authToken=${NPM_REG_TOKEN}">>.npmrc
    - echo "//gitlab.com/api/v4/projects/20565764/packages/npm/:_authToken=${NPM_REG_TOKEN}">>.npmrc
    - yarn global add @fireblocks/fb-cli
  script:
  - - echo "Self Service User Guide - https://fireblocks.atlassian.net/wiki/spaces/RD/pages/1413218873/Self+Service+User+Guide"
    - SVC_NAME=$([ "$SERVICE_NAME" ] && echo $SERVICE_NAME || echo $CI_PROJECT_NAME)
    - echo "Verifying deployment folder for ${SVC_NAME} service"
    - git clone ${DESTINATION_REPO} mono_repo
    - cd mono_repo
    - git fetch --all
    - git checkout ${STATE_BRANCH}
    - git pull origin ${STATE_BRANCH} --no-rebase
    - cd ../${SOURCE_PATH}
    - |
      # Define the paths
      values_file="values.yaml"

      # Check for values.yaml in the deployment folder
      if [ ! -f "$values_file" ]; then
          echo "Error: The values.yaml file is missing in the ${SOURCE_PATH} folder."
          exit 1
      fi

      echo "Success: All required files are present"
    - |
      # Directory to check
      DIR_TO_CHECK="overrides/"

      # List of allowed files
      ALLOWED_PATTERN=$(printf "|%s" "nonprod-tier.yaml" "prod-tier.yaml" "iac-dev.yaml" "localstack.yaml" "dev1.yaml" "dev2.yaml" "dev3.yaml" "dev4.yaml" "dev5.yaml" "dev6.yaml" "dev7.yaml" "dev8.yaml" "dev9.yaml" "dev10.yaml" "dev11.yaml" "dev11.yaml" "dev12.yaml" "dev13.yaml" "dev14.yaml" "dev15.yaml" "pre1.yaml" "stage.yaml" "sandbox.yaml" "eu-prod.yaml" "eu2-prod.yaml" "bnym-dev.yaml" "bnym-prod.yaml" "us-prod.yaml" | cut -c 2-)

      # Flag to track if there are disallowed files
      DISALLOWED_FOUND=false

      # Check for files in the directory that are not in the allowed list
      for file in "$DIR_TO_CHECK"/*; do
        # Get the base name of the file
        filename=$(basename "$file")

        # Check if the filename is in the allowed list
        if [[ ! $filename =~ ^($ALLOWED_PATTERN)$ ]]; then
          echo "Disallowed file found: $filename"
          DISALLOWED_FOUND=true
        fi
      done

      # Final output
      if $DISALLOWED_FOUND; then
        echo "Some files are not allowed."
        exit 1
      else
        echo "All files are allowed."
      fi
    - echo "Linting deployment yaml files"
    - cp ../mono_repo/services/schema/*.yaml .
    - cp ../mono_repo/services/schema/appconfig_schema.json .
    - cp ../mono_repo/services/schema/main_appconfig.json appconfig.json
    - cp ../mono_repo/services/schema/yamllint_rules.yaml yamllint_rules.yaml
    - yamllint --list-files **/*.yaml *.yaml
    - yamllint -s **/*.yaml *.yaml -c yamllint_rules.yaml
    - echo "Validating deployment yaml schema"
    - yamale -s base_values_schema.yaml values.yaml
    - yamale -s tier_values_schema.yaml overrides/prod-tier.yaml
    - yamale -s tier_values_schema.yaml overrides/nonprod-tier.yaml
    - |
      # Iterate over all yaml files in the overrides folder
      for file in overrides/*.yaml; do
          # Extract the filename from the path
          filename=$(basename -- "$file")

          # Check if the file is not prod-tier.yaml or nonprod-tier.yaml
          if [[ "$filename" != "prod-tier.yaml" ]] && [[ "$filename" != "nonprod-tier.yaml" ]]; then
              # Run yamale command on the file
              yamale -s env_values_schema.yaml "$file"
          fi
      done
    - "# Iterate over all yaml files in the overrides folder - validate_resources.sh\nif
      [[ -v ENGINE && \"$ENGINE\" == \"argocd\" ]]; then\n  export CD_INFRA_PROJECT_ID=61508954\n
      \ curl --header \"PRIVATE-TOKEN: $CD_CPU_RAM_REQUEST_LIMIT_READ_ONLY\"  \"https://gitlab.com/api/v4/projects/$CD_INFRA_PROJECT_ID/repository/files/ci-infra%2Fscripts%2Fvalidate_resources.sh/raw?ref=main\"
      -o \"$CI_PROJECT_DIR/validate_resources.sh\"\n  echo \"chmod +x $CI_PROJECT_DIR/validate_resources.sh\"
      \n  chmod +x \"$CI_PROJECT_DIR/validate_resources.sh\"\n  echo \"Searching for
      environments values files...\" \n  ENV_FILES_LIST=$(yamllint --list-files **/*.yaml
      *.yaml | grep -vE 'env_values_schema\\.yaml|tier_values_schema\\.yaml|base_values_schema\\.yaml|yamllint_rules\\.yaml|.*prod-tier\\.yaml|values.yaml'
      || true)\n  if [[ -n \"$ENV_FILES_LIST\" ]]; then\n    echo \"Found environments
      values files\"\n    while IFS= read -r file; do\n      filename=$(basename --
      \"$file\")\n      if [[ \"$filename\" =~ ^(dev[1-9]|dev10|stage|pre1).yaml$
      ]]; then\n        tier_file=\"overrides/nonprod-tier.yaml\"\n      else\n        tier_file=\"overrides/prod-tier.yaml\"
      \ \n      fi\n      echo \"values.yaml <-- $tier_file <-- $file\"\n      yq
      eval-all '. as $item ireduce ({}; . * $item)' values.yaml \"$tier_file\" \"$file\"
      | bash \"$CI_PROJECT_DIR/validate_resources.sh\" -\n    done <<< \"$ENV_FILES_LIST\"\n
      \ else\n    echo \"No environments values files were found. Continuing to the
      tier files.\"\n  fi\necho \"values.yaml <-- overrides/nonprod-tier.yaml\"\nyq
      eval-all '. as $item ireduce ({}; . * $item)' values.yaml overrides/nonprod-tier.yaml
      | bash \"$CI_PROJECT_DIR/validate_resources.sh\" -\necho \"values.yaml <-- overrides/prod-tier.yaml\"
      \nyq eval-all '. as $item ireduce ({}; . * $item)' values.yaml overrides/prod-tier.yaml
      | bash \"$CI_PROJECT_DIR/validate_resources.sh\" -\nelse\n  echo \"Skipping
      resource validation: ENGINE is not set to 'argocd'.\"\nfi\n"
    - ajv validate -s appconfig_schema.json -d appconfig.json
    - echo "Resources verified successfully"
    - echo "Validate filter_policy if exists - should be a valid JSON object"
    - fb deployment:validate . --filter-policy
  - cd ../mono_repo
  - ENV_DESTINATION_PATH=$(echo "${DESTINATION_PATH}/${SVC_NAME}/${ENV}")
  - echo "Copying ${SOURCE_PATH} folder from ${SVC_NAME} service to argocd mono repo
    destination folder at ${ENV_DESTINATION_PATH}"
  - mkdir -pv ${ENV_DESTINATION_PATH}/overrides
  - rm ${ENV_DESTINATION_PATH}/overrides/${ENV}.yaml || true
  - cp  ../${SOURCE_PATH}/values.yaml ${ENV_DESTINATION_PATH}
  - cp ../${SOURCE_PATH}/overrides/${ENV}.yaml  ${ENV_DESTINATION_PATH}/overrides
    || true
  - cp ../${SOURCE_PATH}/overrides/*-tier.yaml  ${ENV_DESTINATION_PATH}/overrides
    || true
  - if [ ! -f ${ENV_DESTINATION_PATH}/appconfig.json ]; then cp ../mono_repo/services/schema/main_appconfig.json
    ${ENV_DESTINATION_PATH}/appconfig.json; fi
  - git status
  - echo "Adding changes to Git"
  - git add ${DESTINATION_PATH}
  - git status
  - COUNT=$(git diff --numstat ${STATE_BRANCH} | awk '{added += $1; deleted += $2}
    END {print added + deleted}')
  - |
    if [ "$COUNT" -eq 0 ]; then
      echo "No changes detected under ${CI_PROJECT_NAME}/${SOURCE_PATH}, exiting"
      exit 0
    fi
  - echo "Committing changes"
  - git commit -m "${CI_JOB_NAME}"
  - echo "Pushing changes to remote"
  - git pull --rebase
  - git status
  - "MAX_RETRIES=3\nINITIAL_DELAY=5\nsuccess=false\n\nfor attempt in $(seq 1 $MAX_RETRIES);
    do\n  if git push; then\n    echo -e \"\\e[32mPush successful\\e[0m\"\n    success=true\n
    \   break\n  else\n    echo -e \"\\e[33mPush failed, retrying ($attempt/$MAX_RETRIES)...\\e[0m\"\n
    \   git pull --rebase\n    \n    # Calculate backoff delay (5s, then 10s, then
    20s)\n    BACKOFF_DELAY=$((INITIAL_DELAY * 2**(attempt-1)))\n    echo \"Waiting
    ${BACKOFF_DELAY} seconds before next attempt...\"\n    sleep $BACKOFF_DELAY\n
    \ fi\ndone\n\nif [ \"$success\" != \"true\" ]; then\n  echo -e \"\\e[31mFailed
    to push after $MAX_RETRIES attempts\\e[0m\"\n  exit 1\nfi\n"
  - git status
  - echo "Resources published to argocd mono repo"
  variables:
    DESTINATION_REPO: https://gitlab.com/fireblocks/devops/iac/argocd.git
    DESTINATION_PROJECT_ID: 50521873
    SOURCE_PATH: deployment
    DESTINATION_PATH: services/shell
    STATE_BRANCH: main
    GITLAB_API_URL: https://gitlab.com/api/v4/projects
    TEMPLATE_REF: "$TEMPLATE_REF"
    GITLAB_RUNNER_TAG: devx-application-gitlab-runner
    ENV: dev7
  extends: ".publish_resources_dev"
".publish_resources_dev8":
  stage: configure
  retry:
    max: 2
    when:
    - script_failure
  tags:
  - "${GITLAB_RUNNER_TAG}"
  before_script:
  - printf "%s:%s\n" DESTINATION_REPO "$DESTINATION_REPO" DESTINATION_PROJECT_ID "$DESTINATION_PROJECT_ID"
    SOURCE_PATH "$SOURCE_PATH" DESTINATION_PATH "$DESTINATION_PATH" STATE_BRANCH "$STATE_BRANCH"
    GITLAB_API_URL "$GITLAB_API_URL"
  - |
    if [ ! -d "$SOURCE_PATH" ]; then
      echo "$SOURCE_PATH directory does not exist. Exiting job successfully."
      exit 0
    fi
    echo "$SOURCE_PATH directory exists. Continuing with deployment."
  - - apk update
    - apk add curl jq yq py3-pip
    - pip3 install --upgrade pip
    - pip3 install yamllint
    - pip3 install yamale --break-system-packages
    - npm install -g ajv-cli
    - echo "Configuring Git"
    - echo "https://argocd-ci-push:${ARGOCD_GITLAB_ACCESS_TOKEN}@gitlab.com" > ~/.git-credentials
    - git remote set-url origin https://argocd-ci-push:${ARGOCD_GITLAB_ACCESS_TOKEN}@gitlab.com/fireblocks/devops/iac/argocd.git
    - git config --global user.email "devops@fireblocks.com"
    - git config --global user.name "argocd-ci-push"
    - git config --global credential.helper store
    - touch .npmrc
    - npm config set --location=user @fireblocks:registry https://gitlab.com/api/v4/packages/npm/
    - npm config set --location=user '//gitlab.com/api/v4/packages/npm/:_authToken'
      "${NPM_REG_TOKEN}"
    - npm config set --location=user '//gitlab.com/api/v4/projects/20565764/packages/npm/:_authToken'
      "${NPM_REG_TOKEN}"
    - echo "@fireblocks:registry=https://gitlab.com/api/v4/packages/npm/">>.npmrc
    - echo "//gitlab.com/api/v4/packages/npm/:_authToken=${NPM_REG_TOKEN}">>.npmrc
    - echo "//gitlab.com/api/v4/projects/20565764/packages/npm/:_authToken=${NPM_REG_TOKEN}">>.npmrc
    - yarn global add @fireblocks/fb-cli
  script:
  - - echo "Self Service User Guide - https://fireblocks.atlassian.net/wiki/spaces/RD/pages/1413218873/Self+Service+User+Guide"
    - SVC_NAME=$([ "$SERVICE_NAME" ] && echo $SERVICE_NAME || echo $CI_PROJECT_NAME)
    - echo "Verifying deployment folder for ${SVC_NAME} service"
    - git clone ${DESTINATION_REPO} mono_repo
    - cd mono_repo
    - git fetch --all
    - git checkout ${STATE_BRANCH}
    - git pull origin ${STATE_BRANCH} --no-rebase
    - cd ../${SOURCE_PATH}
    - |
      # Define the paths
      values_file="values.yaml"

      # Check for values.yaml in the deployment folder
      if [ ! -f "$values_file" ]; then
          echo "Error: The values.yaml file is missing in the ${SOURCE_PATH} folder."
          exit 1
      fi

      echo "Success: All required files are present"
    - |
      # Directory to check
      DIR_TO_CHECK="overrides/"

      # List of allowed files
      ALLOWED_PATTERN=$(printf "|%s" "nonprod-tier.yaml" "prod-tier.yaml" "iac-dev.yaml" "localstack.yaml" "dev1.yaml" "dev2.yaml" "dev3.yaml" "dev4.yaml" "dev5.yaml" "dev6.yaml" "dev7.yaml" "dev8.yaml" "dev9.yaml" "dev10.yaml" "dev11.yaml" "dev11.yaml" "dev12.yaml" "dev13.yaml" "dev14.yaml" "dev15.yaml" "pre1.yaml" "stage.yaml" "sandbox.yaml" "eu-prod.yaml" "eu2-prod.yaml" "bnym-dev.yaml" "bnym-prod.yaml" "us-prod.yaml" | cut -c 2-)

      # Flag to track if there are disallowed files
      DISALLOWED_FOUND=false

      # Check for files in the directory that are not in the allowed list
      for file in "$DIR_TO_CHECK"/*; do
        # Get the base name of the file
        filename=$(basename "$file")

        # Check if the filename is in the allowed list
        if [[ ! $filename =~ ^($ALLOWED_PATTERN)$ ]]; then
          echo "Disallowed file found: $filename"
          DISALLOWED_FOUND=true
        fi
      done

      # Final output
      if $DISALLOWED_FOUND; then
        echo "Some files are not allowed."
        exit 1
      else
        echo "All files are allowed."
      fi
    - echo "Linting deployment yaml files"
    - cp ../mono_repo/services/schema/*.yaml .
    - cp ../mono_repo/services/schema/appconfig_schema.json .
    - cp ../mono_repo/services/schema/main_appconfig.json appconfig.json
    - cp ../mono_repo/services/schema/yamllint_rules.yaml yamllint_rules.yaml
    - yamllint --list-files **/*.yaml *.yaml
    - yamllint -s **/*.yaml *.yaml -c yamllint_rules.yaml
    - echo "Validating deployment yaml schema"
    - yamale -s base_values_schema.yaml values.yaml
    - yamale -s tier_values_schema.yaml overrides/prod-tier.yaml
    - yamale -s tier_values_schema.yaml overrides/nonprod-tier.yaml
    - |
      # Iterate over all yaml files in the overrides folder
      for file in overrides/*.yaml; do
          # Extract the filename from the path
          filename=$(basename -- "$file")

          # Check if the file is not prod-tier.yaml or nonprod-tier.yaml
          if [[ "$filename" != "prod-tier.yaml" ]] && [[ "$filename" != "nonprod-tier.yaml" ]]; then
              # Run yamale command on the file
              yamale -s env_values_schema.yaml "$file"
          fi
      done
    - "# Iterate over all yaml files in the overrides folder - validate_resources.sh\nif
      [[ -v ENGINE && \"$ENGINE\" == \"argocd\" ]]; then\n  export CD_INFRA_PROJECT_ID=61508954\n
      \ curl --header \"PRIVATE-TOKEN: $CD_CPU_RAM_REQUEST_LIMIT_READ_ONLY\"  \"https://gitlab.com/api/v4/projects/$CD_INFRA_PROJECT_ID/repository/files/ci-infra%2Fscripts%2Fvalidate_resources.sh/raw?ref=main\"
      -o \"$CI_PROJECT_DIR/validate_resources.sh\"\n  echo \"chmod +x $CI_PROJECT_DIR/validate_resources.sh\"
      \n  chmod +x \"$CI_PROJECT_DIR/validate_resources.sh\"\n  echo \"Searching for
      environments values files...\" \n  ENV_FILES_LIST=$(yamllint --list-files **/*.yaml
      *.yaml | grep -vE 'env_values_schema\\.yaml|tier_values_schema\\.yaml|base_values_schema\\.yaml|yamllint_rules\\.yaml|.*prod-tier\\.yaml|values.yaml'
      || true)\n  if [[ -n \"$ENV_FILES_LIST\" ]]; then\n    echo \"Found environments
      values files\"\n    while IFS= read -r file; do\n      filename=$(basename --
      \"$file\")\n      if [[ \"$filename\" =~ ^(dev[1-9]|dev10|stage|pre1).yaml$
      ]]; then\n        tier_file=\"overrides/nonprod-tier.yaml\"\n      else\n        tier_file=\"overrides/prod-tier.yaml\"
      \ \n      fi\n      echo \"values.yaml <-- $tier_file <-- $file\"\n      yq
      eval-all '. as $item ireduce ({}; . * $item)' values.yaml \"$tier_file\" \"$file\"
      | bash \"$CI_PROJECT_DIR/validate_resources.sh\" -\n    done <<< \"$ENV_FILES_LIST\"\n
      \ else\n    echo \"No environments values files were found. Continuing to the
      tier files.\"\n  fi\necho \"values.yaml <-- overrides/nonprod-tier.yaml\"\nyq
      eval-all '. as $item ireduce ({}; . * $item)' values.yaml overrides/nonprod-tier.yaml
      | bash \"$CI_PROJECT_DIR/validate_resources.sh\" -\necho \"values.yaml <-- overrides/prod-tier.yaml\"
      \nyq eval-all '. as $item ireduce ({}; . * $item)' values.yaml overrides/prod-tier.yaml
      | bash \"$CI_PROJECT_DIR/validate_resources.sh\" -\nelse\n  echo \"Skipping
      resource validation: ENGINE is not set to 'argocd'.\"\nfi\n"
    - ajv validate -s appconfig_schema.json -d appconfig.json
    - echo "Resources verified successfully"
    - echo "Validate filter_policy if exists - should be a valid JSON object"
    - fb deployment:validate . --filter-policy
  - cd ../mono_repo
  - ENV_DESTINATION_PATH=$(echo "${DESTINATION_PATH}/${SVC_NAME}/${ENV}")
  - echo "Copying ${SOURCE_PATH} folder from ${SVC_NAME} service to argocd mono repo
    destination folder at ${ENV_DESTINATION_PATH}"
  - mkdir -pv ${ENV_DESTINATION_PATH}/overrides
  - rm ${ENV_DESTINATION_PATH}/overrides/${ENV}.yaml || true
  - cp  ../${SOURCE_PATH}/values.yaml ${ENV_DESTINATION_PATH}
  - cp ../${SOURCE_PATH}/overrides/${ENV}.yaml  ${ENV_DESTINATION_PATH}/overrides
    || true
  - cp ../${SOURCE_PATH}/overrides/*-tier.yaml  ${ENV_DESTINATION_PATH}/overrides
    || true
  - if [ ! -f ${ENV_DESTINATION_PATH}/appconfig.json ]; then cp ../mono_repo/services/schema/main_appconfig.json
    ${ENV_DESTINATION_PATH}/appconfig.json; fi
  - git status
  - echo "Adding changes to Git"
  - git add ${DESTINATION_PATH}
  - git status
  - COUNT=$(git diff --numstat ${STATE_BRANCH} | awk '{added += $1; deleted += $2}
    END {print added + deleted}')
  - |
    if [ "$COUNT" -eq 0 ]; then
      echo "No changes detected under ${CI_PROJECT_NAME}/${SOURCE_PATH}, exiting"
      exit 0
    fi
  - echo "Committing changes"
  - git commit -m "${CI_JOB_NAME}"
  - echo "Pushing changes to remote"
  - git pull --rebase
  - git status
  - "MAX_RETRIES=3\nINITIAL_DELAY=5\nsuccess=false\n\nfor attempt in $(seq 1 $MAX_RETRIES);
    do\n  if git push; then\n    echo -e \"\\e[32mPush successful\\e[0m\"\n    success=true\n
    \   break\n  else\n    echo -e \"\\e[33mPush failed, retrying ($attempt/$MAX_RETRIES)...\\e[0m\"\n
    \   git pull --rebase\n    \n    # Calculate backoff delay (5s, then 10s, then
    20s)\n    BACKOFF_DELAY=$((INITIAL_DELAY * 2**(attempt-1)))\n    echo \"Waiting
    ${BACKOFF_DELAY} seconds before next attempt...\"\n    sleep $BACKOFF_DELAY\n
    \ fi\ndone\n\nif [ \"$success\" != \"true\" ]; then\n  echo -e \"\\e[31mFailed
    to push after $MAX_RETRIES attempts\\e[0m\"\n  exit 1\nfi\n"
  - git status
  - echo "Resources published to argocd mono repo"
  variables:
    DESTINATION_REPO: https://gitlab.com/fireblocks/devops/iac/argocd.git
    DESTINATION_PROJECT_ID: 50521873
    SOURCE_PATH: deployment
    DESTINATION_PATH: services/shell
    STATE_BRANCH: main
    GITLAB_API_URL: https://gitlab.com/api/v4/projects
    TEMPLATE_REF: "$TEMPLATE_REF"
    GITLAB_RUNNER_TAG: devx-application-gitlab-runner
    ENV: dev8
  extends: ".publish_resources_dev"
".publish_resources_dev9":
  stage: configure
  retry:
    max: 2
    when:
    - script_failure
  tags:
  - "${GITLAB_RUNNER_TAG}"
  before_script:
  - printf "%s:%s\n" DESTINATION_REPO "$DESTINATION_REPO" DESTINATION_PROJECT_ID "$DESTINATION_PROJECT_ID"
    SOURCE_PATH "$SOURCE_PATH" DESTINATION_PATH "$DESTINATION_PATH" STATE_BRANCH "$STATE_BRANCH"
    GITLAB_API_URL "$GITLAB_API_URL"
  - |
    if [ ! -d "$SOURCE_PATH" ]; then
      echo "$SOURCE_PATH directory does not exist. Exiting job successfully."
      exit 0
    fi
    echo "$SOURCE_PATH directory exists. Continuing with deployment."
  - - apk update
    - apk add curl jq yq py3-pip
    - pip3 install --upgrade pip
    - pip3 install yamllint
    - pip3 install yamale --break-system-packages
    - npm install -g ajv-cli
    - echo "Configuring Git"
    - echo "https://argocd-ci-push:${ARGOCD_GITLAB_ACCESS_TOKEN}@gitlab.com" > ~/.git-credentials
    - git remote set-url origin https://argocd-ci-push:${ARGOCD_GITLAB_ACCESS_TOKEN}@gitlab.com/fireblocks/devops/iac/argocd.git
    - git config --global user.email "devops@fireblocks.com"
    - git config --global user.name "argocd-ci-push"
    - git config --global credential.helper store
    - touch .npmrc
    - npm config set --location=user @fireblocks:registry https://gitlab.com/api/v4/packages/npm/
    - npm config set --location=user '//gitlab.com/api/v4/packages/npm/:_authToken'
      "${NPM_REG_TOKEN}"
    - npm config set --location=user '//gitlab.com/api/v4/projects/20565764/packages/npm/:_authToken'
      "${NPM_REG_TOKEN}"
    - echo "@fireblocks:registry=https://gitlab.com/api/v4/packages/npm/">>.npmrc
    - echo "//gitlab.com/api/v4/packages/npm/:_authToken=${NPM_REG_TOKEN}">>.npmrc
    - echo "//gitlab.com/api/v4/projects/20565764/packages/npm/:_authToken=${NPM_REG_TOKEN}">>.npmrc
    - yarn global add @fireblocks/fb-cli
  script:
  - - echo "Self Service User Guide - https://fireblocks.atlassian.net/wiki/spaces/RD/pages/1413218873/Self+Service+User+Guide"
    - SVC_NAME=$([ "$SERVICE_NAME" ] && echo $SERVICE_NAME || echo $CI_PROJECT_NAME)
    - echo "Verifying deployment folder for ${SVC_NAME} service"
    - git clone ${DESTINATION_REPO} mono_repo
    - cd mono_repo
    - git fetch --all
    - git checkout ${STATE_BRANCH}
    - git pull origin ${STATE_BRANCH} --no-rebase
    - cd ../${SOURCE_PATH}
    - |
      # Define the paths
      values_file="values.yaml"

      # Check for values.yaml in the deployment folder
      if [ ! -f "$values_file" ]; then
          echo "Error: The values.yaml file is missing in the ${SOURCE_PATH} folder."
          exit 1
      fi

      echo "Success: All required files are present"
    - |
      # Directory to check
      DIR_TO_CHECK="overrides/"

      # List of allowed files
      ALLOWED_PATTERN=$(printf "|%s" "nonprod-tier.yaml" "prod-tier.yaml" "iac-dev.yaml" "localstack.yaml" "dev1.yaml" "dev2.yaml" "dev3.yaml" "dev4.yaml" "dev5.yaml" "dev6.yaml" "dev7.yaml" "dev8.yaml" "dev9.yaml" "dev10.yaml" "dev11.yaml" "dev11.yaml" "dev12.yaml" "dev13.yaml" "dev14.yaml" "dev15.yaml" "pre1.yaml" "stage.yaml" "sandbox.yaml" "eu-prod.yaml" "eu2-prod.yaml" "bnym-dev.yaml" "bnym-prod.yaml" "us-prod.yaml" | cut -c 2-)

      # Flag to track if there are disallowed files
      DISALLOWED_FOUND=false

      # Check for files in the directory that are not in the allowed list
      for file in "$DIR_TO_CHECK"/*; do
        # Get the base name of the file
        filename=$(basename "$file")

        # Check if the filename is in the allowed list
        if [[ ! $filename =~ ^($ALLOWED_PATTERN)$ ]]; then
          echo "Disallowed file found: $filename"
          DISALLOWED_FOUND=true
        fi
      done

      # Final output
      if $DISALLOWED_FOUND; then
        echo "Some files are not allowed."
        exit 1
      else
        echo "All files are allowed."
      fi
    - echo "Linting deployment yaml files"
    - cp ../mono_repo/services/schema/*.yaml .
    - cp ../mono_repo/services/schema/appconfig_schema.json .
    - cp ../mono_repo/services/schema/main_appconfig.json appconfig.json
    - cp ../mono_repo/services/schema/yamllint_rules.yaml yamllint_rules.yaml
    - yamllint --list-files **/*.yaml *.yaml
    - yamllint -s **/*.yaml *.yaml -c yamllint_rules.yaml
    - echo "Validating deployment yaml schema"
    - yamale -s base_values_schema.yaml values.yaml
    - yamale -s tier_values_schema.yaml overrides/prod-tier.yaml
    - yamale -s tier_values_schema.yaml overrides/nonprod-tier.yaml
    - |
      # Iterate over all yaml files in the overrides folder
      for file in overrides/*.yaml; do
          # Extract the filename from the path
          filename=$(basename -- "$file")

          # Check if the file is not prod-tier.yaml or nonprod-tier.yaml
          if [[ "$filename" != "prod-tier.yaml" ]] && [[ "$filename" != "nonprod-tier.yaml" ]]; then
              # Run yamale command on the file
              yamale -s env_values_schema.yaml "$file"
          fi
      done
    - "# Iterate over all yaml files in the overrides folder - validate_resources.sh\nif
      [[ -v ENGINE && \"$ENGINE\" == \"argocd\" ]]; then\n  export CD_INFRA_PROJECT_ID=61508954\n
      \ curl --header \"PRIVATE-TOKEN: $CD_CPU_RAM_REQUEST_LIMIT_READ_ONLY\"  \"https://gitlab.com/api/v4/projects/$CD_INFRA_PROJECT_ID/repository/files/ci-infra%2Fscripts%2Fvalidate_resources.sh/raw?ref=main\"
      -o \"$CI_PROJECT_DIR/validate_resources.sh\"\n  echo \"chmod +x $CI_PROJECT_DIR/validate_resources.sh\"
      \n  chmod +x \"$CI_PROJECT_DIR/validate_resources.sh\"\n  echo \"Searching for
      environments values files...\" \n  ENV_FILES_LIST=$(yamllint --list-files **/*.yaml
      *.yaml | grep -vE 'env_values_schema\\.yaml|tier_values_schema\\.yaml|base_values_schema\\.yaml|yamllint_rules\\.yaml|.*prod-tier\\.yaml|values.yaml'
      || true)\n  if [[ -n \"$ENV_FILES_LIST\" ]]; then\n    echo \"Found environments
      values files\"\n    while IFS= read -r file; do\n      filename=$(basename --
      \"$file\")\n      if [[ \"$filename\" =~ ^(dev[1-9]|dev10|stage|pre1).yaml$
      ]]; then\n        tier_file=\"overrides/nonprod-tier.yaml\"\n      else\n        tier_file=\"overrides/prod-tier.yaml\"
      \ \n      fi\n      echo \"values.yaml <-- $tier_file <-- $file\"\n      yq
      eval-all '. as $item ireduce ({}; . * $item)' values.yaml \"$tier_file\" \"$file\"
      | bash \"$CI_PROJECT_DIR/validate_resources.sh\" -\n    done <<< \"$ENV_FILES_LIST\"\n
      \ else\n    echo \"No environments values files were found. Continuing to the
      tier files.\"\n  fi\necho \"values.yaml <-- overrides/nonprod-tier.yaml\"\nyq
      eval-all '. as $item ireduce ({}; . * $item)' values.yaml overrides/nonprod-tier.yaml
      | bash \"$CI_PROJECT_DIR/validate_resources.sh\" -\necho \"values.yaml <-- overrides/prod-tier.yaml\"
      \nyq eval-all '. as $item ireduce ({}; . * $item)' values.yaml overrides/prod-tier.yaml
      | bash \"$CI_PROJECT_DIR/validate_resources.sh\" -\nelse\n  echo \"Skipping
      resource validation: ENGINE is not set to 'argocd'.\"\nfi\n"
    - ajv validate -s appconfig_schema.json -d appconfig.json
    - echo "Resources verified successfully"
    - echo "Validate filter_policy if exists - should be a valid JSON object"
    - fb deployment:validate . --filter-policy
  - cd ../mono_repo
  - ENV_DESTINATION_PATH=$(echo "${DESTINATION_PATH}/${SVC_NAME}/${ENV}")
  - echo "Copying ${SOURCE_PATH} folder from ${SVC_NAME} service to argocd mono repo
    destination folder at ${ENV_DESTINATION_PATH}"
  - mkdir -pv ${ENV_DESTINATION_PATH}/overrides
  - rm ${ENV_DESTINATION_PATH}/overrides/${ENV}.yaml || true
  - cp  ../${SOURCE_PATH}/values.yaml ${ENV_DESTINATION_PATH}
  - cp ../${SOURCE_PATH}/overrides/${ENV}.yaml  ${ENV_DESTINATION_PATH}/overrides
    || true
  - cp ../${SOURCE_PATH}/overrides/*-tier.yaml  ${ENV_DESTINATION_PATH}/overrides
    || true
  - if [ ! -f ${ENV_DESTINATION_PATH}/appconfig.json ]; then cp ../mono_repo/services/schema/main_appconfig.json
    ${ENV_DESTINATION_PATH}/appconfig.json; fi
  - git status
  - echo "Adding changes to Git"
  - git add ${DESTINATION_PATH}
  - git status
  - COUNT=$(git diff --numstat ${STATE_BRANCH} | awk '{added += $1; deleted += $2}
    END {print added + deleted}')
  - |
    if [ "$COUNT" -eq 0 ]; then
      echo "No changes detected under ${CI_PROJECT_NAME}/${SOURCE_PATH}, exiting"
      exit 0
    fi
  - echo "Committing changes"
  - git commit -m "${CI_JOB_NAME}"
  - echo "Pushing changes to remote"
  - git pull --rebase
  - git status
  - "MAX_RETRIES=3\nINITIAL_DELAY=5\nsuccess=false\n\nfor attempt in $(seq 1 $MAX_RETRIES);
    do\n  if git push; then\n    echo -e \"\\e[32mPush successful\\e[0m\"\n    success=true\n
    \   break\n  else\n    echo -e \"\\e[33mPush failed, retrying ($attempt/$MAX_RETRIES)...\\e[0m\"\n
    \   git pull --rebase\n    \n    # Calculate backoff delay (5s, then 10s, then
    20s)\n    BACKOFF_DELAY=$((INITIAL_DELAY * 2**(attempt-1)))\n    echo \"Waiting
    ${BACKOFF_DELAY} seconds before next attempt...\"\n    sleep $BACKOFF_DELAY\n
    \ fi\ndone\n\nif [ \"$success\" != \"true\" ]; then\n  echo -e \"\\e[31mFailed
    to push after $MAX_RETRIES attempts\\e[0m\"\n  exit 1\nfi\n"
  - git status
  - echo "Resources published to argocd mono repo"
  variables:
    DESTINATION_REPO: https://gitlab.com/fireblocks/devops/iac/argocd.git
    DESTINATION_PROJECT_ID: 50521873
    SOURCE_PATH: deployment
    DESTINATION_PATH: services/shell
    STATE_BRANCH: main
    GITLAB_API_URL: https://gitlab.com/api/v4/projects
    TEMPLATE_REF: "$TEMPLATE_REF"
    GITLAB_RUNNER_TAG: devx-application-gitlab-runner
    ENV: dev9
  extends: ".publish_resources_dev"
".publish_resources_dev10":
  stage: configure
  retry:
    max: 2
    when:
    - script_failure
  tags:
  - "${GITLAB_RUNNER_TAG}"
  before_script:
  - printf "%s:%s\n" DESTINATION_REPO "$DESTINATION_REPO" DESTINATION_PROJECT_ID "$DESTINATION_PROJECT_ID"
    SOURCE_PATH "$SOURCE_PATH" DESTINATION_PATH "$DESTINATION_PATH" STATE_BRANCH "$STATE_BRANCH"
    GITLAB_API_URL "$GITLAB_API_URL"
  - |
    if [ ! -d "$SOURCE_PATH" ]; then
      echo "$SOURCE_PATH directory does not exist. Exiting job successfully."
      exit 0
    fi
    echo "$SOURCE_PATH directory exists. Continuing with deployment."
  - - apk update
    - apk add curl jq yq py3-pip
    - pip3 install --upgrade pip
    - pip3 install yamllint
    - pip3 install yamale --break-system-packages
    - npm install -g ajv-cli
    - echo "Configuring Git"
    - echo "https://argocd-ci-push:${ARGOCD_GITLAB_ACCESS_TOKEN}@gitlab.com" > ~/.git-credentials
    - git remote set-url origin https://argocd-ci-push:${ARGOCD_GITLAB_ACCESS_TOKEN}@gitlab.com/fireblocks/devops/iac/argocd.git
    - git config --global user.email "devops@fireblocks.com"
    - git config --global user.name "argocd-ci-push"
    - git config --global credential.helper store
    - touch .npmrc
    - npm config set --location=user @fireblocks:registry https://gitlab.com/api/v4/packages/npm/
    - npm config set --location=user '//gitlab.com/api/v4/packages/npm/:_authToken'
      "${NPM_REG_TOKEN}"
    - npm config set --location=user '//gitlab.com/api/v4/projects/20565764/packages/npm/:_authToken'
      "${NPM_REG_TOKEN}"
    - echo "@fireblocks:registry=https://gitlab.com/api/v4/packages/npm/">>.npmrc
    - echo "//gitlab.com/api/v4/packages/npm/:_authToken=${NPM_REG_TOKEN}">>.npmrc
    - echo "//gitlab.com/api/v4/projects/20565764/packages/npm/:_authToken=${NPM_REG_TOKEN}">>.npmrc
    - yarn global add @fireblocks/fb-cli
  script:
  - - echo "Self Service User Guide - https://fireblocks.atlassian.net/wiki/spaces/RD/pages/1413218873/Self+Service+User+Guide"
    - SVC_NAME=$([ "$SERVICE_NAME" ] && echo $SERVICE_NAME || echo $CI_PROJECT_NAME)
    - echo "Verifying deployment folder for ${SVC_NAME} service"
    - git clone ${DESTINATION_REPO} mono_repo
    - cd mono_repo
    - git fetch --all
    - git checkout ${STATE_BRANCH}
    - git pull origin ${STATE_BRANCH} --no-rebase
    - cd ../${SOURCE_PATH}
    - |
      # Define the paths
      values_file="values.yaml"

      # Check for values.yaml in the deployment folder
      if [ ! -f "$values_file" ]; then
          echo "Error: The values.yaml file is missing in the ${SOURCE_PATH} folder."
          exit 1
      fi

      echo "Success: All required files are present"
    - |
      # Directory to check
      DIR_TO_CHECK="overrides/"

      # List of allowed files
      ALLOWED_PATTERN=$(printf "|%s" "nonprod-tier.yaml" "prod-tier.yaml" "iac-dev.yaml" "localstack.yaml" "dev1.yaml" "dev2.yaml" "dev3.yaml" "dev4.yaml" "dev5.yaml" "dev6.yaml" "dev7.yaml" "dev8.yaml" "dev9.yaml" "dev10.yaml" "dev11.yaml" "dev11.yaml" "dev12.yaml" "dev13.yaml" "dev14.yaml" "dev15.yaml" "pre1.yaml" "stage.yaml" "sandbox.yaml" "eu-prod.yaml" "eu2-prod.yaml" "bnym-dev.yaml" "bnym-prod.yaml" "us-prod.yaml" | cut -c 2-)

      # Flag to track if there are disallowed files
      DISALLOWED_FOUND=false

      # Check for files in the directory that are not in the allowed list
      for file in "$DIR_TO_CHECK"/*; do
        # Get the base name of the file
        filename=$(basename "$file")

        # Check if the filename is in the allowed list
        if [[ ! $filename =~ ^($ALLOWED_PATTERN)$ ]]; then
          echo "Disallowed file found: $filename"
          DISALLOWED_FOUND=true
        fi
      done

      # Final output
      if $DISALLOWED_FOUND; then
        echo "Some files are not allowed."
        exit 1
      else
        echo "All files are allowed."
      fi
    - echo "Linting deployment yaml files"
    - cp ../mono_repo/services/schema/*.yaml .
    - cp ../mono_repo/services/schema/appconfig_schema.json .
    - cp ../mono_repo/services/schema/main_appconfig.json appconfig.json
    - cp ../mono_repo/services/schema/yamllint_rules.yaml yamllint_rules.yaml
    - yamllint --list-files **/*.yaml *.yaml
    - yamllint -s **/*.yaml *.yaml -c yamllint_rules.yaml
    - echo "Validating deployment yaml schema"
    - yamale -s base_values_schema.yaml values.yaml
    - yamale -s tier_values_schema.yaml overrides/prod-tier.yaml
    - yamale -s tier_values_schema.yaml overrides/nonprod-tier.yaml
    - |
      # Iterate over all yaml files in the overrides folder
      for file in overrides/*.yaml; do
          # Extract the filename from the path
          filename=$(basename -- "$file")

          # Check if the file is not prod-tier.yaml or nonprod-tier.yaml
          if [[ "$filename" != "prod-tier.yaml" ]] && [[ "$filename" != "nonprod-tier.yaml" ]]; then
              # Run yamale command on the file
              yamale -s env_values_schema.yaml "$file"
          fi
      done
    - "# Iterate over all yaml files in the overrides folder - validate_resources.sh\nif
      [[ -v ENGINE && \"$ENGINE\" == \"argocd\" ]]; then\n  export CD_INFRA_PROJECT_ID=61508954\n
      \ curl --header \"PRIVATE-TOKEN: $CD_CPU_RAM_REQUEST_LIMIT_READ_ONLY\"  \"https://gitlab.com/api/v4/projects/$CD_INFRA_PROJECT_ID/repository/files/ci-infra%2Fscripts%2Fvalidate_resources.sh/raw?ref=main\"
      -o \"$CI_PROJECT_DIR/validate_resources.sh\"\n  echo \"chmod +x $CI_PROJECT_DIR/validate_resources.sh\"
      \n  chmod +x \"$CI_PROJECT_DIR/validate_resources.sh\"\n  echo \"Searching for
      environments values files...\" \n  ENV_FILES_LIST=$(yamllint --list-files **/*.yaml
      *.yaml | grep -vE 'env_values_schema\\.yaml|tier_values_schema\\.yaml|base_values_schema\\.yaml|yamllint_rules\\.yaml|.*prod-tier\\.yaml|values.yaml'
      || true)\n  if [[ -n \"$ENV_FILES_LIST\" ]]; then\n    echo \"Found environments
      values files\"\n    while IFS= read -r file; do\n      filename=$(basename --
      \"$file\")\n      if [[ \"$filename\" =~ ^(dev[1-9]|dev10|stage|pre1).yaml$
      ]]; then\n        tier_file=\"overrides/nonprod-tier.yaml\"\n      else\n        tier_file=\"overrides/prod-tier.yaml\"
      \ \n      fi\n      echo \"values.yaml <-- $tier_file <-- $file\"\n      yq
      eval-all '. as $item ireduce ({}; . * $item)' values.yaml \"$tier_file\" \"$file\"
      | bash \"$CI_PROJECT_DIR/validate_resources.sh\" -\n    done <<< \"$ENV_FILES_LIST\"\n
      \ else\n    echo \"No environments values files were found. Continuing to the
      tier files.\"\n  fi\necho \"values.yaml <-- overrides/nonprod-tier.yaml\"\nyq
      eval-all '. as $item ireduce ({}; . * $item)' values.yaml overrides/nonprod-tier.yaml
      | bash \"$CI_PROJECT_DIR/validate_resources.sh\" -\necho \"values.yaml <-- overrides/prod-tier.yaml\"
      \nyq eval-all '. as $item ireduce ({}; . * $item)' values.yaml overrides/prod-tier.yaml
      | bash \"$CI_PROJECT_DIR/validate_resources.sh\" -\nelse\n  echo \"Skipping
      resource validation: ENGINE is not set to 'argocd'.\"\nfi\n"
    - ajv validate -s appconfig_schema.json -d appconfig.json
    - echo "Resources verified successfully"
    - echo "Validate filter_policy if exists - should be a valid JSON object"
    - fb deployment:validate . --filter-policy
  - cd ../mono_repo
  - ENV_DESTINATION_PATH=$(echo "${DESTINATION_PATH}/${SVC_NAME}/${ENV}")
  - echo "Copying ${SOURCE_PATH} folder from ${SVC_NAME} service to argocd mono repo
    destination folder at ${ENV_DESTINATION_PATH}"
  - mkdir -pv ${ENV_DESTINATION_PATH}/overrides
  - rm ${ENV_DESTINATION_PATH}/overrides/${ENV}.yaml || true
  - cp  ../${SOURCE_PATH}/values.yaml ${ENV_DESTINATION_PATH}
  - cp ../${SOURCE_PATH}/overrides/${ENV}.yaml  ${ENV_DESTINATION_PATH}/overrides
    || true
  - cp ../${SOURCE_PATH}/overrides/*-tier.yaml  ${ENV_DESTINATION_PATH}/overrides
    || true
  - if [ ! -f ${ENV_DESTINATION_PATH}/appconfig.json ]; then cp ../mono_repo/services/schema/main_appconfig.json
    ${ENV_DESTINATION_PATH}/appconfig.json; fi
  - git status
  - echo "Adding changes to Git"
  - git add ${DESTINATION_PATH}
  - git status
  - COUNT=$(git diff --numstat ${STATE_BRANCH} | awk '{added += $1; deleted += $2}
    END {print added + deleted}')
  - |
    if [ "$COUNT" -eq 0 ]; then
      echo "No changes detected under ${CI_PROJECT_NAME}/${SOURCE_PATH}, exiting"
      exit 0
    fi
  - echo "Committing changes"
  - git commit -m "${CI_JOB_NAME}"
  - echo "Pushing changes to remote"
  - git pull --rebase
  - git status
  - "MAX_RETRIES=3\nINITIAL_DELAY=5\nsuccess=false\n\nfor attempt in $(seq 1 $MAX_RETRIES);
    do\n  if git push; then\n    echo -e \"\\e[32mPush successful\\e[0m\"\n    success=true\n
    \   break\n  else\n    echo -e \"\\e[33mPush failed, retrying ($attempt/$MAX_RETRIES)...\\e[0m\"\n
    \   git pull --rebase\n    \n    # Calculate backoff delay (5s, then 10s, then
    20s)\n    BACKOFF_DELAY=$((INITIAL_DELAY * 2**(attempt-1)))\n    echo \"Waiting
    ${BACKOFF_DELAY} seconds before next attempt...\"\n    sleep $BACKOFF_DELAY\n
    \ fi\ndone\n\nif [ \"$success\" != \"true\" ]; then\n  echo -e \"\\e[31mFailed
    to push after $MAX_RETRIES attempts\\e[0m\"\n  exit 1\nfi\n"
  - git status
  - echo "Resources published to argocd mono repo"
  variables:
    DESTINATION_REPO: https://gitlab.com/fireblocks/devops/iac/argocd.git
    DESTINATION_PROJECT_ID: 50521873
    SOURCE_PATH: deployment
    DESTINATION_PATH: services/shell
    STATE_BRANCH: main
    GITLAB_API_URL: https://gitlab.com/api/v4/projects
    TEMPLATE_REF: "$TEMPLATE_REF"
    GITLAB_RUNNER_TAG: devx-application-gitlab-runner
    ENV: dev10
  extends: ".publish_resources_dev"
".publish_resources_dev11":
  stage: configure
  retry:
    max: 2
    when:
    - script_failure
  tags:
  - "${GITLAB_RUNNER_TAG}"
  before_script:
  - printf "%s:%s\n" DESTINATION_REPO "$DESTINATION_REPO" DESTINATION_PROJECT_ID "$DESTINATION_PROJECT_ID"
    SOURCE_PATH "$SOURCE_PATH" DESTINATION_PATH "$DESTINATION_PATH" STATE_BRANCH "$STATE_BRANCH"
    GITLAB_API_URL "$GITLAB_API_URL"
  - |
    if [ ! -d "$SOURCE_PATH" ]; then
      echo "$SOURCE_PATH directory does not exist. Exiting job successfully."
      exit 0
    fi
    echo "$SOURCE_PATH directory exists. Continuing with deployment."
  - - apk update
    - apk add curl jq yq py3-pip
    - pip3 install --upgrade pip
    - pip3 install yamllint
    - pip3 install yamale --break-system-packages
    - npm install -g ajv-cli
    - echo "Configuring Git"
    - echo "https://argocd-ci-push:${ARGOCD_GITLAB_ACCESS_TOKEN}@gitlab.com" > ~/.git-credentials
    - git remote set-url origin https://argocd-ci-push:${ARGOCD_GITLAB_ACCESS_TOKEN}@gitlab.com/fireblocks/devops/iac/argocd.git
    - git config --global user.email "devops@fireblocks.com"
    - git config --global user.name "argocd-ci-push"
    - git config --global credential.helper store
    - touch .npmrc
    - npm config set --location=user @fireblocks:registry https://gitlab.com/api/v4/packages/npm/
    - npm config set --location=user '//gitlab.com/api/v4/packages/npm/:_authToken'
      "${NPM_REG_TOKEN}"
    - npm config set --location=user '//gitlab.com/api/v4/projects/20565764/packages/npm/:_authToken'
      "${NPM_REG_TOKEN}"
    - echo "@fireblocks:registry=https://gitlab.com/api/v4/packages/npm/">>.npmrc
    - echo "//gitlab.com/api/v4/packages/npm/:_authToken=${NPM_REG_TOKEN}">>.npmrc
    - echo "//gitlab.com/api/v4/projects/20565764/packages/npm/:_authToken=${NPM_REG_TOKEN}">>.npmrc
    - yarn global add @fireblocks/fb-cli
  script:
  - - echo "Self Service User Guide - https://fireblocks.atlassian.net/wiki/spaces/RD/pages/1413218873/Self+Service+User+Guide"
    - SVC_NAME=$([ "$SERVICE_NAME" ] && echo $SERVICE_NAME || echo $CI_PROJECT_NAME)
    - echo "Verifying deployment folder for ${SVC_NAME} service"
    - git clone ${DESTINATION_REPO} mono_repo
    - cd mono_repo
    - git fetch --all
    - git checkout ${STATE_BRANCH}
    - git pull origin ${STATE_BRANCH} --no-rebase
    - cd ../${SOURCE_PATH}
    - |
      # Define the paths
      values_file="values.yaml"

      # Check for values.yaml in the deployment folder
      if [ ! -f "$values_file" ]; then
          echo "Error: The values.yaml file is missing in the ${SOURCE_PATH} folder."
          exit 1
      fi

      echo "Success: All required files are present"
    - |
      # Directory to check
      DIR_TO_CHECK="overrides/"

      # List of allowed files
      ALLOWED_PATTERN=$(printf "|%s" "nonprod-tier.yaml" "prod-tier.yaml" "iac-dev.yaml" "localstack.yaml" "dev1.yaml" "dev2.yaml" "dev3.yaml" "dev4.yaml" "dev5.yaml" "dev6.yaml" "dev7.yaml" "dev8.yaml" "dev9.yaml" "dev10.yaml" "dev11.yaml" "dev11.yaml" "dev12.yaml" "dev13.yaml" "dev14.yaml" "dev15.yaml" "pre1.yaml" "stage.yaml" "sandbox.yaml" "eu-prod.yaml" "eu2-prod.yaml" "bnym-dev.yaml" "bnym-prod.yaml" "us-prod.yaml" | cut -c 2-)

      # Flag to track if there are disallowed files
      DISALLOWED_FOUND=false

      # Check for files in the directory that are not in the allowed list
      for file in "$DIR_TO_CHECK"/*; do
        # Get the base name of the file
        filename=$(basename "$file")

        # Check if the filename is in the allowed list
        if [[ ! $filename =~ ^($ALLOWED_PATTERN)$ ]]; then
          echo "Disallowed file found: $filename"
          DISALLOWED_FOUND=true
        fi
      done

      # Final output
      if $DISALLOWED_FOUND; then
        echo "Some files are not allowed."
        exit 1
      else
        echo "All files are allowed."
      fi
    - echo "Linting deployment yaml files"
    - cp ../mono_repo/services/schema/*.yaml .
    - cp ../mono_repo/services/schema/appconfig_schema.json .
    - cp ../mono_repo/services/schema/main_appconfig.json appconfig.json
    - cp ../mono_repo/services/schema/yamllint_rules.yaml yamllint_rules.yaml
    - yamllint --list-files **/*.yaml *.yaml
    - yamllint -s **/*.yaml *.yaml -c yamllint_rules.yaml
    - echo "Validating deployment yaml schema"
    - yamale -s base_values_schema.yaml values.yaml
    - yamale -s tier_values_schema.yaml overrides/prod-tier.yaml
    - yamale -s tier_values_schema.yaml overrides/nonprod-tier.yaml
    - |
      # Iterate over all yaml files in the overrides folder
      for file in overrides/*.yaml; do
          # Extract the filename from the path
          filename=$(basename -- "$file")

          # Check if the file is not prod-tier.yaml or nonprod-tier.yaml
          if [[ "$filename" != "prod-tier.yaml" ]] && [[ "$filename" != "nonprod-tier.yaml" ]]; then
              # Run yamale command on the file
              yamale -s env_values_schema.yaml "$file"
          fi
      done
    - "# Iterate over all yaml files in the overrides folder - validate_resources.sh\nif
      [[ -v ENGINE && \"$ENGINE\" == \"argocd\" ]]; then\n  export CD_INFRA_PROJECT_ID=61508954\n
      \ curl --header \"PRIVATE-TOKEN: $CD_CPU_RAM_REQUEST_LIMIT_READ_ONLY\"  \"https://gitlab.com/api/v4/projects/$CD_INFRA_PROJECT_ID/repository/files/ci-infra%2Fscripts%2Fvalidate_resources.sh/raw?ref=main\"
      -o \"$CI_PROJECT_DIR/validate_resources.sh\"\n  echo \"chmod +x $CI_PROJECT_DIR/validate_resources.sh\"
      \n  chmod +x \"$CI_PROJECT_DIR/validate_resources.sh\"\n  echo \"Searching for
      environments values files...\" \n  ENV_FILES_LIST=$(yamllint --list-files **/*.yaml
      *.yaml | grep -vE 'env_values_schema\\.yaml|tier_values_schema\\.yaml|base_values_schema\\.yaml|yamllint_rules\\.yaml|.*prod-tier\\.yaml|values.yaml'
      || true)\n  if [[ -n \"$ENV_FILES_LIST\" ]]; then\n    echo \"Found environments
      values files\"\n    while IFS= read -r file; do\n      filename=$(basename --
      \"$file\")\n      if [[ \"$filename\" =~ ^(dev[1-9]|dev10|stage|pre1).yaml$
      ]]; then\n        tier_file=\"overrides/nonprod-tier.yaml\"\n      else\n        tier_file=\"overrides/prod-tier.yaml\"
      \ \n      fi\n      echo \"values.yaml <-- $tier_file <-- $file\"\n      yq
      eval-all '. as $item ireduce ({}; . * $item)' values.yaml \"$tier_file\" \"$file\"
      | bash \"$CI_PROJECT_DIR/validate_resources.sh\" -\n    done <<< \"$ENV_FILES_LIST\"\n
      \ else\n    echo \"No environments values files were found. Continuing to the
      tier files.\"\n  fi\necho \"values.yaml <-- overrides/nonprod-tier.yaml\"\nyq
      eval-all '. as $item ireduce ({}; . * $item)' values.yaml overrides/nonprod-tier.yaml
      | bash \"$CI_PROJECT_DIR/validate_resources.sh\" -\necho \"values.yaml <-- overrides/prod-tier.yaml\"
      \nyq eval-all '. as $item ireduce ({}; . * $item)' values.yaml overrides/prod-tier.yaml
      | bash \"$CI_PROJECT_DIR/validate_resources.sh\" -\nelse\n  echo \"Skipping
      resource validation: ENGINE is not set to 'argocd'.\"\nfi\n"
    - ajv validate -s appconfig_schema.json -d appconfig.json
    - echo "Resources verified successfully"
    - echo "Validate filter_policy if exists - should be a valid JSON object"
    - fb deployment:validate . --filter-policy
  - cd ../mono_repo
  - ENV_DESTINATION_PATH=$(echo "${DESTINATION_PATH}/${SVC_NAME}/${ENV}")
  - echo "Copying ${SOURCE_PATH} folder from ${SVC_NAME} service to argocd mono repo
    destination folder at ${ENV_DESTINATION_PATH}"
  - mkdir -pv ${ENV_DESTINATION_PATH}/overrides
  - rm ${ENV_DESTINATION_PATH}/overrides/${ENV}.yaml || true
  - cp  ../${SOURCE_PATH}/values.yaml ${ENV_DESTINATION_PATH}
  - cp ../${SOURCE_PATH}/overrides/${ENV}.yaml  ${ENV_DESTINATION_PATH}/overrides
    || true
  - cp ../${SOURCE_PATH}/overrides/*-tier.yaml  ${ENV_DESTINATION_PATH}/overrides
    || true
  - if [ ! -f ${ENV_DESTINATION_PATH}/appconfig.json ]; then cp ../mono_repo/services/schema/main_appconfig.json
    ${ENV_DESTINATION_PATH}/appconfig.json; fi
  - git status
  - echo "Adding changes to Git"
  - git add ${DESTINATION_PATH}
  - git status
  - COUNT=$(git diff --numstat ${STATE_BRANCH} | awk '{added += $1; deleted += $2}
    END {print added + deleted}')
  - |
    if [ "$COUNT" -eq 0 ]; then
      echo "No changes detected under ${CI_PROJECT_NAME}/${SOURCE_PATH}, exiting"
      exit 0
    fi
  - echo "Committing changes"
  - git commit -m "${CI_JOB_NAME}"
  - echo "Pushing changes to remote"
  - git pull --rebase
  - git status
  - "MAX_RETRIES=3\nINITIAL_DELAY=5\nsuccess=false\n\nfor attempt in $(seq 1 $MAX_RETRIES);
    do\n  if git push; then\n    echo -e \"\\e[32mPush successful\\e[0m\"\n    success=true\n
    \   break\n  else\n    echo -e \"\\e[33mPush failed, retrying ($attempt/$MAX_RETRIES)...\\e[0m\"\n
    \   git pull --rebase\n    \n    # Calculate backoff delay (5s, then 10s, then
    20s)\n    BACKOFF_DELAY=$((INITIAL_DELAY * 2**(attempt-1)))\n    echo \"Waiting
    ${BACKOFF_DELAY} seconds before next attempt...\"\n    sleep $BACKOFF_DELAY\n
    \ fi\ndone\n\nif [ \"$success\" != \"true\" ]; then\n  echo -e \"\\e[31mFailed
    to push after $MAX_RETRIES attempts\\e[0m\"\n  exit 1\nfi\n"
  - git status
  - echo "Resources published to argocd mono repo"
  variables:
    DESTINATION_REPO: https://gitlab.com/fireblocks/devops/iac/argocd.git
    DESTINATION_PROJECT_ID: 50521873
    SOURCE_PATH: deployment
    DESTINATION_PATH: services/shell
    STATE_BRANCH: main
    GITLAB_API_URL: https://gitlab.com/api/v4/projects
    TEMPLATE_REF: "$TEMPLATE_REF"
    GITLAB_RUNNER_TAG: devx-application-gitlab-runner
    ENV: dev11
  extends: ".publish_resources_dev"
".publish_resources_dev12":
  stage: configure
  retry:
    max: 2
    when:
    - script_failure
  tags:
  - "${GITLAB_RUNNER_TAG}"
  before_script:
  - printf "%s:%s\n" DESTINATION_REPO "$DESTINATION_REPO" DESTINATION_PROJECT_ID "$DESTINATION_PROJECT_ID"
    SOURCE_PATH "$SOURCE_PATH" DESTINATION_PATH "$DESTINATION_PATH" STATE_BRANCH "$STATE_BRANCH"
    GITLAB_API_URL "$GITLAB_API_URL"
  - |
    if [ ! -d "$SOURCE_PATH" ]; then
      echo "$SOURCE_PATH directory does not exist. Exiting job successfully."
      exit 0
    fi
    echo "$SOURCE_PATH directory exists. Continuing with deployment."
  - - apk update
    - apk add curl jq yq py3-pip
    - pip3 install --upgrade pip
    - pip3 install yamllint
    - pip3 install yamale --break-system-packages
    - npm install -g ajv-cli
    - echo "Configuring Git"
    - echo "https://argocd-ci-push:${ARGOCD_GITLAB_ACCESS_TOKEN}@gitlab.com" > ~/.git-credentials
    - git remote set-url origin https://argocd-ci-push:${ARGOCD_GITLAB_ACCESS_TOKEN}@gitlab.com/fireblocks/devops/iac/argocd.git
    - git config --global user.email "devops@fireblocks.com"
    - git config --global user.name "argocd-ci-push"
    - git config --global credential.helper store
    - touch .npmrc
    - npm config set --location=user @fireblocks:registry https://gitlab.com/api/v4/packages/npm/
    - npm config set --location=user '//gitlab.com/api/v4/packages/npm/:_authToken'
      "${NPM_REG_TOKEN}"
    - npm config set --location=user '//gitlab.com/api/v4/projects/20565764/packages/npm/:_authToken'
      "${NPM_REG_TOKEN}"
    - echo "@fireblocks:registry=https://gitlab.com/api/v4/packages/npm/">>.npmrc
    - echo "//gitlab.com/api/v4/packages/npm/:_authToken=${NPM_REG_TOKEN}">>.npmrc
    - echo "//gitlab.com/api/v4/projects/20565764/packages/npm/:_authToken=${NPM_REG_TOKEN}">>.npmrc
    - yarn global add @fireblocks/fb-cli
  script:
  - - echo "Self Service User Guide - https://fireblocks.atlassian.net/wiki/spaces/RD/pages/1413218873/Self+Service+User+Guide"
    - SVC_NAME=$([ "$SERVICE_NAME" ] && echo $SERVICE_NAME || echo $CI_PROJECT_NAME)
    - echo "Verifying deployment folder for ${SVC_NAME} service"
    - git clone ${DESTINATION_REPO} mono_repo
    - cd mono_repo
    - git fetch --all
    - git checkout ${STATE_BRANCH}
    - git pull origin ${STATE_BRANCH} --no-rebase
    - cd ../${SOURCE_PATH}
    - |
      # Define the paths
      values_file="values.yaml"

      # Check for values.yaml in the deployment folder
      if [ ! -f "$values_file" ]; then
          echo "Error: The values.yaml file is missing in the ${SOURCE_PATH} folder."
          exit 1
      fi

      echo "Success: All required files are present"
    - |
      # Directory to check
      DIR_TO_CHECK="overrides/"

      # List of allowed files
      ALLOWED_PATTERN=$(printf "|%s" "nonprod-tier.yaml" "prod-tier.yaml" "iac-dev.yaml" "localstack.yaml" "dev1.yaml" "dev2.yaml" "dev3.yaml" "dev4.yaml" "dev5.yaml" "dev6.yaml" "dev7.yaml" "dev8.yaml" "dev9.yaml" "dev10.yaml" "dev11.yaml" "dev11.yaml" "dev12.yaml" "dev13.yaml" "dev14.yaml" "dev15.yaml" "pre1.yaml" "stage.yaml" "sandbox.yaml" "eu-prod.yaml" "eu2-prod.yaml" "bnym-dev.yaml" "bnym-prod.yaml" "us-prod.yaml" | cut -c 2-)

      # Flag to track if there are disallowed files
      DISALLOWED_FOUND=false

      # Check for files in the directory that are not in the allowed list
      for file in "$DIR_TO_CHECK"/*; do
        # Get the base name of the file
        filename=$(basename "$file")

        # Check if the filename is in the allowed list
        if [[ ! $filename =~ ^($ALLOWED_PATTERN)$ ]]; then
          echo "Disallowed file found: $filename"
          DISALLOWED_FOUND=true
        fi
      done

      # Final output
      if $DISALLOWED_FOUND; then
        echo "Some files are not allowed."
        exit 1
      else
        echo "All files are allowed."
      fi
    - echo "Linting deployment yaml files"
    - cp ../mono_repo/services/schema/*.yaml .
    - cp ../mono_repo/services/schema/appconfig_schema.json .
    - cp ../mono_repo/services/schema/main_appconfig.json appconfig.json
    - cp ../mono_repo/services/schema/yamllint_rules.yaml yamllint_rules.yaml
    - yamllint --list-files **/*.yaml *.yaml
    - yamllint -s **/*.yaml *.yaml -c yamllint_rules.yaml
    - echo "Validating deployment yaml schema"
    - yamale -s base_values_schema.yaml values.yaml
    - yamale -s tier_values_schema.yaml overrides/prod-tier.yaml
    - yamale -s tier_values_schema.yaml overrides/nonprod-tier.yaml
    - |
      # Iterate over all yaml files in the overrides folder
      for file in overrides/*.yaml; do
          # Extract the filename from the path
          filename=$(basename -- "$file")

          # Check if the file is not prod-tier.yaml or nonprod-tier.yaml
          if [[ "$filename" != "prod-tier.yaml" ]] && [[ "$filename" != "nonprod-tier.yaml" ]]; then
              # Run yamale command on the file
              yamale -s env_values_schema.yaml "$file"
          fi
      done
    - "# Iterate over all yaml files in the overrides folder - validate_resources.sh\nif
      [[ -v ENGINE && \"$ENGINE\" == \"argocd\" ]]; then\n  export CD_INFRA_PROJECT_ID=61508954\n
      \ curl --header \"PRIVATE-TOKEN: $CD_CPU_RAM_REQUEST_LIMIT_READ_ONLY\"  \"https://gitlab.com/api/v4/projects/$CD_INFRA_PROJECT_ID/repository/files/ci-infra%2Fscripts%2Fvalidate_resources.sh/raw?ref=main\"
      -o \"$CI_PROJECT_DIR/validate_resources.sh\"\n  echo \"chmod +x $CI_PROJECT_DIR/validate_resources.sh\"
      \n  chmod +x \"$CI_PROJECT_DIR/validate_resources.sh\"\n  echo \"Searching for
      environments values files...\" \n  ENV_FILES_LIST=$(yamllint --list-files **/*.yaml
      *.yaml | grep -vE 'env_values_schema\\.yaml|tier_values_schema\\.yaml|base_values_schema\\.yaml|yamllint_rules\\.yaml|.*prod-tier\\.yaml|values.yaml'
      || true)\n  if [[ -n \"$ENV_FILES_LIST\" ]]; then\n    echo \"Found environments
      values files\"\n    while IFS= read -r file; do\n      filename=$(basename --
      \"$file\")\n      if [[ \"$filename\" =~ ^(dev[1-9]|dev10|stage|pre1).yaml$
      ]]; then\n        tier_file=\"overrides/nonprod-tier.yaml\"\n      else\n        tier_file=\"overrides/prod-tier.yaml\"
      \ \n      fi\n      echo \"values.yaml <-- $tier_file <-- $file\"\n      yq
      eval-all '. as $item ireduce ({}; . * $item)' values.yaml \"$tier_file\" \"$file\"
      | bash \"$CI_PROJECT_DIR/validate_resources.sh\" -\n    done <<< \"$ENV_FILES_LIST\"\n
      \ else\n    echo \"No environments values files were found. Continuing to the
      tier files.\"\n  fi\necho \"values.yaml <-- overrides/nonprod-tier.yaml\"\nyq
      eval-all '. as $item ireduce ({}; . * $item)' values.yaml overrides/nonprod-tier.yaml
      | bash \"$CI_PROJECT_DIR/validate_resources.sh\" -\necho \"values.yaml <-- overrides/prod-tier.yaml\"
      \nyq eval-all '. as $item ireduce ({}; . * $item)' values.yaml overrides/prod-tier.yaml
      | bash \"$CI_PROJECT_DIR/validate_resources.sh\" -\nelse\n  echo \"Skipping
      resource validation: ENGINE is not set to 'argocd'.\"\nfi\n"
    - ajv validate -s appconfig_schema.json -d appconfig.json
    - echo "Resources verified successfully"
    - echo "Validate filter_policy if exists - should be a valid JSON object"
    - fb deployment:validate . --filter-policy
  - cd ../mono_repo
  - ENV_DESTINATION_PATH=$(echo "${DESTINATION_PATH}/${SVC_NAME}/${ENV}")
  - echo "Copying ${SOURCE_PATH} folder from ${SVC_NAME} service to argocd mono repo
    destination folder at ${ENV_DESTINATION_PATH}"
  - mkdir -pv ${ENV_DESTINATION_PATH}/overrides
  - rm ${ENV_DESTINATION_PATH}/overrides/${ENV}.yaml || true
  - cp  ../${SOURCE_PATH}/values.yaml ${ENV_DESTINATION_PATH}
  - cp ../${SOURCE_PATH}/overrides/${ENV}.yaml  ${ENV_DESTINATION_PATH}/overrides
    || true
  - cp ../${SOURCE_PATH}/overrides/*-tier.yaml  ${ENV_DESTINATION_PATH}/overrides
    || true
  - if [ ! -f ${ENV_DESTINATION_PATH}/appconfig.json ]; then cp ../mono_repo/services/schema/main_appconfig.json
    ${ENV_DESTINATION_PATH}/appconfig.json; fi
  - git status
  - echo "Adding changes to Git"
  - git add ${DESTINATION_PATH}
  - git status
  - COUNT=$(git diff --numstat ${STATE_BRANCH} | awk '{added += $1; deleted += $2}
    END {print added + deleted}')
  - |
    if [ "$COUNT" -eq 0 ]; then
      echo "No changes detected under ${CI_PROJECT_NAME}/${SOURCE_PATH}, exiting"
      exit 0
    fi
  - echo "Committing changes"
  - git commit -m "${CI_JOB_NAME}"
  - echo "Pushing changes to remote"
  - git pull --rebase
  - git status
  - "MAX_RETRIES=3\nINITIAL_DELAY=5\nsuccess=false\n\nfor attempt in $(seq 1 $MAX_RETRIES);
    do\n  if git push; then\n    echo -e \"\\e[32mPush successful\\e[0m\"\n    success=true\n
    \   break\n  else\n    echo -e \"\\e[33mPush failed, retrying ($attempt/$MAX_RETRIES)...\\e[0m\"\n
    \   git pull --rebase\n    \n    # Calculate backoff delay (5s, then 10s, then
    20s)\n    BACKOFF_DELAY=$((INITIAL_DELAY * 2**(attempt-1)))\n    echo \"Waiting
    ${BACKOFF_DELAY} seconds before next attempt...\"\n    sleep $BACKOFF_DELAY\n
    \ fi\ndone\n\nif [ \"$success\" != \"true\" ]; then\n  echo -e \"\\e[31mFailed
    to push after $MAX_RETRIES attempts\\e[0m\"\n  exit 1\nfi\n"
  - git status
  - echo "Resources published to argocd mono repo"
  variables:
    DESTINATION_REPO: https://gitlab.com/fireblocks/devops/iac/argocd.git
    DESTINATION_PROJECT_ID: 50521873
    SOURCE_PATH: deployment
    DESTINATION_PATH: services/shell
    STATE_BRANCH: main
    GITLAB_API_URL: https://gitlab.com/api/v4/projects
    TEMPLATE_REF: "$TEMPLATE_REF"
    GITLAB_RUNNER_TAG: devx-application-gitlab-runner
    ENV: dev12
  extends: ".publish_resources_dev"
".publish_resources_dev13":
  stage: configure
  retry:
    max: 2
    when:
    - script_failure
  tags:
  - "${GITLAB_RUNNER_TAG}"
  before_script:
  - printf "%s:%s\n" DESTINATION_REPO "$DESTINATION_REPO" DESTINATION_PROJECT_ID "$DESTINATION_PROJECT_ID"
    SOURCE_PATH "$SOURCE_PATH" DESTINATION_PATH "$DESTINATION_PATH" STATE_BRANCH "$STATE_BRANCH"
    GITLAB_API_URL "$GITLAB_API_URL"
  - |
    if [ ! -d "$SOURCE_PATH" ]; then
      echo "$SOURCE_PATH directory does not exist. Exiting job successfully."
      exit 0
    fi
    echo "$SOURCE_PATH directory exists. Continuing with deployment."
  - - apk update
    - apk add curl jq yq py3-pip
    - pip3 install --upgrade pip
    - pip3 install yamllint
    - pip3 install yamale --break-system-packages
    - npm install -g ajv-cli
    - echo "Configuring Git"
    - echo "https://argocd-ci-push:${ARGOCD_GITLAB_ACCESS_TOKEN}@gitlab.com" > ~/.git-credentials
    - git remote set-url origin https://argocd-ci-push:${ARGOCD_GITLAB_ACCESS_TOKEN}@gitlab.com/fireblocks/devops/iac/argocd.git
    - git config --global user.email "devops@fireblocks.com"
    - git config --global user.name "argocd-ci-push"
    - git config --global credential.helper store
    - touch .npmrc
    - npm config set --location=user @fireblocks:registry https://gitlab.com/api/v4/packages/npm/
    - npm config set --location=user '//gitlab.com/api/v4/packages/npm/:_authToken'
      "${NPM_REG_TOKEN}"
    - npm config set --location=user '//gitlab.com/api/v4/projects/20565764/packages/npm/:_authToken'
      "${NPM_REG_TOKEN}"
    - echo "@fireblocks:registry=https://gitlab.com/api/v4/packages/npm/">>.npmrc
    - echo "//gitlab.com/api/v4/packages/npm/:_authToken=${NPM_REG_TOKEN}">>.npmrc
    - echo "//gitlab.com/api/v4/projects/20565764/packages/npm/:_authToken=${NPM_REG_TOKEN}">>.npmrc
    - yarn global add @fireblocks/fb-cli
  script:
  - - echo "Self Service User Guide - https://fireblocks.atlassian.net/wiki/spaces/RD/pages/1413218873/Self+Service+User+Guide"
    - SVC_NAME=$([ "$SERVICE_NAME" ] && echo $SERVICE_NAME || echo $CI_PROJECT_NAME)
    - echo "Verifying deployment folder for ${SVC_NAME} service"
    - git clone ${DESTINATION_REPO} mono_repo
    - cd mono_repo
    - git fetch --all
    - git checkout ${STATE_BRANCH}
    - git pull origin ${STATE_BRANCH} --no-rebase
    - cd ../${SOURCE_PATH}
    - |
      # Define the paths
      values_file="values.yaml"

      # Check for values.yaml in the deployment folder
      if [ ! -f "$values_file" ]; then
          echo "Error: The values.yaml file is missing in the ${SOURCE_PATH} folder."
          exit 1
      fi

      echo "Success: All required files are present"
    - |
      # Directory to check
      DIR_TO_CHECK="overrides/"

      # List of allowed files
      ALLOWED_PATTERN=$(printf "|%s" "nonprod-tier.yaml" "prod-tier.yaml" "iac-dev.yaml" "localstack.yaml" "dev1.yaml" "dev2.yaml" "dev3.yaml" "dev4.yaml" "dev5.yaml" "dev6.yaml" "dev7.yaml" "dev8.yaml" "dev9.yaml" "dev10.yaml" "dev11.yaml" "dev11.yaml" "dev12.yaml" "dev13.yaml" "dev14.yaml" "dev15.yaml" "pre1.yaml" "stage.yaml" "sandbox.yaml" "eu-prod.yaml" "eu2-prod.yaml" "bnym-dev.yaml" "bnym-prod.yaml" "us-prod.yaml" | cut -c 2-)

      # Flag to track if there are disallowed files
      DISALLOWED_FOUND=false

      # Check for files in the directory that are not in the allowed list
      for file in "$DIR_TO_CHECK"/*; do
        # Get the base name of the file
        filename=$(basename "$file")

        # Check if the filename is in the allowed list
        if [[ ! $filename =~ ^($ALLOWED_PATTERN)$ ]]; then
          echo "Disallowed file found: $filename"
          DISALLOWED_FOUND=true
        fi
      done

      # Final output
      if $DISALLOWED_FOUND; then
        echo "Some files are not allowed."
        exit 1
      else
        echo "All files are allowed."
      fi
    - echo "Linting deployment yaml files"
    - cp ../mono_repo/services/schema/*.yaml .
    - cp ../mono_repo/services/schema/appconfig_schema.json .
    - cp ../mono_repo/services/schema/main_appconfig.json appconfig.json
    - cp ../mono_repo/services/schema/yamllint_rules.yaml yamllint_rules.yaml
    - yamllint --list-files **/*.yaml *.yaml
    - yamllint -s **/*.yaml *.yaml -c yamllint_rules.yaml
    - echo "Validating deployment yaml schema"
    - yamale -s base_values_schema.yaml values.yaml
    - yamale -s tier_values_schema.yaml overrides/prod-tier.yaml
    - yamale -s tier_values_schema.yaml overrides/nonprod-tier.yaml
    - |
      # Iterate over all yaml files in the overrides folder
      for file in overrides/*.yaml; do
          # Extract the filename from the path
          filename=$(basename -- "$file")

          # Check if the file is not prod-tier.yaml or nonprod-tier.yaml
          if [[ "$filename" != "prod-tier.yaml" ]] && [[ "$filename" != "nonprod-tier.yaml" ]]; then
              # Run yamale command on the file
              yamale -s env_values_schema.yaml "$file"
          fi
      done
    - "# Iterate over all yaml files in the overrides folder - validate_resources.sh\nif
      [[ -v ENGINE && \"$ENGINE\" == \"argocd\" ]]; then\n  export CD_INFRA_PROJECT_ID=61508954\n
      \ curl --header \"PRIVATE-TOKEN: $CD_CPU_RAM_REQUEST_LIMIT_READ_ONLY\"  \"https://gitlab.com/api/v4/projects/$CD_INFRA_PROJECT_ID/repository/files/ci-infra%2Fscripts%2Fvalidate_resources.sh/raw?ref=main\"
      -o \"$CI_PROJECT_DIR/validate_resources.sh\"\n  echo \"chmod +x $CI_PROJECT_DIR/validate_resources.sh\"
      \n  chmod +x \"$CI_PROJECT_DIR/validate_resources.sh\"\n  echo \"Searching for
      environments values files...\" \n  ENV_FILES_LIST=$(yamllint --list-files **/*.yaml
      *.yaml | grep -vE 'env_values_schema\\.yaml|tier_values_schema\\.yaml|base_values_schema\\.yaml|yamllint_rules\\.yaml|.*prod-tier\\.yaml|values.yaml'
      || true)\n  if [[ -n \"$ENV_FILES_LIST\" ]]; then\n    echo \"Found environments
      values files\"\n    while IFS= read -r file; do\n      filename=$(basename --
      \"$file\")\n      if [[ \"$filename\" =~ ^(dev[1-9]|dev10|stage|pre1).yaml$
      ]]; then\n        tier_file=\"overrides/nonprod-tier.yaml\"\n      else\n        tier_file=\"overrides/prod-tier.yaml\"
      \ \n      fi\n      echo \"values.yaml <-- $tier_file <-- $file\"\n      yq
      eval-all '. as $item ireduce ({}; . * $item)' values.yaml \"$tier_file\" \"$file\"
      | bash \"$CI_PROJECT_DIR/validate_resources.sh\" -\n    done <<< \"$ENV_FILES_LIST\"\n
      \ else\n    echo \"No environments values files were found. Continuing to the
      tier files.\"\n  fi\necho \"values.yaml <-- overrides/nonprod-tier.yaml\"\nyq
      eval-all '. as $item ireduce ({}; . * $item)' values.yaml overrides/nonprod-tier.yaml
      | bash \"$CI_PROJECT_DIR/validate_resources.sh\" -\necho \"values.yaml <-- overrides/prod-tier.yaml\"
      \nyq eval-all '. as $item ireduce ({}; . * $item)' values.yaml overrides/prod-tier.yaml
      | bash \"$CI_PROJECT_DIR/validate_resources.sh\" -\nelse\n  echo \"Skipping
      resource validation: ENGINE is not set to 'argocd'.\"\nfi\n"
    - ajv validate -s appconfig_schema.json -d appconfig.json
    - echo "Resources verified successfully"
    - echo "Validate filter_policy if exists - should be a valid JSON object"
    - fb deployment:validate . --filter-policy
  - cd ../mono_repo
  - ENV_DESTINATION_PATH=$(echo "${DESTINATION_PATH}/${SVC_NAME}/${ENV}")
  - echo "Copying ${SOURCE_PATH} folder from ${SVC_NAME} service to argocd mono repo
    destination folder at ${ENV_DESTINATION_PATH}"
  - mkdir -pv ${ENV_DESTINATION_PATH}/overrides
  - rm ${ENV_DESTINATION_PATH}/overrides/${ENV}.yaml || true
  - cp  ../${SOURCE_PATH}/values.yaml ${ENV_DESTINATION_PATH}
  - cp ../${SOURCE_PATH}/overrides/${ENV}.yaml  ${ENV_DESTINATION_PATH}/overrides
    || true
  - cp ../${SOURCE_PATH}/overrides/*-tier.yaml  ${ENV_DESTINATION_PATH}/overrides
    || true
  - if [ ! -f ${ENV_DESTINATION_PATH}/appconfig.json ]; then cp ../mono_repo/services/schema/main_appconfig.json
    ${ENV_DESTINATION_PATH}/appconfig.json; fi
  - git status
  - echo "Adding changes to Git"
  - git add ${DESTINATION_PATH}
  - git status
  - COUNT=$(git diff --numstat ${STATE_BRANCH} | awk '{added += $1; deleted += $2}
    END {print added + deleted}')
  - |
    if [ "$COUNT" -eq 0 ]; then
      echo "No changes detected under ${CI_PROJECT_NAME}/${SOURCE_PATH}, exiting"
      exit 0
    fi
  - echo "Committing changes"
  - git commit -m "${CI_JOB_NAME}"
  - echo "Pushing changes to remote"
  - git pull --rebase
  - git status
  - "MAX_RETRIES=3\nINITIAL_DELAY=5\nsuccess=false\n\nfor attempt in $(seq 1 $MAX_RETRIES);
    do\n  if git push; then\n    echo -e \"\\e[32mPush successful\\e[0m\"\n    success=true\n
    \   break\n  else\n    echo -e \"\\e[33mPush failed, retrying ($attempt/$MAX_RETRIES)...\\e[0m\"\n
    \   git pull --rebase\n    \n    # Calculate backoff delay (5s, then 10s, then
    20s)\n    BACKOFF_DELAY=$((INITIAL_DELAY * 2**(attempt-1)))\n    echo \"Waiting
    ${BACKOFF_DELAY} seconds before next attempt...\"\n    sleep $BACKOFF_DELAY\n
    \ fi\ndone\n\nif [ \"$success\" != \"true\" ]; then\n  echo -e \"\\e[31mFailed
    to push after $MAX_RETRIES attempts\\e[0m\"\n  exit 1\nfi\n"
  - git status
  - echo "Resources published to argocd mono repo"
  variables:
    DESTINATION_REPO: https://gitlab.com/fireblocks/devops/iac/argocd.git
    DESTINATION_PROJECT_ID: 50521873
    SOURCE_PATH: deployment
    DESTINATION_PATH: services/shell
    STATE_BRANCH: main
    GITLAB_API_URL: https://gitlab.com/api/v4/projects
    TEMPLATE_REF: "$TEMPLATE_REF"
    GITLAB_RUNNER_TAG: devx-application-gitlab-runner
    ENV: dev13
  extends: ".publish_resources_dev"
".publish_resources_dev14":
  stage: configure
  retry:
    max: 2
    when:
    - script_failure
  tags:
  - "${GITLAB_RUNNER_TAG}"
  before_script:
  - printf "%s:%s\n" DESTINATION_REPO "$DESTINATION_REPO" DESTINATION_PROJECT_ID "$DESTINATION_PROJECT_ID"
    SOURCE_PATH "$SOURCE_PATH" DESTINATION_PATH "$DESTINATION_PATH" STATE_BRANCH "$STATE_BRANCH"
    GITLAB_API_URL "$GITLAB_API_URL"
  - |
    if [ ! -d "$SOURCE_PATH" ]; then
      echo "$SOURCE_PATH directory does not exist. Exiting job successfully."
      exit 0
    fi
    echo "$SOURCE_PATH directory exists. Continuing with deployment."
  - - apk update
    - apk add curl jq yq py3-pip
    - pip3 install --upgrade pip
    - pip3 install yamllint
    - pip3 install yamale --break-system-packages
    - npm install -g ajv-cli
    - echo "Configuring Git"
    - echo "https://argocd-ci-push:${ARGOCD_GITLAB_ACCESS_TOKEN}@gitlab.com" > ~/.git-credentials
    - git remote set-url origin https://argocd-ci-push:${ARGOCD_GITLAB_ACCESS_TOKEN}@gitlab.com/fireblocks/devops/iac/argocd.git
    - git config --global user.email "devops@fireblocks.com"
    - git config --global user.name "argocd-ci-push"
    - git config --global credential.helper store
    - touch .npmrc
    - npm config set --location=user @fireblocks:registry https://gitlab.com/api/v4/packages/npm/
    - npm config set --location=user '//gitlab.com/api/v4/packages/npm/:_authToken'
      "${NPM_REG_TOKEN}"
    - npm config set --location=user '//gitlab.com/api/v4/projects/20565764/packages/npm/:_authToken'
      "${NPM_REG_TOKEN}"
    - echo "@fireblocks:registry=https://gitlab.com/api/v4/packages/npm/">>.npmrc
    - echo "//gitlab.com/api/v4/packages/npm/:_authToken=${NPM_REG_TOKEN}">>.npmrc
    - echo "//gitlab.com/api/v4/projects/20565764/packages/npm/:_authToken=${NPM_REG_TOKEN}">>.npmrc
    - yarn global add @fireblocks/fb-cli
  script:
  - - echo "Self Service User Guide - https://fireblocks.atlassian.net/wiki/spaces/RD/pages/1413218873/Self+Service+User+Guide"
    - SVC_NAME=$([ "$SERVICE_NAME" ] && echo $SERVICE_NAME || echo $CI_PROJECT_NAME)
    - echo "Verifying deployment folder for ${SVC_NAME} service"
    - git clone ${DESTINATION_REPO} mono_repo
    - cd mono_repo
    - git fetch --all
    - git checkout ${STATE_BRANCH}
    - git pull origin ${STATE_BRANCH} --no-rebase
    - cd ../${SOURCE_PATH}
    - |
      # Define the paths
      values_file="values.yaml"

      # Check for values.yaml in the deployment folder
      if [ ! -f "$values_file" ]; then
          echo "Error: The values.yaml file is missing in the ${SOURCE_PATH} folder."
          exit 1
      fi

      echo "Success: All required files are present"
    - |
      # Directory to check
      DIR_TO_CHECK="overrides/"

      # List of allowed files
      ALLOWED_PATTERN=$(printf "|%s" "nonprod-tier.yaml" "prod-tier.yaml" "iac-dev.yaml" "localstack.yaml" "dev1.yaml" "dev2.yaml" "dev3.yaml" "dev4.yaml" "dev5.yaml" "dev6.yaml" "dev7.yaml" "dev8.yaml" "dev9.yaml" "dev10.yaml" "dev11.yaml" "dev11.yaml" "dev12.yaml" "dev13.yaml" "dev14.yaml" "dev15.yaml" "pre1.yaml" "stage.yaml" "sandbox.yaml" "eu-prod.yaml" "eu2-prod.yaml" "bnym-dev.yaml" "bnym-prod.yaml" "us-prod.yaml" | cut -c 2-)

      # Flag to track if there are disallowed files
      DISALLOWED_FOUND=false

      # Check for files in the directory that are not in the allowed list
      for file in "$DIR_TO_CHECK"/*; do
        # Get the base name of the file
        filename=$(basename "$file")

        # Check if the filename is in the allowed list
        if [[ ! $filename =~ ^($ALLOWED_PATTERN)$ ]]; then
          echo "Disallowed file found: $filename"
          DISALLOWED_FOUND=true
        fi
      done

      # Final output
      if $DISALLOWED_FOUND; then
        echo "Some files are not allowed."
        exit 1
      else
        echo "All files are allowed."
      fi
    - echo "Linting deployment yaml files"
    - cp ../mono_repo/services/schema/*.yaml .
    - cp ../mono_repo/services/schema/appconfig_schema.json .
    - cp ../mono_repo/services/schema/main_appconfig.json appconfig.json
    - cp ../mono_repo/services/schema/yamllint_rules.yaml yamllint_rules.yaml
    - yamllint --list-files **/*.yaml *.yaml
    - yamllint -s **/*.yaml *.yaml -c yamllint_rules.yaml
    - echo "Validating deployment yaml schema"
    - yamale -s base_values_schema.yaml values.yaml
    - yamale -s tier_values_schema.yaml overrides/prod-tier.yaml
    - yamale -s tier_values_schema.yaml overrides/nonprod-tier.yaml
    - |
      # Iterate over all yaml files in the overrides folder
      for file in overrides/*.yaml; do
          # Extract the filename from the path
          filename=$(basename -- "$file")

          # Check if the file is not prod-tier.yaml or nonprod-tier.yaml
          if [[ "$filename" != "prod-tier.yaml" ]] && [[ "$filename" != "nonprod-tier.yaml" ]]; then
              # Run yamale command on the file
              yamale -s env_values_schema.yaml "$file"
          fi
      done
    - "# Iterate over all yaml files in the overrides folder - validate_resources.sh\nif
      [[ -v ENGINE && \"$ENGINE\" == \"argocd\" ]]; then\n  export CD_INFRA_PROJECT_ID=61508954\n
      \ curl --header \"PRIVATE-TOKEN: $CD_CPU_RAM_REQUEST_LIMIT_READ_ONLY\"  \"https://gitlab.com/api/v4/projects/$CD_INFRA_PROJECT_ID/repository/files/ci-infra%2Fscripts%2Fvalidate_resources.sh/raw?ref=main\"
      -o \"$CI_PROJECT_DIR/validate_resources.sh\"\n  echo \"chmod +x $CI_PROJECT_DIR/validate_resources.sh\"
      \n  chmod +x \"$CI_PROJECT_DIR/validate_resources.sh\"\n  echo \"Searching for
      environments values files...\" \n  ENV_FILES_LIST=$(yamllint --list-files **/*.yaml
      *.yaml | grep -vE 'env_values_schema\\.yaml|tier_values_schema\\.yaml|base_values_schema\\.yaml|yamllint_rules\\.yaml|.*prod-tier\\.yaml|values.yaml'
      || true)\n  if [[ -n \"$ENV_FILES_LIST\" ]]; then\n    echo \"Found environments
      values files\"\n    while IFS= read -r file; do\n      filename=$(basename --
      \"$file\")\n      if [[ \"$filename\" =~ ^(dev[1-9]|dev10|stage|pre1).yaml$
      ]]; then\n        tier_file=\"overrides/nonprod-tier.yaml\"\n      else\n        tier_file=\"overrides/prod-tier.yaml\"
      \ \n      fi\n      echo \"values.yaml <-- $tier_file <-- $file\"\n      yq
      eval-all '. as $item ireduce ({}; . * $item)' values.yaml \"$tier_file\" \"$file\"
      | bash \"$CI_PROJECT_DIR/validate_resources.sh\" -\n    done <<< \"$ENV_FILES_LIST\"\n
      \ else\n    echo \"No environments values files were found. Continuing to the
      tier files.\"\n  fi\necho \"values.yaml <-- overrides/nonprod-tier.yaml\"\nyq
      eval-all '. as $item ireduce ({}; . * $item)' values.yaml overrides/nonprod-tier.yaml
      | bash \"$CI_PROJECT_DIR/validate_resources.sh\" -\necho \"values.yaml <-- overrides/prod-tier.yaml\"
      \nyq eval-all '. as $item ireduce ({}; . * $item)' values.yaml overrides/prod-tier.yaml
      | bash \"$CI_PROJECT_DIR/validate_resources.sh\" -\nelse\n  echo \"Skipping
      resource validation: ENGINE is not set to 'argocd'.\"\nfi\n"
    - ajv validate -s appconfig_schema.json -d appconfig.json
    - echo "Resources verified successfully"
    - echo "Validate filter_policy if exists - should be a valid JSON object"
    - fb deployment:validate . --filter-policy
  - cd ../mono_repo
  - ENV_DESTINATION_PATH=$(echo "${DESTINATION_PATH}/${SVC_NAME}/${ENV}")
  - echo "Copying ${SOURCE_PATH} folder from ${SVC_NAME} service to argocd mono repo
    destination folder at ${ENV_DESTINATION_PATH}"
  - mkdir -pv ${ENV_DESTINATION_PATH}/overrides
  - rm ${ENV_DESTINATION_PATH}/overrides/${ENV}.yaml || true
  - cp  ../${SOURCE_PATH}/values.yaml ${ENV_DESTINATION_PATH}
  - cp ../${SOURCE_PATH}/overrides/${ENV}.yaml  ${ENV_DESTINATION_PATH}/overrides
    || true
  - cp ../${SOURCE_PATH}/overrides/*-tier.yaml  ${ENV_DESTINATION_PATH}/overrides
    || true
  - if [ ! -f ${ENV_DESTINATION_PATH}/appconfig.json ]; then cp ../mono_repo/services/schema/main_appconfig.json
    ${ENV_DESTINATION_PATH}/appconfig.json; fi
  - git status
  - echo "Adding changes to Git"
  - git add ${DESTINATION_PATH}
  - git status
  - COUNT=$(git diff --numstat ${STATE_BRANCH} | awk '{added += $1; deleted += $2}
    END {print added + deleted}')
  - |
    if [ "$COUNT" -eq 0 ]; then
      echo "No changes detected under ${CI_PROJECT_NAME}/${SOURCE_PATH}, exiting"
      exit 0
    fi
  - echo "Committing changes"
  - git commit -m "${CI_JOB_NAME}"
  - echo "Pushing changes to remote"
  - git pull --rebase
  - git status
  - "MAX_RETRIES=3\nINITIAL_DELAY=5\nsuccess=false\n\nfor attempt in $(seq 1 $MAX_RETRIES);
    do\n  if git push; then\n    echo -e \"\\e[32mPush successful\\e[0m\"\n    success=true\n
    \   break\n  else\n    echo -e \"\\e[33mPush failed, retrying ($attempt/$MAX_RETRIES)...\\e[0m\"\n
    \   git pull --rebase\n    \n    # Calculate backoff delay (5s, then 10s, then
    20s)\n    BACKOFF_DELAY=$((INITIAL_DELAY * 2**(attempt-1)))\n    echo \"Waiting
    ${BACKOFF_DELAY} seconds before next attempt...\"\n    sleep $BACKOFF_DELAY\n
    \ fi\ndone\n\nif [ \"$success\" != \"true\" ]; then\n  echo -e \"\\e[31mFailed
    to push after $MAX_RETRIES attempts\\e[0m\"\n  exit 1\nfi\n"
  - git status
  - echo "Resources published to argocd mono repo"
  variables:
    DESTINATION_REPO: https://gitlab.com/fireblocks/devops/iac/argocd.git
    DESTINATION_PROJECT_ID: 50521873
    SOURCE_PATH: deployment
    DESTINATION_PATH: services/shell
    STATE_BRANCH: main
    GITLAB_API_URL: https://gitlab.com/api/v4/projects
    TEMPLATE_REF: "$TEMPLATE_REF"
    GITLAB_RUNNER_TAG: devx-application-gitlab-runner
    ENV: dev14
  extends: ".publish_resources_dev"
".publish_resources_dev15":
  stage: configure
  retry:
    max: 2
    when:
    - script_failure
  tags:
  - "${GITLAB_RUNNER_TAG}"
  before_script:
  - printf "%s:%s\n" DESTINATION_REPO "$DESTINATION_REPO" DESTINATION_PROJECT_ID "$DESTINATION_PROJECT_ID"
    SOURCE_PATH "$SOURCE_PATH" DESTINATION_PATH "$DESTINATION_PATH" STATE_BRANCH "$STATE_BRANCH"
    GITLAB_API_URL "$GITLAB_API_URL"
  - |
    if [ ! -d "$SOURCE_PATH" ]; then
      echo "$SOURCE_PATH directory does not exist. Exiting job successfully."
      exit 0
    fi
    echo "$SOURCE_PATH directory exists. Continuing with deployment."
  - - apk update
    - apk add curl jq yq py3-pip
    - pip3 install --upgrade pip
    - pip3 install yamllint
    - pip3 install yamale --break-system-packages
    - npm install -g ajv-cli
    - echo "Configuring Git"
    - echo "https://argocd-ci-push:${ARGOCD_GITLAB_ACCESS_TOKEN}@gitlab.com" > ~/.git-credentials
    - git remote set-url origin https://argocd-ci-push:${ARGOCD_GITLAB_ACCESS_TOKEN}@gitlab.com/fireblocks/devops/iac/argocd.git
    - git config --global user.email "devops@fireblocks.com"
    - git config --global user.name "argocd-ci-push"
    - git config --global credential.helper store
    - touch .npmrc
    - npm config set --location=user @fireblocks:registry https://gitlab.com/api/v4/packages/npm/
    - npm config set --location=user '//gitlab.com/api/v4/packages/npm/:_authToken'
      "${NPM_REG_TOKEN}"
    - npm config set --location=user '//gitlab.com/api/v4/projects/20565764/packages/npm/:_authToken'
      "${NPM_REG_TOKEN}"
    - echo "@fireblocks:registry=https://gitlab.com/api/v4/packages/npm/">>.npmrc
    - echo "//gitlab.com/api/v4/packages/npm/:_authToken=${NPM_REG_TOKEN}">>.npmrc
    - echo "//gitlab.com/api/v4/projects/20565764/packages/npm/:_authToken=${NPM_REG_TOKEN}">>.npmrc
    - yarn global add @fireblocks/fb-cli
  script:
  - - echo "Self Service User Guide - https://fireblocks.atlassian.net/wiki/spaces/RD/pages/1413218873/Self+Service+User+Guide"
    - SVC_NAME=$([ "$SERVICE_NAME" ] && echo $SERVICE_NAME || echo $CI_PROJECT_NAME)
    - echo "Verifying deployment folder for ${SVC_NAME} service"
    - git clone ${DESTINATION_REPO} mono_repo
    - cd mono_repo
    - git fetch --all
    - git checkout ${STATE_BRANCH}
    - git pull origin ${STATE_BRANCH} --no-rebase
    - cd ../${SOURCE_PATH}
    - |
      # Define the paths
      values_file="values.yaml"

      # Check for values.yaml in the deployment folder
      if [ ! -f "$values_file" ]; then
          echo "Error: The values.yaml file is missing in the ${SOURCE_PATH} folder."
          exit 1
      fi

      echo "Success: All required files are present"
    - |
      # Directory to check
      DIR_TO_CHECK="overrides/"

      # List of allowed files
      ALLOWED_PATTERN=$(printf "|%s" "nonprod-tier.yaml" "prod-tier.yaml" "iac-dev.yaml" "localstack.yaml" "dev1.yaml" "dev2.yaml" "dev3.yaml" "dev4.yaml" "dev5.yaml" "dev6.yaml" "dev7.yaml" "dev8.yaml" "dev9.yaml" "dev10.yaml" "dev11.yaml" "dev11.yaml" "dev12.yaml" "dev13.yaml" "dev14.yaml" "dev15.yaml" "pre1.yaml" "stage.yaml" "sandbox.yaml" "eu-prod.yaml" "eu2-prod.yaml" "bnym-dev.yaml" "bnym-prod.yaml" "us-prod.yaml" | cut -c 2-)

      # Flag to track if there are disallowed files
      DISALLOWED_FOUND=false

      # Check for files in the directory that are not in the allowed list
      for file in "$DIR_TO_CHECK"/*; do
        # Get the base name of the file
        filename=$(basename "$file")

        # Check if the filename is in the allowed list
        if [[ ! $filename =~ ^($ALLOWED_PATTERN)$ ]]; then
          echo "Disallowed file found: $filename"
          DISALLOWED_FOUND=true
        fi
      done

      # Final output
      if $DISALLOWED_FOUND; then
        echo "Some files are not allowed."
        exit 1
      else
        echo "All files are allowed."
      fi
    - echo "Linting deployment yaml files"
    - cp ../mono_repo/services/schema/*.yaml .
    - cp ../mono_repo/services/schema/appconfig_schema.json .
    - cp ../mono_repo/services/schema/main_appconfig.json appconfig.json
    - cp ../mono_repo/services/schema/yamllint_rules.yaml yamllint_rules.yaml
    - yamllint --list-files **/*.yaml *.yaml
    - yamllint -s **/*.yaml *.yaml -c yamllint_rules.yaml
    - echo "Validating deployment yaml schema"
    - yamale -s base_values_schema.yaml values.yaml
    - yamale -s tier_values_schema.yaml overrides/prod-tier.yaml
    - yamale -s tier_values_schema.yaml overrides/nonprod-tier.yaml
    - |
      # Iterate over all yaml files in the overrides folder
      for file in overrides/*.yaml; do
          # Extract the filename from the path
          filename=$(basename -- "$file")

          # Check if the file is not prod-tier.yaml or nonprod-tier.yaml
          if [[ "$filename" != "prod-tier.yaml" ]] && [[ "$filename" != "nonprod-tier.yaml" ]]; then
              # Run yamale command on the file
              yamale -s env_values_schema.yaml "$file"
          fi
      done
    - "# Iterate over all yaml files in the overrides folder - validate_resources.sh\nif
      [[ -v ENGINE && \"$ENGINE\" == \"argocd\" ]]; then\n  export CD_INFRA_PROJECT_ID=61508954\n
      \ curl --header \"PRIVATE-TOKEN: $CD_CPU_RAM_REQUEST_LIMIT_READ_ONLY\"  \"https://gitlab.com/api/v4/projects/$CD_INFRA_PROJECT_ID/repository/files/ci-infra%2Fscripts%2Fvalidate_resources.sh/raw?ref=main\"
      -o \"$CI_PROJECT_DIR/validate_resources.sh\"\n  echo \"chmod +x $CI_PROJECT_DIR/validate_resources.sh\"
      \n  chmod +x \"$CI_PROJECT_DIR/validate_resources.sh\"\n  echo \"Searching for
      environments values files...\" \n  ENV_FILES_LIST=$(yamllint --list-files **/*.yaml
      *.yaml | grep -vE 'env_values_schema\\.yaml|tier_values_schema\\.yaml|base_values_schema\\.yaml|yamllint_rules\\.yaml|.*prod-tier\\.yaml|values.yaml'
      || true)\n  if [[ -n \"$ENV_FILES_LIST\" ]]; then\n    echo \"Found environments
      values files\"\n    while IFS= read -r file; do\n      filename=$(basename --
      \"$file\")\n      if [[ \"$filename\" =~ ^(dev[1-9]|dev10|stage|pre1).yaml$
      ]]; then\n        tier_file=\"overrides/nonprod-tier.yaml\"\n      else\n        tier_file=\"overrides/prod-tier.yaml\"
      \ \n      fi\n      echo \"values.yaml <-- $tier_file <-- $file\"\n      yq
      eval-all '. as $item ireduce ({}; . * $item)' values.yaml \"$tier_file\" \"$file\"
      | bash \"$CI_PROJECT_DIR/validate_resources.sh\" -\n    done <<< \"$ENV_FILES_LIST\"\n
      \ else\n    echo \"No environments values files were found. Continuing to the
      tier files.\"\n  fi\necho \"values.yaml <-- overrides/nonprod-tier.yaml\"\nyq
      eval-all '. as $item ireduce ({}; . * $item)' values.yaml overrides/nonprod-tier.yaml
      | bash \"$CI_PROJECT_DIR/validate_resources.sh\" -\necho \"values.yaml <-- overrides/prod-tier.yaml\"
      \nyq eval-all '. as $item ireduce ({}; . * $item)' values.yaml overrides/prod-tier.yaml
      | bash \"$CI_PROJECT_DIR/validate_resources.sh\" -\nelse\n  echo \"Skipping
      resource validation: ENGINE is not set to 'argocd'.\"\nfi\n"
    - ajv validate -s appconfig_schema.json -d appconfig.json
    - echo "Resources verified successfully"
    - echo "Validate filter_policy if exists - should be a valid JSON object"
    - fb deployment:validate . --filter-policy
  - cd ../mono_repo
  - ENV_DESTINATION_PATH=$(echo "${DESTINATION_PATH}/${SVC_NAME}/${ENV}")
  - echo "Copying ${SOURCE_PATH} folder from ${SVC_NAME} service to argocd mono repo
    destination folder at ${ENV_DESTINATION_PATH}"
  - mkdir -pv ${ENV_DESTINATION_PATH}/overrides
  - rm ${ENV_DESTINATION_PATH}/overrides/${ENV}.yaml || true
  - cp  ../${SOURCE_PATH}/values.yaml ${ENV_DESTINATION_PATH}
  - cp ../${SOURCE_PATH}/overrides/${ENV}.yaml  ${ENV_DESTINATION_PATH}/overrides
    || true
  - cp ../${SOURCE_PATH}/overrides/*-tier.yaml  ${ENV_DESTINATION_PATH}/overrides
    || true
  - if [ ! -f ${ENV_DESTINATION_PATH}/appconfig.json ]; then cp ../mono_repo/services/schema/main_appconfig.json
    ${ENV_DESTINATION_PATH}/appconfig.json; fi
  - git status
  - echo "Adding changes to Git"
  - git add ${DESTINATION_PATH}
  - git status
  - COUNT=$(git diff --numstat ${STATE_BRANCH} | awk '{added += $1; deleted += $2}
    END {print added + deleted}')
  - |
    if [ "$COUNT" -eq 0 ]; then
      echo "No changes detected under ${CI_PROJECT_NAME}/${SOURCE_PATH}, exiting"
      exit 0
    fi
  - echo "Committing changes"
  - git commit -m "${CI_JOB_NAME}"
  - echo "Pushing changes to remote"
  - git pull --rebase
  - git status
  - "MAX_RETRIES=3\nINITIAL_DELAY=5\nsuccess=false\n\nfor attempt in $(seq 1 $MAX_RETRIES);
    do\n  if git push; then\n    echo -e \"\\e[32mPush successful\\e[0m\"\n    success=true\n
    \   break\n  else\n    echo -e \"\\e[33mPush failed, retrying ($attempt/$MAX_RETRIES)...\\e[0m\"\n
    \   git pull --rebase\n    \n    # Calculate backoff delay (5s, then 10s, then
    20s)\n    BACKOFF_DELAY=$((INITIAL_DELAY * 2**(attempt-1)))\n    echo \"Waiting
    ${BACKOFF_DELAY} seconds before next attempt...\"\n    sleep $BACKOFF_DELAY\n
    \ fi\ndone\n\nif [ \"$success\" != \"true\" ]; then\n  echo -e \"\\e[31mFailed
    to push after $MAX_RETRIES attempts\\e[0m\"\n  exit 1\nfi\n"
  - git status
  - echo "Resources published to argocd mono repo"
  variables:
    DESTINATION_REPO: https://gitlab.com/fireblocks/devops/iac/argocd.git
    DESTINATION_PROJECT_ID: 50521873
    SOURCE_PATH: deployment
    DESTINATION_PATH: services/shell
    STATE_BRANCH: main
    GITLAB_API_URL: https://gitlab.com/api/v4/projects
    TEMPLATE_REF: "$TEMPLATE_REF"
    GITLAB_RUNNER_TAG: devx-application-gitlab-runner
    ENV: dev15
  extends: ".publish_resources_dev"
".publish_resources_prod-us":
  stage: configure
  retry:
    max: 2
    when:
    - script_failure
  tags:
  - "${GITLAB_RUNNER_TAG}"
  before_script:
  - printf "%s:%s\n" DESTINATION_REPO "$DESTINATION_REPO" DESTINATION_PROJECT_ID "$DESTINATION_PROJECT_ID"
    SOURCE_PATH "$SOURCE_PATH" DESTINATION_PATH "$DESTINATION_PATH" STATE_BRANCH "$STATE_BRANCH"
    GITLAB_API_URL "$GITLAB_API_URL"
  - |
    if [ ! -d "$SOURCE_PATH" ]; then
      echo "$SOURCE_PATH directory does not exist. Exiting job successfully."
      exit 0
    fi
    echo "$SOURCE_PATH directory exists. Continuing with deployment."
  - - apk update
    - apk add curl jq yq py3-pip
    - pip3 install --upgrade pip
    - pip3 install yamllint
    - pip3 install yamale --break-system-packages
    - npm install -g ajv-cli
    - echo "Configuring Git"
    - echo "https://argocd-ci-push:${ARGOCD_GITLAB_ACCESS_TOKEN}@gitlab.com" > ~/.git-credentials
    - git remote set-url origin https://argocd-ci-push:${ARGOCD_GITLAB_ACCESS_TOKEN}@gitlab.com/fireblocks/devops/iac/argocd.git
    - git config --global user.email "devops@fireblocks.com"
    - git config --global user.name "argocd-ci-push"
    - git config --global credential.helper store
    - touch .npmrc
    - npm config set --location=user @fireblocks:registry https://gitlab.com/api/v4/packages/npm/
    - npm config set --location=user '//gitlab.com/api/v4/packages/npm/:_authToken'
      "${NPM_REG_TOKEN}"
    - npm config set --location=user '//gitlab.com/api/v4/projects/20565764/packages/npm/:_authToken'
      "${NPM_REG_TOKEN}"
    - echo "@fireblocks:registry=https://gitlab.com/api/v4/packages/npm/">>.npmrc
    - echo "//gitlab.com/api/v4/packages/npm/:_authToken=${NPM_REG_TOKEN}">>.npmrc
    - echo "//gitlab.com/api/v4/projects/20565764/packages/npm/:_authToken=${NPM_REG_TOKEN}">>.npmrc
    - yarn global add @fireblocks/fb-cli
  script:
  - - echo "Self Service User Guide - https://fireblocks.atlassian.net/wiki/spaces/RD/pages/1413218873/Self+Service+User+Guide"
    - SVC_NAME=$([ "$SERVICE_NAME" ] && echo $SERVICE_NAME || echo $CI_PROJECT_NAME)
    - echo "Verifying deployment folder for ${SVC_NAME} service"
    - git clone ${DESTINATION_REPO} mono_repo
    - cd mono_repo
    - git fetch --all
    - git checkout ${STATE_BRANCH}
    - git pull origin ${STATE_BRANCH} --no-rebase
    - cd ../${SOURCE_PATH}
    - |
      # Define the paths
      values_file="values.yaml"

      # Check for values.yaml in the deployment folder
      if [ ! -f "$values_file" ]; then
          echo "Error: The values.yaml file is missing in the ${SOURCE_PATH} folder."
          exit 1
      fi

      echo "Success: All required files are present"
    - |
      # Directory to check
      DIR_TO_CHECK="overrides/"

      # List of allowed files
      ALLOWED_PATTERN=$(printf "|%s" "nonprod-tier.yaml" "prod-tier.yaml" "iac-dev.yaml" "localstack.yaml" "dev1.yaml" "dev2.yaml" "dev3.yaml" "dev4.yaml" "dev5.yaml" "dev6.yaml" "dev7.yaml" "dev8.yaml" "dev9.yaml" "dev10.yaml" "dev11.yaml" "dev11.yaml" "dev12.yaml" "dev13.yaml" "dev14.yaml" "dev15.yaml" "pre1.yaml" "stage.yaml" "sandbox.yaml" "eu-prod.yaml" "eu2-prod.yaml" "bnym-dev.yaml" "bnym-prod.yaml" "us-prod.yaml" | cut -c 2-)

      # Flag to track if there are disallowed files
      DISALLOWED_FOUND=false

      # Check for files in the directory that are not in the allowed list
      for file in "$DIR_TO_CHECK"/*; do
        # Get the base name of the file
        filename=$(basename "$file")

        # Check if the filename is in the allowed list
        if [[ ! $filename =~ ^($ALLOWED_PATTERN)$ ]]; then
          echo "Disallowed file found: $filename"
          DISALLOWED_FOUND=true
        fi
      done

      # Final output
      if $DISALLOWED_FOUND; then
        echo "Some files are not allowed."
        exit 1
      else
        echo "All files are allowed."
      fi
    - echo "Linting deployment yaml files"
    - cp ../mono_repo/services/schema/*.yaml .
    - cp ../mono_repo/services/schema/appconfig_schema.json .
    - cp ../mono_repo/services/schema/main_appconfig.json appconfig.json
    - cp ../mono_repo/services/schema/yamllint_rules.yaml yamllint_rules.yaml
    - yamllint --list-files **/*.yaml *.yaml
    - yamllint -s **/*.yaml *.yaml -c yamllint_rules.yaml
    - echo "Validating deployment yaml schema"
    - yamale -s base_values_schema.yaml values.yaml
    - yamale -s tier_values_schema.yaml overrides/prod-tier.yaml
    - yamale -s tier_values_schema.yaml overrides/nonprod-tier.yaml
    - |
      # Iterate over all yaml files in the overrides folder
      for file in overrides/*.yaml; do
          # Extract the filename from the path
          filename=$(basename -- "$file")

          # Check if the file is not prod-tier.yaml or nonprod-tier.yaml
          if [[ "$filename" != "prod-tier.yaml" ]] && [[ "$filename" != "nonprod-tier.yaml" ]]; then
              # Run yamale command on the file
              yamale -s env_values_schema.yaml "$file"
          fi
      done
    - "# Iterate over all yaml files in the overrides folder - validate_resources.sh\nif
      [[ -v ENGINE && \"$ENGINE\" == \"argocd\" ]]; then\n  export CD_INFRA_PROJECT_ID=61508954\n
      \ curl --header \"PRIVATE-TOKEN: $CD_CPU_RAM_REQUEST_LIMIT_READ_ONLY\"  \"https://gitlab.com/api/v4/projects/$CD_INFRA_PROJECT_ID/repository/files/ci-infra%2Fscripts%2Fvalidate_resources.sh/raw?ref=main\"
      -o \"$CI_PROJECT_DIR/validate_resources.sh\"\n  echo \"chmod +x $CI_PROJECT_DIR/validate_resources.sh\"
      \n  chmod +x \"$CI_PROJECT_DIR/validate_resources.sh\"\n  echo \"Searching for
      environments values files...\" \n  ENV_FILES_LIST=$(yamllint --list-files **/*.yaml
      *.yaml | grep -vE 'env_values_schema\\.yaml|tier_values_schema\\.yaml|base_values_schema\\.yaml|yamllint_rules\\.yaml|.*prod-tier\\.yaml|values.yaml'
      || true)\n  if [[ -n \"$ENV_FILES_LIST\" ]]; then\n    echo \"Found environments
      values files\"\n    while IFS= read -r file; do\n      filename=$(basename --
      \"$file\")\n      if [[ \"$filename\" =~ ^(dev[1-9]|dev10|stage|pre1).yaml$
      ]]; then\n        tier_file=\"overrides/nonprod-tier.yaml\"\n      else\n        tier_file=\"overrides/prod-tier.yaml\"
      \ \n      fi\n      echo \"values.yaml <-- $tier_file <-- $file\"\n      yq
      eval-all '. as $item ireduce ({}; . * $item)' values.yaml \"$tier_file\" \"$file\"
      | bash \"$CI_PROJECT_DIR/validate_resources.sh\" -\n    done <<< \"$ENV_FILES_LIST\"\n
      \ else\n    echo \"No environments values files were found. Continuing to the
      tier files.\"\n  fi\necho \"values.yaml <-- overrides/nonprod-tier.yaml\"\nyq
      eval-all '. as $item ireduce ({}; . * $item)' values.yaml overrides/nonprod-tier.yaml
      | bash \"$CI_PROJECT_DIR/validate_resources.sh\" -\necho \"values.yaml <-- overrides/prod-tier.yaml\"
      \nyq eval-all '. as $item ireduce ({}; . * $item)' values.yaml overrides/prod-tier.yaml
      | bash \"$CI_PROJECT_DIR/validate_resources.sh\" -\nelse\n  echo \"Skipping
      resource validation: ENGINE is not set to 'argocd'.\"\nfi\n"
    - ajv validate -s appconfig_schema.json -d appconfig.json
    - echo "Resources verified successfully"
    - echo "Validate filter_policy if exists - should be a valid JSON object"
    - fb deployment:validate . --filter-policy
  - cd ../mono_repo
  - ENV_DESTINATION_PATH=$(echo "${DESTINATION_PATH}/${SVC_NAME}/${ENV}")
  - echo "Copying ${SOURCE_PATH} folder from ${SVC_NAME} service to argocd mono repo
    destination folder at ${ENV_DESTINATION_PATH}"
  - mkdir -pv ${ENV_DESTINATION_PATH}/overrides
  - rm ${ENV_DESTINATION_PATH}/overrides/${ENV}.yaml || true
  - cp  ../${SOURCE_PATH}/values.yaml ${ENV_DESTINATION_PATH}
  - cp ../${SOURCE_PATH}/overrides/${ENV}.yaml  ${ENV_DESTINATION_PATH}/overrides
    || true
  - cp ../${SOURCE_PATH}/overrides/*-tier.yaml  ${ENV_DESTINATION_PATH}/overrides
    || true
  - if [ ! -f ${ENV_DESTINATION_PATH}/appconfig.json ]; then cp ../mono_repo/services/schema/main_appconfig.json
    ${ENV_DESTINATION_PATH}/appconfig.json; fi
  - git status
  - echo "Adding changes to Git"
  - git add ${DESTINATION_PATH}
  - git status
  - COUNT=$(git diff --numstat ${STATE_BRANCH} | awk '{added += $1; deleted += $2}
    END {print added + deleted}')
  - |
    if [ "$COUNT" -eq 0 ]; then
      echo "No changes detected under ${CI_PROJECT_NAME}/${SOURCE_PATH}, exiting"
      exit 0
    fi
  - echo "Committing changes"
  - git commit -m "${CI_JOB_NAME}"
  - echo "Pushing changes to remote"
  - git pull --rebase
  - git status
  - "MAX_RETRIES=3\nINITIAL_DELAY=5\nsuccess=false\n\nfor attempt in $(seq 1 $MAX_RETRIES);
    do\n  if git push; then\n    echo -e \"\\e[32mPush successful\\e[0m\"\n    success=true\n
    \   break\n  else\n    echo -e \"\\e[33mPush failed, retrying ($attempt/$MAX_RETRIES)...\\e[0m\"\n
    \   git pull --rebase\n    \n    # Calculate backoff delay (5s, then 10s, then
    20s)\n    BACKOFF_DELAY=$((INITIAL_DELAY * 2**(attempt-1)))\n    echo \"Waiting
    ${BACKOFF_DELAY} seconds before next attempt...\"\n    sleep $BACKOFF_DELAY\n
    \ fi\ndone\n\nif [ \"$success\" != \"true\" ]; then\n  echo -e \"\\e[31mFailed
    to push after $MAX_RETRIES attempts\\e[0m\"\n  exit 1\nfi\n"
  - git status
  - echo "Resources published to argocd mono repo"
  variables:
    DESTINATION_REPO: https://gitlab.com/fireblocks/devops/iac/argocd.git
    DESTINATION_PROJECT_ID: 50521873
    SOURCE_PATH: deployment
    DESTINATION_PATH: services/shell
    STATE_BRANCH: main
    GITLAB_API_URL: https://gitlab.com/api/v4/projects
    TEMPLATE_REF: "$TEMPLATE_REF"
    GITLAB_RUNNER_TAG: us-prod-application-gitlab-runner
    ENV: us-prod
  extends: ".publish_resources_prod"
".publish_resources_sandbox":
  stage: configure
  retry:
    max: 2
    when:
    - script_failure
  tags:
  - "${GITLAB_RUNNER_TAG}"
  before_script:
  - printf "%s:%s\n" DESTINATION_REPO "$DESTINATION_REPO" DESTINATION_PROJECT_ID "$DESTINATION_PROJECT_ID"
    SOURCE_PATH "$SOURCE_PATH" DESTINATION_PATH "$DESTINATION_PATH" STATE_BRANCH "$STATE_BRANCH"
    GITLAB_API_URL "$GITLAB_API_URL"
  - |
    if [ ! -d "$SOURCE_PATH" ]; then
      echo "$SOURCE_PATH directory does not exist. Exiting job successfully."
      exit 0
    fi
    echo "$SOURCE_PATH directory exists. Continuing with deployment."
  - - apk update
    - apk add curl jq yq py3-pip
    - pip3 install --upgrade pip
    - pip3 install yamllint
    - pip3 install yamale --break-system-packages
    - npm install -g ajv-cli
    - echo "Configuring Git"
    - echo "https://argocd-ci-push:${ARGOCD_GITLAB_ACCESS_TOKEN}@gitlab.com" > ~/.git-credentials
    - git remote set-url origin https://argocd-ci-push:${ARGOCD_GITLAB_ACCESS_TOKEN}@gitlab.com/fireblocks/devops/iac/argocd.git
    - git config --global user.email "devops@fireblocks.com"
    - git config --global user.name "argocd-ci-push"
    - git config --global credential.helper store
    - touch .npmrc
    - npm config set --location=user @fireblocks:registry https://gitlab.com/api/v4/packages/npm/
    - npm config set --location=user '//gitlab.com/api/v4/packages/npm/:_authToken'
      "${NPM_REG_TOKEN}"
    - npm config set --location=user '//gitlab.com/api/v4/projects/20565764/packages/npm/:_authToken'
      "${NPM_REG_TOKEN}"
    - echo "@fireblocks:registry=https://gitlab.com/api/v4/packages/npm/">>.npmrc
    - echo "//gitlab.com/api/v4/packages/npm/:_authToken=${NPM_REG_TOKEN}">>.npmrc
    - echo "//gitlab.com/api/v4/projects/20565764/packages/npm/:_authToken=${NPM_REG_TOKEN}">>.npmrc
    - yarn global add @fireblocks/fb-cli
  script:
  - - echo "Self Service User Guide - https://fireblocks.atlassian.net/wiki/spaces/RD/pages/1413218873/Self+Service+User+Guide"
    - SVC_NAME=$([ "$SERVICE_NAME" ] && echo $SERVICE_NAME || echo $CI_PROJECT_NAME)
    - echo "Verifying deployment folder for ${SVC_NAME} service"
    - git clone ${DESTINATION_REPO} mono_repo
    - cd mono_repo
    - git fetch --all
    - git checkout ${STATE_BRANCH}
    - git pull origin ${STATE_BRANCH} --no-rebase
    - cd ../${SOURCE_PATH}
    - |
      # Define the paths
      values_file="values.yaml"

      # Check for values.yaml in the deployment folder
      if [ ! -f "$values_file" ]; then
          echo "Error: The values.yaml file is missing in the ${SOURCE_PATH} folder."
          exit 1
      fi

      echo "Success: All required files are present"
    - |
      # Directory to check
      DIR_TO_CHECK="overrides/"

      # List of allowed files
      ALLOWED_PATTERN=$(printf "|%s" "nonprod-tier.yaml" "prod-tier.yaml" "iac-dev.yaml" "localstack.yaml" "dev1.yaml" "dev2.yaml" "dev3.yaml" "dev4.yaml" "dev5.yaml" "dev6.yaml" "dev7.yaml" "dev8.yaml" "dev9.yaml" "dev10.yaml" "dev11.yaml" "dev11.yaml" "dev12.yaml" "dev13.yaml" "dev14.yaml" "dev15.yaml" "pre1.yaml" "stage.yaml" "sandbox.yaml" "eu-prod.yaml" "eu2-prod.yaml" "bnym-dev.yaml" "bnym-prod.yaml" "us-prod.yaml" | cut -c 2-)

      # Flag to track if there are disallowed files
      DISALLOWED_FOUND=false

      # Check for files in the directory that are not in the allowed list
      for file in "$DIR_TO_CHECK"/*; do
        # Get the base name of the file
        filename=$(basename "$file")

        # Check if the filename is in the allowed list
        if [[ ! $filename =~ ^($ALLOWED_PATTERN)$ ]]; then
          echo "Disallowed file found: $filename"
          DISALLOWED_FOUND=true
        fi
      done

      # Final output
      if $DISALLOWED_FOUND; then
        echo "Some files are not allowed."
        exit 1
      else
        echo "All files are allowed."
      fi
    - echo "Linting deployment yaml files"
    - cp ../mono_repo/services/schema/*.yaml .
    - cp ../mono_repo/services/schema/appconfig_schema.json .
    - cp ../mono_repo/services/schema/main_appconfig.json appconfig.json
    - cp ../mono_repo/services/schema/yamllint_rules.yaml yamllint_rules.yaml
    - yamllint --list-files **/*.yaml *.yaml
    - yamllint -s **/*.yaml *.yaml -c yamllint_rules.yaml
    - echo "Validating deployment yaml schema"
    - yamale -s base_values_schema.yaml values.yaml
    - yamale -s tier_values_schema.yaml overrides/prod-tier.yaml
    - yamale -s tier_values_schema.yaml overrides/nonprod-tier.yaml
    - |
      # Iterate over all yaml files in the overrides folder
      for file in overrides/*.yaml; do
          # Extract the filename from the path
          filename=$(basename -- "$file")

          # Check if the file is not prod-tier.yaml or nonprod-tier.yaml
          if [[ "$filename" != "prod-tier.yaml" ]] && [[ "$filename" != "nonprod-tier.yaml" ]]; then
              # Run yamale command on the file
              yamale -s env_values_schema.yaml "$file"
          fi
      done
    - "# Iterate over all yaml files in the overrides folder - validate_resources.sh\nif
      [[ -v ENGINE && \"$ENGINE\" == \"argocd\" ]]; then\n  export CD_INFRA_PROJECT_ID=61508954\n
      \ curl --header \"PRIVATE-TOKEN: $CD_CPU_RAM_REQUEST_LIMIT_READ_ONLY\"  \"https://gitlab.com/api/v4/projects/$CD_INFRA_PROJECT_ID/repository/files/ci-infra%2Fscripts%2Fvalidate_resources.sh/raw?ref=main\"
      -o \"$CI_PROJECT_DIR/validate_resources.sh\"\n  echo \"chmod +x $CI_PROJECT_DIR/validate_resources.sh\"
      \n  chmod +x \"$CI_PROJECT_DIR/validate_resources.sh\"\n  echo \"Searching for
      environments values files...\" \n  ENV_FILES_LIST=$(yamllint --list-files **/*.yaml
      *.yaml | grep -vE 'env_values_schema\\.yaml|tier_values_schema\\.yaml|base_values_schema\\.yaml|yamllint_rules\\.yaml|.*prod-tier\\.yaml|values.yaml'
      || true)\n  if [[ -n \"$ENV_FILES_LIST\" ]]; then\n    echo \"Found environments
      values files\"\n    while IFS= read -r file; do\n      filename=$(basename --
      \"$file\")\n      if [[ \"$filename\" =~ ^(dev[1-9]|dev10|stage|pre1).yaml$
      ]]; then\n        tier_file=\"overrides/nonprod-tier.yaml\"\n      else\n        tier_file=\"overrides/prod-tier.yaml\"
      \ \n      fi\n      echo \"values.yaml <-- $tier_file <-- $file\"\n      yq
      eval-all '. as $item ireduce ({}; . * $item)' values.yaml \"$tier_file\" \"$file\"
      | bash \"$CI_PROJECT_DIR/validate_resources.sh\" -\n    done <<< \"$ENV_FILES_LIST\"\n
      \ else\n    echo \"No environments values files were found. Continuing to the
      tier files.\"\n  fi\necho \"values.yaml <-- overrides/nonprod-tier.yaml\"\nyq
      eval-all '. as $item ireduce ({}; . * $item)' values.yaml overrides/nonprod-tier.yaml
      | bash \"$CI_PROJECT_DIR/validate_resources.sh\" -\necho \"values.yaml <-- overrides/prod-tier.yaml\"
      \nyq eval-all '. as $item ireduce ({}; . * $item)' values.yaml overrides/prod-tier.yaml
      | bash \"$CI_PROJECT_DIR/validate_resources.sh\" -\nelse\n  echo \"Skipping
      resource validation: ENGINE is not set to 'argocd'.\"\nfi\n"
    - ajv validate -s appconfig_schema.json -d appconfig.json
    - echo "Resources verified successfully"
    - echo "Validate filter_policy if exists - should be a valid JSON object"
    - fb deployment:validate . --filter-policy
  - cd ../mono_repo
  - ENV_DESTINATION_PATH=$(echo "${DESTINATION_PATH}/${SVC_NAME}/${ENV}")
  - echo "Copying ${SOURCE_PATH} folder from ${SVC_NAME} service to argocd mono repo
    destination folder at ${ENV_DESTINATION_PATH}"
  - mkdir -pv ${ENV_DESTINATION_PATH}/overrides
  - rm ${ENV_DESTINATION_PATH}/overrides/${ENV}.yaml || true
  - cp  ../${SOURCE_PATH}/values.yaml ${ENV_DESTINATION_PATH}
  - cp ../${SOURCE_PATH}/overrides/${ENV}.yaml  ${ENV_DESTINATION_PATH}/overrides
    || true
  - cp ../${SOURCE_PATH}/overrides/*-tier.yaml  ${ENV_DESTINATION_PATH}/overrides
    || true
  - if [ ! -f ${ENV_DESTINATION_PATH}/appconfig.json ]; then cp ../mono_repo/services/schema/main_appconfig.json
    ${ENV_DESTINATION_PATH}/appconfig.json; fi
  - git status
  - echo "Adding changes to Git"
  - git add ${DESTINATION_PATH}
  - git status
  - COUNT=$(git diff --numstat ${STATE_BRANCH} | awk '{added += $1; deleted += $2}
    END {print added + deleted}')
  - |
    if [ "$COUNT" -eq 0 ]; then
      echo "No changes detected under ${CI_PROJECT_NAME}/${SOURCE_PATH}, exiting"
      exit 0
    fi
  - echo "Committing changes"
  - git commit -m "${CI_JOB_NAME}"
  - echo "Pushing changes to remote"
  - git pull --rebase
  - git status
  - "MAX_RETRIES=3\nINITIAL_DELAY=5\nsuccess=false\n\nfor attempt in $(seq 1 $MAX_RETRIES);
    do\n  if git push; then\n    echo -e \"\\e[32mPush successful\\e[0m\"\n    success=true\n
    \   break\n  else\n    echo -e \"\\e[33mPush failed, retrying ($attempt/$MAX_RETRIES)...\\e[0m\"\n
    \   git pull --rebase\n    \n    # Calculate backoff delay (5s, then 10s, then
    20s)\n    BACKOFF_DELAY=$((INITIAL_DELAY * 2**(attempt-1)))\n    echo \"Waiting
    ${BACKOFF_DELAY} seconds before next attempt...\"\n    sleep $BACKOFF_DELAY\n
    \ fi\ndone\n\nif [ \"$success\" != \"true\" ]; then\n  echo -e \"\\e[31mFailed
    to push after $MAX_RETRIES attempts\\e[0m\"\n  exit 1\nfi\n"
  - git status
  - echo "Resources published to argocd mono repo"
  variables:
    DESTINATION_REPO: https://gitlab.com/fireblocks/devops/iac/argocd.git
    DESTINATION_PROJECT_ID: 50521873
    SOURCE_PATH: deployment
    DESTINATION_PATH: services/shell
    STATE_BRANCH: main
    GITLAB_API_URL: https://gitlab.com/api/v4/projects
    TEMPLATE_REF: "$TEMPLATE_REF"
    GITLAB_RUNNER_TAG: sandbox-application-gitlab-runner
    ENV: sandbox
  extends: ".publish_resources_prod"
".publish_resources_eu-prod-fr":
  stage: configure
  retry:
    max: 2
    when:
    - script_failure
  tags:
  - "${GITLAB_RUNNER_TAG}"
  before_script:
  - printf "%s:%s\n" DESTINATION_REPO "$DESTINATION_REPO" DESTINATION_PROJECT_ID "$DESTINATION_PROJECT_ID"
    SOURCE_PATH "$SOURCE_PATH" DESTINATION_PATH "$DESTINATION_PATH" STATE_BRANCH "$STATE_BRANCH"
    GITLAB_API_URL "$GITLAB_API_URL"
  - |
    if [ ! -d "$SOURCE_PATH" ]; then
      echo "$SOURCE_PATH directory does not exist. Exiting job successfully."
      exit 0
    fi
    echo "$SOURCE_PATH directory exists. Continuing with deployment."
  - - apk update
    - apk add curl jq yq py3-pip
    - pip3 install --upgrade pip
    - pip3 install yamllint
    - pip3 install yamale --break-system-packages
    - npm install -g ajv-cli
    - echo "Configuring Git"
    - echo "https://argocd-ci-push:${ARGOCD_GITLAB_ACCESS_TOKEN}@gitlab.com" > ~/.git-credentials
    - git remote set-url origin https://argocd-ci-push:${ARGOCD_GITLAB_ACCESS_TOKEN}@gitlab.com/fireblocks/devops/iac/argocd.git
    - git config --global user.email "devops@fireblocks.com"
    - git config --global user.name "argocd-ci-push"
    - git config --global credential.helper store
    - touch .npmrc
    - npm config set --location=user @fireblocks:registry https://gitlab.com/api/v4/packages/npm/
    - npm config set --location=user '//gitlab.com/api/v4/packages/npm/:_authToken'
      "${NPM_REG_TOKEN}"
    - npm config set --location=user '//gitlab.com/api/v4/projects/20565764/packages/npm/:_authToken'
      "${NPM_REG_TOKEN}"
    - echo "@fireblocks:registry=https://gitlab.com/api/v4/packages/npm/">>.npmrc
    - echo "//gitlab.com/api/v4/packages/npm/:_authToken=${NPM_REG_TOKEN}">>.npmrc
    - echo "//gitlab.com/api/v4/projects/20565764/packages/npm/:_authToken=${NPM_REG_TOKEN}">>.npmrc
    - yarn global add @fireblocks/fb-cli
  script:
  - - echo "Self Service User Guide - https://fireblocks.atlassian.net/wiki/spaces/RD/pages/1413218873/Self+Service+User+Guide"
    - SVC_NAME=$([ "$SERVICE_NAME" ] && echo $SERVICE_NAME || echo $CI_PROJECT_NAME)
    - echo "Verifying deployment folder for ${SVC_NAME} service"
    - git clone ${DESTINATION_REPO} mono_repo
    - cd mono_repo
    - git fetch --all
    - git checkout ${STATE_BRANCH}
    - git pull origin ${STATE_BRANCH} --no-rebase
    - cd ../${SOURCE_PATH}
    - |
      # Define the paths
      values_file="values.yaml"

      # Check for values.yaml in the deployment folder
      if [ ! -f "$values_file" ]; then
          echo "Error: The values.yaml file is missing in the ${SOURCE_PATH} folder."
          exit 1
      fi

      echo "Success: All required files are present"
    - |
      # Directory to check
      DIR_TO_CHECK="overrides/"

      # List of allowed files
      ALLOWED_PATTERN=$(printf "|%s" "nonprod-tier.yaml" "prod-tier.yaml" "iac-dev.yaml" "localstack.yaml" "dev1.yaml" "dev2.yaml" "dev3.yaml" "dev4.yaml" "dev5.yaml" "dev6.yaml" "dev7.yaml" "dev8.yaml" "dev9.yaml" "dev10.yaml" "dev11.yaml" "dev11.yaml" "dev12.yaml" "dev13.yaml" "dev14.yaml" "dev15.yaml" "pre1.yaml" "stage.yaml" "sandbox.yaml" "eu-prod.yaml" "eu2-prod.yaml" "bnym-dev.yaml" "bnym-prod.yaml" "us-prod.yaml" | cut -c 2-)

      # Flag to track if there are disallowed files
      DISALLOWED_FOUND=false

      # Check for files in the directory that are not in the allowed list
      for file in "$DIR_TO_CHECK"/*; do
        # Get the base name of the file
        filename=$(basename "$file")

        # Check if the filename is in the allowed list
        if [[ ! $filename =~ ^($ALLOWED_PATTERN)$ ]]; then
          echo "Disallowed file found: $filename"
          DISALLOWED_FOUND=true
        fi
      done

      # Final output
      if $DISALLOWED_FOUND; then
        echo "Some files are not allowed."
        exit 1
      else
        echo "All files are allowed."
      fi
    - echo "Linting deployment yaml files"
    - cp ../mono_repo/services/schema/*.yaml .
    - cp ../mono_repo/services/schema/appconfig_schema.json .
    - cp ../mono_repo/services/schema/main_appconfig.json appconfig.json
    - cp ../mono_repo/services/schema/yamllint_rules.yaml yamllint_rules.yaml
    - yamllint --list-files **/*.yaml *.yaml
    - yamllint -s **/*.yaml *.yaml -c yamllint_rules.yaml
    - echo "Validating deployment yaml schema"
    - yamale -s base_values_schema.yaml values.yaml
    - yamale -s tier_values_schema.yaml overrides/prod-tier.yaml
    - yamale -s tier_values_schema.yaml overrides/nonprod-tier.yaml
    - |
      # Iterate over all yaml files in the overrides folder
      for file in overrides/*.yaml; do
          # Extract the filename from the path
          filename=$(basename -- "$file")

          # Check if the file is not prod-tier.yaml or nonprod-tier.yaml
          if [[ "$filename" != "prod-tier.yaml" ]] && [[ "$filename" != "nonprod-tier.yaml" ]]; then
              # Run yamale command on the file
              yamale -s env_values_schema.yaml "$file"
          fi
      done
    - "# Iterate over all yaml files in the overrides folder - validate_resources.sh\nif
      [[ -v ENGINE && \"$ENGINE\" == \"argocd\" ]]; then\n  export CD_INFRA_PROJECT_ID=61508954\n
      \ curl --header \"PRIVATE-TOKEN: $CD_CPU_RAM_REQUEST_LIMIT_READ_ONLY\"  \"https://gitlab.com/api/v4/projects/$CD_INFRA_PROJECT_ID/repository/files/ci-infra%2Fscripts%2Fvalidate_resources.sh/raw?ref=main\"
      -o \"$CI_PROJECT_DIR/validate_resources.sh\"\n  echo \"chmod +x $CI_PROJECT_DIR/validate_resources.sh\"
      \n  chmod +x \"$CI_PROJECT_DIR/validate_resources.sh\"\n  echo \"Searching for
      environments values files...\" \n  ENV_FILES_LIST=$(yamllint --list-files **/*.yaml
      *.yaml | grep -vE 'env_values_schema\\.yaml|tier_values_schema\\.yaml|base_values_schema\\.yaml|yamllint_rules\\.yaml|.*prod-tier\\.yaml|values.yaml'
      || true)\n  if [[ -n \"$ENV_FILES_LIST\" ]]; then\n    echo \"Found environments
      values files\"\n    while IFS= read -r file; do\n      filename=$(basename --
      \"$file\")\n      if [[ \"$filename\" =~ ^(dev[1-9]|dev10|stage|pre1).yaml$
      ]]; then\n        tier_file=\"overrides/nonprod-tier.yaml\"\n      else\n        tier_file=\"overrides/prod-tier.yaml\"
      \ \n      fi\n      echo \"values.yaml <-- $tier_file <-- $file\"\n      yq
      eval-all '. as $item ireduce ({}; . * $item)' values.yaml \"$tier_file\" \"$file\"
      | bash \"$CI_PROJECT_DIR/validate_resources.sh\" -\n    done <<< \"$ENV_FILES_LIST\"\n
      \ else\n    echo \"No environments values files were found. Continuing to the
      tier files.\"\n  fi\necho \"values.yaml <-- overrides/nonprod-tier.yaml\"\nyq
      eval-all '. as $item ireduce ({}; . * $item)' values.yaml overrides/nonprod-tier.yaml
      | bash \"$CI_PROJECT_DIR/validate_resources.sh\" -\necho \"values.yaml <-- overrides/prod-tier.yaml\"
      \nyq eval-all '. as $item ireduce ({}; . * $item)' values.yaml overrides/prod-tier.yaml
      | bash \"$CI_PROJECT_DIR/validate_resources.sh\" -\nelse\n  echo \"Skipping
      resource validation: ENGINE is not set to 'argocd'.\"\nfi\n"
    - ajv validate -s appconfig_schema.json -d appconfig.json
    - echo "Resources verified successfully"
    - echo "Validate filter_policy if exists - should be a valid JSON object"
    - fb deployment:validate . --filter-policy
  - cd ../mono_repo
  - ENV_DESTINATION_PATH=$(echo "${DESTINATION_PATH}/${SVC_NAME}/${ENV}")
  - echo "Copying ${SOURCE_PATH} folder from ${SVC_NAME} service to argocd mono repo
    destination folder at ${ENV_DESTINATION_PATH}"
  - mkdir -pv ${ENV_DESTINATION_PATH}/overrides
  - rm ${ENV_DESTINATION_PATH}/overrides/${ENV}.yaml || true
  - cp  ../${SOURCE_PATH}/values.yaml ${ENV_DESTINATION_PATH}
  - cp ../${SOURCE_PATH}/overrides/${ENV}.yaml  ${ENV_DESTINATION_PATH}/overrides
    || true
  - cp ../${SOURCE_PATH}/overrides/*-tier.yaml  ${ENV_DESTINATION_PATH}/overrides
    || true
  - if [ ! -f ${ENV_DESTINATION_PATH}/appconfig.json ]; then cp ../mono_repo/services/schema/main_appconfig.json
    ${ENV_DESTINATION_PATH}/appconfig.json; fi
  - git status
  - echo "Adding changes to Git"
  - git add ${DESTINATION_PATH}
  - git status
  - COUNT=$(git diff --numstat ${STATE_BRANCH} | awk '{added += $1; deleted += $2}
    END {print added + deleted}')
  - |
    if [ "$COUNT" -eq 0 ]; then
      echo "No changes detected under ${CI_PROJECT_NAME}/${SOURCE_PATH}, exiting"
      exit 0
    fi
  - echo "Committing changes"
  - git commit -m "${CI_JOB_NAME}"
  - echo "Pushing changes to remote"
  - git pull --rebase
  - git status
  - "MAX_RETRIES=3\nINITIAL_DELAY=5\nsuccess=false\n\nfor attempt in $(seq 1 $MAX_RETRIES);
    do\n  if git push; then\n    echo -e \"\\e[32mPush successful\\e[0m\"\n    success=true\n
    \   break\n  else\n    echo -e \"\\e[33mPush failed, retrying ($attempt/$MAX_RETRIES)...\\e[0m\"\n
    \   git pull --rebase\n    \n    # Calculate backoff delay (5s, then 10s, then
    20s)\n    BACKOFF_DELAY=$((INITIAL_DELAY * 2**(attempt-1)))\n    echo \"Waiting
    ${BACKOFF_DELAY} seconds before next attempt...\"\n    sleep $BACKOFF_DELAY\n
    \ fi\ndone\n\nif [ \"$success\" != \"true\" ]; then\n  echo -e \"\\e[31mFailed
    to push after $MAX_RETRIES attempts\\e[0m\"\n  exit 1\nfi\n"
  - git status
  - echo "Resources published to argocd mono repo"
  variables:
    DESTINATION_REPO: https://gitlab.com/fireblocks/devops/iac/argocd.git
    DESTINATION_PROJECT_ID: 50521873
    SOURCE_PATH: deployment
    DESTINATION_PATH: services/shell
    STATE_BRANCH: main
    GITLAB_API_URL: https://gitlab.com/api/v4/projects
    TEMPLATE_REF: "$TEMPLATE_REF"
    GITLAB_RUNNER_TAG: eu-prod-fr-application-gitlab-runner
    ENV: eu-prod
  extends: ".publish_resources_prod"
".publish_resources_eu2-prod-fr":
  stage: configure
  retry:
    max: 2
    when:
    - script_failure
  tags:
  - "${GITLAB_RUNNER_TAG}"
  before_script:
  - printf "%s:%s\n" DESTINATION_REPO "$DESTINATION_REPO" DESTINATION_PROJECT_ID "$DESTINATION_PROJECT_ID"
    SOURCE_PATH "$SOURCE_PATH" DESTINATION_PATH "$DESTINATION_PATH" STATE_BRANCH "$STATE_BRANCH"
    GITLAB_API_URL "$GITLAB_API_URL"
  - |
    if [ ! -d "$SOURCE_PATH" ]; then
      echo "$SOURCE_PATH directory does not exist. Exiting job successfully."
      exit 0
    fi
    echo "$SOURCE_PATH directory exists. Continuing with deployment."
  - - apk update
    - apk add curl jq yq py3-pip
    - pip3 install --upgrade pip
    - pip3 install yamllint
    - pip3 install yamale --break-system-packages
    - npm install -g ajv-cli
    - echo "Configuring Git"
    - echo "https://argocd-ci-push:${ARGOCD_GITLAB_ACCESS_TOKEN}@gitlab.com" > ~/.git-credentials
    - git remote set-url origin https://argocd-ci-push:${ARGOCD_GITLAB_ACCESS_TOKEN}@gitlab.com/fireblocks/devops/iac/argocd.git
    - git config --global user.email "devops@fireblocks.com"
    - git config --global user.name "argocd-ci-push"
    - git config --global credential.helper store
    - touch .npmrc
    - npm config set --location=user @fireblocks:registry https://gitlab.com/api/v4/packages/npm/
    - npm config set --location=user '//gitlab.com/api/v4/packages/npm/:_authToken'
      "${NPM_REG_TOKEN}"
    - npm config set --location=user '//gitlab.com/api/v4/projects/20565764/packages/npm/:_authToken'
      "${NPM_REG_TOKEN}"
    - echo "@fireblocks:registry=https://gitlab.com/api/v4/packages/npm/">>.npmrc
    - echo "//gitlab.com/api/v4/packages/npm/:_authToken=${NPM_REG_TOKEN}">>.npmrc
    - echo "//gitlab.com/api/v4/projects/20565764/packages/npm/:_authToken=${NPM_REG_TOKEN}">>.npmrc
    - yarn global add @fireblocks/fb-cli
  script:
  - - echo "Self Service User Guide - https://fireblocks.atlassian.net/wiki/spaces/RD/pages/1413218873/Self+Service+User+Guide"
    - SVC_NAME=$([ "$SERVICE_NAME" ] && echo $SERVICE_NAME || echo $CI_PROJECT_NAME)
    - echo "Verifying deployment folder for ${SVC_NAME} service"
    - git clone ${DESTINATION_REPO} mono_repo
    - cd mono_repo
    - git fetch --all
    - git checkout ${STATE_BRANCH}
    - git pull origin ${STATE_BRANCH} --no-rebase
    - cd ../${SOURCE_PATH}
    - |
      # Define the paths
      values_file="values.yaml"

      # Check for values.yaml in the deployment folder
      if [ ! -f "$values_file" ]; then
          echo "Error: The values.yaml file is missing in the ${SOURCE_PATH} folder."
          exit 1
      fi

      echo "Success: All required files are present"
    - |
      # Directory to check
      DIR_TO_CHECK="overrides/"

      # List of allowed files
      ALLOWED_PATTERN=$(printf "|%s" "nonprod-tier.yaml" "prod-tier.yaml" "iac-dev.yaml" "localstack.yaml" "dev1.yaml" "dev2.yaml" "dev3.yaml" "dev4.yaml" "dev5.yaml" "dev6.yaml" "dev7.yaml" "dev8.yaml" "dev9.yaml" "dev10.yaml" "dev11.yaml" "dev11.yaml" "dev12.yaml" "dev13.yaml" "dev14.yaml" "dev15.yaml" "pre1.yaml" "stage.yaml" "sandbox.yaml" "eu-prod.yaml" "eu2-prod.yaml" "bnym-dev.yaml" "bnym-prod.yaml" "us-prod.yaml" | cut -c 2-)

      # Flag to track if there are disallowed files
      DISALLOWED_FOUND=false

      # Check for files in the directory that are not in the allowed list
      for file in "$DIR_TO_CHECK"/*; do
        # Get the base name of the file
        filename=$(basename "$file")

        # Check if the filename is in the allowed list
        if [[ ! $filename =~ ^($ALLOWED_PATTERN)$ ]]; then
          echo "Disallowed file found: $filename"
          DISALLOWED_FOUND=true
        fi
      done

      # Final output
      if $DISALLOWED_FOUND; then
        echo "Some files are not allowed."
        exit 1
      else
        echo "All files are allowed."
      fi
    - echo "Linting deployment yaml files"
    - cp ../mono_repo/services/schema/*.yaml .
    - cp ../mono_repo/services/schema/appconfig_schema.json .
    - cp ../mono_repo/services/schema/main_appconfig.json appconfig.json
    - cp ../mono_repo/services/schema/yamllint_rules.yaml yamllint_rules.yaml
    - yamllint --list-files **/*.yaml *.yaml
    - yamllint -s **/*.yaml *.yaml -c yamllint_rules.yaml
    - echo "Validating deployment yaml schema"
    - yamale -s base_values_schema.yaml values.yaml
    - yamale -s tier_values_schema.yaml overrides/prod-tier.yaml
    - yamale -s tier_values_schema.yaml overrides/nonprod-tier.yaml
    - |
      # Iterate over all yaml files in the overrides folder
      for file in overrides/*.yaml; do
          # Extract the filename from the path
          filename=$(basename -- "$file")

          # Check if the file is not prod-tier.yaml or nonprod-tier.yaml
          if [[ "$filename" != "prod-tier.yaml" ]] && [[ "$filename" != "nonprod-tier.yaml" ]]; then
              # Run yamale command on the file
              yamale -s env_values_schema.yaml "$file"
          fi
      done
    - "# Iterate over all yaml files in the overrides folder - validate_resources.sh\nif
      [[ -v ENGINE && \"$ENGINE\" == \"argocd\" ]]; then\n  export CD_INFRA_PROJECT_ID=61508954\n
      \ curl --header \"PRIVATE-TOKEN: $CD_CPU_RAM_REQUEST_LIMIT_READ_ONLY\"  \"https://gitlab.com/api/v4/projects/$CD_INFRA_PROJECT_ID/repository/files/ci-infra%2Fscripts%2Fvalidate_resources.sh/raw?ref=main\"
      -o \"$CI_PROJECT_DIR/validate_resources.sh\"\n  echo \"chmod +x $CI_PROJECT_DIR/validate_resources.sh\"
      \n  chmod +x \"$CI_PROJECT_DIR/validate_resources.sh\"\n  echo \"Searching for
      environments values files...\" \n  ENV_FILES_LIST=$(yamllint --list-files **/*.yaml
      *.yaml | grep -vE 'env_values_schema\\.yaml|tier_values_schema\\.yaml|base_values_schema\\.yaml|yamllint_rules\\.yaml|.*prod-tier\\.yaml|values.yaml'
      || true)\n  if [[ -n \"$ENV_FILES_LIST\" ]]; then\n    echo \"Found environments
      values files\"\n    while IFS= read -r file; do\n      filename=$(basename --
      \"$file\")\n      if [[ \"$filename\" =~ ^(dev[1-9]|dev10|stage|pre1).yaml$
      ]]; then\n        tier_file=\"overrides/nonprod-tier.yaml\"\n      else\n        tier_file=\"overrides/prod-tier.yaml\"
      \ \n      fi\n      echo \"values.yaml <-- $tier_file <-- $file\"\n      yq
      eval-all '. as $item ireduce ({}; . * $item)' values.yaml \"$tier_file\" \"$file\"
      | bash \"$CI_PROJECT_DIR/validate_resources.sh\" -\n    done <<< \"$ENV_FILES_LIST\"\n
      \ else\n    echo \"No environments values files were found. Continuing to the
      tier files.\"\n  fi\necho \"values.yaml <-- overrides/nonprod-tier.yaml\"\nyq
      eval-all '. as $item ireduce ({}; . * $item)' values.yaml overrides/nonprod-tier.yaml
      | bash \"$CI_PROJECT_DIR/validate_resources.sh\" -\necho \"values.yaml <-- overrides/prod-tier.yaml\"
      \nyq eval-all '. as $item ireduce ({}; . * $item)' values.yaml overrides/prod-tier.yaml
      | bash \"$CI_PROJECT_DIR/validate_resources.sh\" -\nelse\n  echo \"Skipping
      resource validation: ENGINE is not set to 'argocd'.\"\nfi\n"
    - ajv validate -s appconfig_schema.json -d appconfig.json
    - echo "Resources verified successfully"
    - echo "Validate filter_policy if exists - should be a valid JSON object"
    - fb deployment:validate . --filter-policy
  - cd ../mono_repo
  - ENV_DESTINATION_PATH=$(echo "${DESTINATION_PATH}/${SVC_NAME}/${ENV}")
  - echo "Copying ${SOURCE_PATH} folder from ${SVC_NAME} service to argocd mono repo
    destination folder at ${ENV_DESTINATION_PATH}"
  - mkdir -pv ${ENV_DESTINATION_PATH}/overrides
  - rm ${ENV_DESTINATION_PATH}/overrides/${ENV}.yaml || true
  - cp  ../${SOURCE_PATH}/values.yaml ${ENV_DESTINATION_PATH}
  - cp ../${SOURCE_PATH}/overrides/${ENV}.yaml  ${ENV_DESTINATION_PATH}/overrides
    || true
  - cp ../${SOURCE_PATH}/overrides/*-tier.yaml  ${ENV_DESTINATION_PATH}/overrides
    || true
  - if [ ! -f ${ENV_DESTINATION_PATH}/appconfig.json ]; then cp ../mono_repo/services/schema/main_appconfig.json
    ${ENV_DESTINATION_PATH}/appconfig.json; fi
  - git status
  - echo "Adding changes to Git"
  - git add ${DESTINATION_PATH}
  - git status
  - COUNT=$(git diff --numstat ${STATE_BRANCH} | awk '{added += $1; deleted += $2}
    END {print added + deleted}')
  - |
    if [ "$COUNT" -eq 0 ]; then
      echo "No changes detected under ${CI_PROJECT_NAME}/${SOURCE_PATH}, exiting"
      exit 0
    fi
  - echo "Committing changes"
  - git commit -m "${CI_JOB_NAME}"
  - echo "Pushing changes to remote"
  - git pull --rebase
  - git status
  - "MAX_RETRIES=3\nINITIAL_DELAY=5\nsuccess=false\n\nfor attempt in $(seq 1 $MAX_RETRIES);
    do\n  if git push; then\n    echo -e \"\\e[32mPush successful\\e[0m\"\n    success=true\n
    \   break\n  else\n    echo -e \"\\e[33mPush failed, retrying ($attempt/$MAX_RETRIES)...\\e[0m\"\n
    \   git pull --rebase\n    \n    # Calculate backoff delay (5s, then 10s, then
    20s)\n    BACKOFF_DELAY=$((INITIAL_DELAY * 2**(attempt-1)))\n    echo \"Waiting
    ${BACKOFF_DELAY} seconds before next attempt...\"\n    sleep $BACKOFF_DELAY\n
    \ fi\ndone\n\nif [ \"$success\" != \"true\" ]; then\n  echo -e \"\\e[31mFailed
    to push after $MAX_RETRIES attempts\\e[0m\"\n  exit 1\nfi\n"
  - git status
  - echo "Resources published to argocd mono repo"
  variables:
    DESTINATION_REPO: https://gitlab.com/fireblocks/devops/iac/argocd.git
    DESTINATION_PROJECT_ID: 50521873
    SOURCE_PATH: deployment
    DESTINATION_PATH: services/shell
    STATE_BRANCH: main
    GITLAB_API_URL: https://gitlab.com/api/v4/projects
    TEMPLATE_REF: "$TEMPLATE_REF"
    GITLAB_RUNNER_TAG: eu2-prod-fr-application-gitlab-runner
    ENV: eu2-prod
  extends: ".publish_resources_prod"
".publish_resources_bnym-dev":
  stage: configure
  retry:
    max: 2
    when:
    - script_failure
  tags:
  - "${GITLAB_RUNNER_TAG}"
  before_script:
  - printf "%s:%s\n" DESTINATION_REPO "$DESTINATION_REPO" DESTINATION_PROJECT_ID "$DESTINATION_PROJECT_ID"
    SOURCE_PATH "$SOURCE_PATH" DESTINATION_PATH "$DESTINATION_PATH" STATE_BRANCH "$STATE_BRANCH"
    GITLAB_API_URL "$GITLAB_API_URL"
  - |
    if [ ! -d "$SOURCE_PATH" ]; then
      echo "$SOURCE_PATH directory does not exist. Exiting job successfully."
      exit 0
    fi
    echo "$SOURCE_PATH directory exists. Continuing with deployment."
  - - apk update
    - apk add curl jq yq py3-pip
    - pip3 install --upgrade pip
    - pip3 install yamllint
    - pip3 install yamale --break-system-packages
    - npm install -g ajv-cli
    - echo "Configuring Git"
    - echo "https://argocd-ci-push:${ARGOCD_GITLAB_ACCESS_TOKEN}@gitlab.com" > ~/.git-credentials
    - git remote set-url origin https://argocd-ci-push:${ARGOCD_GITLAB_ACCESS_TOKEN}@gitlab.com/fireblocks/devops/iac/argocd.git
    - git config --global user.email "devops@fireblocks.com"
    - git config --global user.name "argocd-ci-push"
    - git config --global credential.helper store
    - touch .npmrc
    - npm config set --location=user @fireblocks:registry https://gitlab.com/api/v4/packages/npm/
    - npm config set --location=user '//gitlab.com/api/v4/packages/npm/:_authToken'
      "${NPM_REG_TOKEN}"
    - npm config set --location=user '//gitlab.com/api/v4/projects/20565764/packages/npm/:_authToken'
      "${NPM_REG_TOKEN}"
    - echo "@fireblocks:registry=https://gitlab.com/api/v4/packages/npm/">>.npmrc
    - echo "//gitlab.com/api/v4/packages/npm/:_authToken=${NPM_REG_TOKEN}">>.npmrc
    - echo "//gitlab.com/api/v4/projects/20565764/packages/npm/:_authToken=${NPM_REG_TOKEN}">>.npmrc
    - yarn global add @fireblocks/fb-cli
  script:
  - - echo "Self Service User Guide - https://fireblocks.atlassian.net/wiki/spaces/RD/pages/1413218873/Self+Service+User+Guide"
    - SVC_NAME=$([ "$SERVICE_NAME" ] && echo $SERVICE_NAME || echo $CI_PROJECT_NAME)
    - echo "Verifying deployment folder for ${SVC_NAME} service"
    - git clone ${DESTINATION_REPO} mono_repo
    - cd mono_repo
    - git fetch --all
    - git checkout ${STATE_BRANCH}
    - git pull origin ${STATE_BRANCH} --no-rebase
    - cd ../${SOURCE_PATH}
    - |
      # Define the paths
      values_file="values.yaml"

      # Check for values.yaml in the deployment folder
      if [ ! -f "$values_file" ]; then
          echo "Error: The values.yaml file is missing in the ${SOURCE_PATH} folder."
          exit 1
      fi

      echo "Success: All required files are present"
    - |
      # Directory to check
      DIR_TO_CHECK="overrides/"

      # List of allowed files
      ALLOWED_PATTERN=$(printf "|%s" "nonprod-tier.yaml" "prod-tier.yaml" "iac-dev.yaml" "localstack.yaml" "dev1.yaml" "dev2.yaml" "dev3.yaml" "dev4.yaml" "dev5.yaml" "dev6.yaml" "dev7.yaml" "dev8.yaml" "dev9.yaml" "dev10.yaml" "dev11.yaml" "dev11.yaml" "dev12.yaml" "dev13.yaml" "dev14.yaml" "dev15.yaml" "pre1.yaml" "stage.yaml" "sandbox.yaml" "eu-prod.yaml" "eu2-prod.yaml" "bnym-dev.yaml" "bnym-prod.yaml" "us-prod.yaml" | cut -c 2-)

      # Flag to track if there are disallowed files
      DISALLOWED_FOUND=false

      # Check for files in the directory that are not in the allowed list
      for file in "$DIR_TO_CHECK"/*; do
        # Get the base name of the file
        filename=$(basename "$file")

        # Check if the filename is in the allowed list
        if [[ ! $filename =~ ^($ALLOWED_PATTERN)$ ]]; then
          echo "Disallowed file found: $filename"
          DISALLOWED_FOUND=true
        fi
      done

      # Final output
      if $DISALLOWED_FOUND; then
        echo "Some files are not allowed."
        exit 1
      else
        echo "All files are allowed."
      fi
    - echo "Linting deployment yaml files"
    - cp ../mono_repo/services/schema/*.yaml .
    - cp ../mono_repo/services/schema/appconfig_schema.json .
    - cp ../mono_repo/services/schema/main_appconfig.json appconfig.json
    - cp ../mono_repo/services/schema/yamllint_rules.yaml yamllint_rules.yaml
    - yamllint --list-files **/*.yaml *.yaml
    - yamllint -s **/*.yaml *.yaml -c yamllint_rules.yaml
    - echo "Validating deployment yaml schema"
    - yamale -s base_values_schema.yaml values.yaml
    - yamale -s tier_values_schema.yaml overrides/prod-tier.yaml
    - yamale -s tier_values_schema.yaml overrides/nonprod-tier.yaml
    - |
      # Iterate over all yaml files in the overrides folder
      for file in overrides/*.yaml; do
          # Extract the filename from the path
          filename=$(basename -- "$file")

          # Check if the file is not prod-tier.yaml or nonprod-tier.yaml
          if [[ "$filename" != "prod-tier.yaml" ]] && [[ "$filename" != "nonprod-tier.yaml" ]]; then
              # Run yamale command on the file
              yamale -s env_values_schema.yaml "$file"
          fi
      done
    - "# Iterate over all yaml files in the overrides folder - validate_resources.sh\nif
      [[ -v ENGINE && \"$ENGINE\" == \"argocd\" ]]; then\n  export CD_INFRA_PROJECT_ID=61508954\n
      \ curl --header \"PRIVATE-TOKEN: $CD_CPU_RAM_REQUEST_LIMIT_READ_ONLY\"  \"https://gitlab.com/api/v4/projects/$CD_INFRA_PROJECT_ID/repository/files/ci-infra%2Fscripts%2Fvalidate_resources.sh/raw?ref=main\"
      -o \"$CI_PROJECT_DIR/validate_resources.sh\"\n  echo \"chmod +x $CI_PROJECT_DIR/validate_resources.sh\"
      \n  chmod +x \"$CI_PROJECT_DIR/validate_resources.sh\"\n  echo \"Searching for
      environments values files...\" \n  ENV_FILES_LIST=$(yamllint --list-files **/*.yaml
      *.yaml | grep -vE 'env_values_schema\\.yaml|tier_values_schema\\.yaml|base_values_schema\\.yaml|yamllint_rules\\.yaml|.*prod-tier\\.yaml|values.yaml'
      || true)\n  if [[ -n \"$ENV_FILES_LIST\" ]]; then\n    echo \"Found environments
      values files\"\n    while IFS= read -r file; do\n      filename=$(basename --
      \"$file\")\n      if [[ \"$filename\" =~ ^(dev[1-9]|dev10|stage|pre1).yaml$
      ]]; then\n        tier_file=\"overrides/nonprod-tier.yaml\"\n      else\n        tier_file=\"overrides/prod-tier.yaml\"
      \ \n      fi\n      echo \"values.yaml <-- $tier_file <-- $file\"\n      yq
      eval-all '. as $item ireduce ({}; . * $item)' values.yaml \"$tier_file\" \"$file\"
      | bash \"$CI_PROJECT_DIR/validate_resources.sh\" -\n    done <<< \"$ENV_FILES_LIST\"\n
      \ else\n    echo \"No environments values files were found. Continuing to the
      tier files.\"\n  fi\necho \"values.yaml <-- overrides/nonprod-tier.yaml\"\nyq
      eval-all '. as $item ireduce ({}; . * $item)' values.yaml overrides/nonprod-tier.yaml
      | bash \"$CI_PROJECT_DIR/validate_resources.sh\" -\necho \"values.yaml <-- overrides/prod-tier.yaml\"
      \nyq eval-all '. as $item ireduce ({}; . * $item)' values.yaml overrides/prod-tier.yaml
      | bash \"$CI_PROJECT_DIR/validate_resources.sh\" -\nelse\n  echo \"Skipping
      resource validation: ENGINE is not set to 'argocd'.\"\nfi\n"
    - ajv validate -s appconfig_schema.json -d appconfig.json
    - echo "Resources verified successfully"
    - echo "Validate filter_policy if exists - should be a valid JSON object"
    - fb deployment:validate . --filter-policy
  - cd ../mono_repo
  - ENV_DESTINATION_PATH=$(echo "${DESTINATION_PATH}/${SVC_NAME}/${ENV}")
  - echo "Copying ${SOURCE_PATH} folder from ${SVC_NAME} service to argocd mono repo
    destination folder at ${ENV_DESTINATION_PATH}"
  - mkdir -pv ${ENV_DESTINATION_PATH}/overrides
  - rm ${ENV_DESTINATION_PATH}/overrides/${ENV}.yaml || true
  - cp  ../${SOURCE_PATH}/values.yaml ${ENV_DESTINATION_PATH}
  - cp ../${SOURCE_PATH}/overrides/${ENV}.yaml  ${ENV_DESTINATION_PATH}/overrides
    || true
  - cp ../${SOURCE_PATH}/overrides/*-tier.yaml  ${ENV_DESTINATION_PATH}/overrides
    || true
  - if [ ! -f ${ENV_DESTINATION_PATH}/appconfig.json ]; then cp ../mono_repo/services/schema/main_appconfig.json
    ${ENV_DESTINATION_PATH}/appconfig.json; fi
  - git status
  - echo "Adding changes to Git"
  - git add ${DESTINATION_PATH}
  - git status
  - COUNT=$(git diff --numstat ${STATE_BRANCH} | awk '{added += $1; deleted += $2}
    END {print added + deleted}')
  - |
    if [ "$COUNT" -eq 0 ]; then
      echo "No changes detected under ${CI_PROJECT_NAME}/${SOURCE_PATH}, exiting"
      exit 0
    fi
  - echo "Committing changes"
  - git commit -m "${CI_JOB_NAME}"
  - echo "Pushing changes to remote"
  - git pull --rebase
  - git status
  - "MAX_RETRIES=3\nINITIAL_DELAY=5\nsuccess=false\n\nfor attempt in $(seq 1 $MAX_RETRIES);
    do\n  if git push; then\n    echo -e \"\\e[32mPush successful\\e[0m\"\n    success=true\n
    \   break\n  else\n    echo -e \"\\e[33mPush failed, retrying ($attempt/$MAX_RETRIES)...\\e[0m\"\n
    \   git pull --rebase\n    \n    # Calculate backoff delay (5s, then 10s, then
    20s)\n    BACKOFF_DELAY=$((INITIAL_DELAY * 2**(attempt-1)))\n    echo \"Waiting
    ${BACKOFF_DELAY} seconds before next attempt...\"\n    sleep $BACKOFF_DELAY\n
    \ fi\ndone\n\nif [ \"$success\" != \"true\" ]; then\n  echo -e \"\\e[31mFailed
    to push after $MAX_RETRIES attempts\\e[0m\"\n  exit 1\nfi\n"
  - git status
  - echo "Resources published to argocd mono repo"
  variables:
    DESTINATION_REPO: https://gitlab.com/fireblocks/devops/iac/argocd.git
    DESTINATION_PROJECT_ID: 50521873
    SOURCE_PATH: deployment
    DESTINATION_PATH: services/shell
    STATE_BRANCH: main
    GITLAB_API_URL: https://gitlab.com/api/v4/projects
    TEMPLATE_REF: "$TEMPLATE_REF"
    GITLAB_RUNNER_TAG: bnym-dev-application-gitlab-runner
    ENV: bnym-dev
  extends: ".publish_resources_prod"
".publish_resources_bnym-prod":
  stage: configure
  retry:
    max: 2
    when:
    - script_failure
  tags:
  - "${GITLAB_RUNNER_TAG}"
  before_script:
  - printf "%s:%s\n" DESTINATION_REPO "$DESTINATION_REPO" DESTINATION_PROJECT_ID "$DESTINATION_PROJECT_ID"
    SOURCE_PATH "$SOURCE_PATH" DESTINATION_PATH "$DESTINATION_PATH" STATE_BRANCH "$STATE_BRANCH"
    GITLAB_API_URL "$GITLAB_API_URL"
  - |
    if [ ! -d "$SOURCE_PATH" ]; then
      echo "$SOURCE_PATH directory does not exist. Exiting job successfully."
      exit 0
    fi
    echo "$SOURCE_PATH directory exists. Continuing with deployment."
  - - apk update
    - apk add curl jq yq py3-pip
    - pip3 install --upgrade pip
    - pip3 install yamllint
    - pip3 install yamale --break-system-packages
    - npm install -g ajv-cli
    - echo "Configuring Git"
    - echo "https://argocd-ci-push:${ARGOCD_GITLAB_ACCESS_TOKEN}@gitlab.com" > ~/.git-credentials
    - git remote set-url origin https://argocd-ci-push:${ARGOCD_GITLAB_ACCESS_TOKEN}@gitlab.com/fireblocks/devops/iac/argocd.git
    - git config --global user.email "devops@fireblocks.com"
    - git config --global user.name "argocd-ci-push"
    - git config --global credential.helper store
    - touch .npmrc
    - npm config set --location=user @fireblocks:registry https://gitlab.com/api/v4/packages/npm/
    - npm config set --location=user '//gitlab.com/api/v4/packages/npm/:_authToken'
      "${NPM_REG_TOKEN}"
    - npm config set --location=user '//gitlab.com/api/v4/projects/20565764/packages/npm/:_authToken'
      "${NPM_REG_TOKEN}"
    - echo "@fireblocks:registry=https://gitlab.com/api/v4/packages/npm/">>.npmrc
    - echo "//gitlab.com/api/v4/packages/npm/:_authToken=${NPM_REG_TOKEN}">>.npmrc
    - echo "//gitlab.com/api/v4/projects/20565764/packages/npm/:_authToken=${NPM_REG_TOKEN}">>.npmrc
    - yarn global add @fireblocks/fb-cli
  script:
  - - echo "Self Service User Guide - https://fireblocks.atlassian.net/wiki/spaces/RD/pages/1413218873/Self+Service+User+Guide"
    - SVC_NAME=$([ "$SERVICE_NAME" ] && echo $SERVICE_NAME || echo $CI_PROJECT_NAME)
    - echo "Verifying deployment folder for ${SVC_NAME} service"
    - git clone ${DESTINATION_REPO} mono_repo
    - cd mono_repo
    - git fetch --all
    - git checkout ${STATE_BRANCH}
    - git pull origin ${STATE_BRANCH} --no-rebase
    - cd ../${SOURCE_PATH}
    - |
      # Define the paths
      values_file="values.yaml"

      # Check for values.yaml in the deployment folder
      if [ ! -f "$values_file" ]; then
          echo "Error: The values.yaml file is missing in the ${SOURCE_PATH} folder."
          exit 1
      fi

      echo "Success: All required files are present"
    - |
      # Directory to check
      DIR_TO_CHECK="overrides/"

      # List of allowed files
      ALLOWED_PATTERN=$(printf "|%s" "nonprod-tier.yaml" "prod-tier.yaml" "iac-dev.yaml" "localstack.yaml" "dev1.yaml" "dev2.yaml" "dev3.yaml" "dev4.yaml" "dev5.yaml" "dev6.yaml" "dev7.yaml" "dev8.yaml" "dev9.yaml" "dev10.yaml" "dev11.yaml" "dev11.yaml" "dev12.yaml" "dev13.yaml" "dev14.yaml" "dev15.yaml" "pre1.yaml" "stage.yaml" "sandbox.yaml" "eu-prod.yaml" "eu2-prod.yaml" "bnym-dev.yaml" "bnym-prod.yaml" "us-prod.yaml" | cut -c 2-)

      # Flag to track if there are disallowed files
      DISALLOWED_FOUND=false

      # Check for files in the directory that are not in the allowed list
      for file in "$DIR_TO_CHECK"/*; do
        # Get the base name of the file
        filename=$(basename "$file")

        # Check if the filename is in the allowed list
        if [[ ! $filename =~ ^($ALLOWED_PATTERN)$ ]]; then
          echo "Disallowed file found: $filename"
          DISALLOWED_FOUND=true
        fi
      done

      # Final output
      if $DISALLOWED_FOUND; then
        echo "Some files are not allowed."
        exit 1
      else
        echo "All files are allowed."
      fi
    - echo "Linting deployment yaml files"
    - cp ../mono_repo/services/schema/*.yaml .
    - cp ../mono_repo/services/schema/appconfig_schema.json .
    - cp ../mono_repo/services/schema/main_appconfig.json appconfig.json
    - cp ../mono_repo/services/schema/yamllint_rules.yaml yamllint_rules.yaml
    - yamllint --list-files **/*.yaml *.yaml
    - yamllint -s **/*.yaml *.yaml -c yamllint_rules.yaml
    - echo "Validating deployment yaml schema"
    - yamale -s base_values_schema.yaml values.yaml
    - yamale -s tier_values_schema.yaml overrides/prod-tier.yaml
    - yamale -s tier_values_schema.yaml overrides/nonprod-tier.yaml
    - |
      # Iterate over all yaml files in the overrides folder
      for file in overrides/*.yaml; do
          # Extract the filename from the path
          filename=$(basename -- "$file")

          # Check if the file is not prod-tier.yaml or nonprod-tier.yaml
          if [[ "$filename" != "prod-tier.yaml" ]] && [[ "$filename" != "nonprod-tier.yaml" ]]; then
              # Run yamale command on the file
              yamale -s env_values_schema.yaml "$file"
          fi
      done
    - "# Iterate over all yaml files in the overrides folder - validate_resources.sh\nif
      [[ -v ENGINE && \"$ENGINE\" == \"argocd\" ]]; then\n  export CD_INFRA_PROJECT_ID=61508954\n
      \ curl --header \"PRIVATE-TOKEN: $CD_CPU_RAM_REQUEST_LIMIT_READ_ONLY\"  \"https://gitlab.com/api/v4/projects/$CD_INFRA_PROJECT_ID/repository/files/ci-infra%2Fscripts%2Fvalidate_resources.sh/raw?ref=main\"
      -o \"$CI_PROJECT_DIR/validate_resources.sh\"\n  echo \"chmod +x $CI_PROJECT_DIR/validate_resources.sh\"
      \n  chmod +x \"$CI_PROJECT_DIR/validate_resources.sh\"\n  echo \"Searching for
      environments values files...\" \n  ENV_FILES_LIST=$(yamllint --list-files **/*.yaml
      *.yaml | grep -vE 'env_values_schema\\.yaml|tier_values_schema\\.yaml|base_values_schema\\.yaml|yamllint_rules\\.yaml|.*prod-tier\\.yaml|values.yaml'
      || true)\n  if [[ -n \"$ENV_FILES_LIST\" ]]; then\n    echo \"Found environments
      values files\"\n    while IFS= read -r file; do\n      filename=$(basename --
      \"$file\")\n      if [[ \"$filename\" =~ ^(dev[1-9]|dev10|stage|pre1).yaml$
      ]]; then\n        tier_file=\"overrides/nonprod-tier.yaml\"\n      else\n        tier_file=\"overrides/prod-tier.yaml\"
      \ \n      fi\n      echo \"values.yaml <-- $tier_file <-- $file\"\n      yq
      eval-all '. as $item ireduce ({}; . * $item)' values.yaml \"$tier_file\" \"$file\"
      | bash \"$CI_PROJECT_DIR/validate_resources.sh\" -\n    done <<< \"$ENV_FILES_LIST\"\n
      \ else\n    echo \"No environments values files were found. Continuing to the
      tier files.\"\n  fi\necho \"values.yaml <-- overrides/nonprod-tier.yaml\"\nyq
      eval-all '. as $item ireduce ({}; . * $item)' values.yaml overrides/nonprod-tier.yaml
      | bash \"$CI_PROJECT_DIR/validate_resources.sh\" -\necho \"values.yaml <-- overrides/prod-tier.yaml\"
      \nyq eval-all '. as $item ireduce ({}; . * $item)' values.yaml overrides/prod-tier.yaml
      | bash \"$CI_PROJECT_DIR/validate_resources.sh\" -\nelse\n  echo \"Skipping
      resource validation: ENGINE is not set to 'argocd'.\"\nfi\n"
    - ajv validate -s appconfig_schema.json -d appconfig.json
    - echo "Resources verified successfully"
    - echo "Validate filter_policy if exists - should be a valid JSON object"
    - fb deployment:validate . --filter-policy
  - cd ../mono_repo
  - ENV_DESTINATION_PATH=$(echo "${DESTINATION_PATH}/${SVC_NAME}/${ENV}")
  - echo "Copying ${SOURCE_PATH} folder from ${SVC_NAME} service to argocd mono repo
    destination folder at ${ENV_DESTINATION_PATH}"
  - mkdir -pv ${ENV_DESTINATION_PATH}/overrides
  - rm ${ENV_DESTINATION_PATH}/overrides/${ENV}.yaml || true
  - cp  ../${SOURCE_PATH}/values.yaml ${ENV_DESTINATION_PATH}
  - cp ../${SOURCE_PATH}/overrides/${ENV}.yaml  ${ENV_DESTINATION_PATH}/overrides
    || true
  - cp ../${SOURCE_PATH}/overrides/*-tier.yaml  ${ENV_DESTINATION_PATH}/overrides
    || true
  - if [ ! -f ${ENV_DESTINATION_PATH}/appconfig.json ]; then cp ../mono_repo/services/schema/main_appconfig.json
    ${ENV_DESTINATION_PATH}/appconfig.json; fi
  - git status
  - echo "Adding changes to Git"
  - git add ${DESTINATION_PATH}
  - git status
  - COUNT=$(git diff --numstat ${STATE_BRANCH} | awk '{added += $1; deleted += $2}
    END {print added + deleted}')
  - |
    if [ "$COUNT" -eq 0 ]; then
      echo "No changes detected under ${CI_PROJECT_NAME}/${SOURCE_PATH}, exiting"
      exit 0
    fi
  - echo "Committing changes"
  - git commit -m "${CI_JOB_NAME}"
  - echo "Pushing changes to remote"
  - git pull --rebase
  - git status
  - "MAX_RETRIES=3\nINITIAL_DELAY=5\nsuccess=false\n\nfor attempt in $(seq 1 $MAX_RETRIES);
    do\n  if git push; then\n    echo -e \"\\e[32mPush successful\\e[0m\"\n    success=true\n
    \   break\n  else\n    echo -e \"\\e[33mPush failed, retrying ($attempt/$MAX_RETRIES)...\\e[0m\"\n
    \   git pull --rebase\n    \n    # Calculate backoff delay (5s, then 10s, then
    20s)\n    BACKOFF_DELAY=$((INITIAL_DELAY * 2**(attempt-1)))\n    echo \"Waiting
    ${BACKOFF_DELAY} seconds before next attempt...\"\n    sleep $BACKOFF_DELAY\n
    \ fi\ndone\n\nif [ \"$success\" != \"true\" ]; then\n  echo -e \"\\e[31mFailed
    to push after $MAX_RETRIES attempts\\e[0m\"\n  exit 1\nfi\n"
  - git status
  - echo "Resources published to argocd mono repo"
  variables:
    DESTINATION_REPO: https://gitlab.com/fireblocks/devops/iac/argocd.git
    DESTINATION_PROJECT_ID: 50521873
    SOURCE_PATH: deployment
    DESTINATION_PATH: services/shell
    STATE_BRANCH: main
    GITLAB_API_URL: https://gitlab.com/api/v4/projects
    TEMPLATE_REF: "$TEMPLATE_REF"
    GITLAB_RUNNER_TAG: bnym-prod-application-gitlab-runner
    ENV: bnym-prod
  extends: ".publish_resources_prod"
".argocd_sync_resources_dev1":
  stage: configure
  retry:
    max: 2
    when:
    - script_failure
  tags:
  - "${GITLAB_RUNNER_TAG}"
  before_script:
  - echo "Install yq & jq from deploy-stage.yml"
  - apk update
  - apk add jq
  - apk add yq
  - |
    if [ ! -d "$SOURCE_PATH" ]; then
      echo "$SOURCE_PATH directory does not exist. Exiting job successfully."
      exit 0
    fi
    echo "$SOURCE_PATH directory exists. Continuing with deployment."
  - apk update
  - apk add curl
  - curl -sSL -o argocd-linux-amd64 https://github.com/argoproj/argo-cd/releases/download/v2.14.9/argocd-linux-amd64
  - install -m 555 argocd-linux-amd64 /usr/local/bin/argocd
  - rm argocd-linux-amd64
  - argocd version --client
  script:
  - echo "Self Service User Guide - https://fireblocks.atlassian.net/wiki/spaces/RD/pages/1413218873/Self+Service+User+Guide"
  - SVC_NAME=$([ "$SERVICE_NAME" ] && echo $SERVICE_NAME || echo $CI_PROJECT_NAME)
  - echo "Syncing resources for ${SVC_NAME} service"
  - ARGOCD_APP_NAME=$(echo "${SVC_NAME}-${ENV}")
  - echo "Refreshing ${ARGOCD_APP_NAME} application"
  - argocd app get ${ARGOCD_APP_NAME} -owide --refresh --insecure --auth-token ${ARGOCD_AUTH_TOKEN}
    --server ${ARGOCD_SERVER}
  - echo "Syncing ${ARGOCD_APP_NAME} application"
  - |
    if [[ "$STRATEGY" == "canary" ]]; then
      argocd app sync --resource '!*:Rollout:*' --resource '!*:Service:*' --prune ${ARGOCD_APP_NAME} --insecure --auth-token ${ARGOCD_AUTH_TOKEN} --server ${ARGOCD_SERVER}
    elif [[ "$STRATEGY" == "in_place" ]]; then
      argocd app sync --resource '!*:Deployment:*' --resource '!*:Service:*' --prune ${ARGOCD_APP_NAME} --insecure --auth-token ${ARGOCD_AUTH_TOKEN} --server ${ARGOCD_SERVER}
    else
      argocd app sync --prune ${ARGOCD_APP_NAME} --insecure --auth-token ${ARGOCD_AUTH_TOKEN} --server ${ARGOCD_SERVER}
    fi
  - echo "Waiting for ${ARGOCD_APP_NAME} application to be synced and healthy"
  - |
    resources_to_sync=$(argocd app get ${ARGOCD_APP_NAME} --insecure --auth-token ${ARGOCD_AUTH_TOKEN} --server ${ARGOCD_SERVER} -o json | jq -r 'select(.status.resources != null) | .status.resources[] | select(.health.status and .kind != "Deployment" and .kind != "Rollout" and .kind != "Ingress" and .kind != "Service") | "\(.group // ""):\(.kind):\(.name)"')
    if [ "x${resources_to_sync}" == "x" ]; then
        echo "There are no resources to sync"
    else
        echo ${resources_to_sync}
        for resource in ${resources_to_sync}; do
            argocd app wait ${ARGOCD_APP_NAME} --resource $resource --health --sync --timeout 600 --loglevel debug --insecure --auth-token ${ARGOCD_AUTH_TOKEN} --server ${ARGOCD_SERVER}
        done
    fi
  variables:
    SOURCE_PATH: deployment
    GITLAB_RUNNER_TAG: devx-application-gitlab-runner
    ARGOCD_SERVER: "${ARGOCD_NONPROD_SERVER}"
    ARGOCD_AUTH_TOKEN: "${ARGOCD_NONPROD_SHELL_AUTH_TOKEN}"
    ENV: dev1
  extends: ".argocd_sync_resources_dev"
".argocd_sync_resources_dev2":
  stage: configure
  retry:
    max: 2
    when:
    - script_failure
  tags:
  - "${GITLAB_RUNNER_TAG}"
  before_script:
  - echo "Install yq & jq from deploy-stage.yml"
  - apk update
  - apk add jq
  - apk add yq
  - |
    if [ ! -d "$SOURCE_PATH" ]; then
      echo "$SOURCE_PATH directory does not exist. Exiting job successfully."
      exit 0
    fi
    echo "$SOURCE_PATH directory exists. Continuing with deployment."
  - apk update
  - apk add curl
  - curl -sSL -o argocd-linux-amd64 https://github.com/argoproj/argo-cd/releases/download/v2.14.9/argocd-linux-amd64
  - install -m 555 argocd-linux-amd64 /usr/local/bin/argocd
  - rm argocd-linux-amd64
  - argocd version --client
  script:
  - echo "Self Service User Guide - https://fireblocks.atlassian.net/wiki/spaces/RD/pages/1413218873/Self+Service+User+Guide"
  - SVC_NAME=$([ "$SERVICE_NAME" ] && echo $SERVICE_NAME || echo $CI_PROJECT_NAME)
  - echo "Syncing resources for ${SVC_NAME} service"
  - ARGOCD_APP_NAME=$(echo "${SVC_NAME}-${ENV}")
  - echo "Refreshing ${ARGOCD_APP_NAME} application"
  - argocd app get ${ARGOCD_APP_NAME} -owide --refresh --insecure --auth-token ${ARGOCD_AUTH_TOKEN}
    --server ${ARGOCD_SERVER}
  - echo "Syncing ${ARGOCD_APP_NAME} application"
  - |
    if [[ "$STRATEGY" == "canary" ]]; then
      argocd app sync --resource '!*:Rollout:*' --resource '!*:Service:*' --prune ${ARGOCD_APP_NAME} --insecure --auth-token ${ARGOCD_AUTH_TOKEN} --server ${ARGOCD_SERVER}
    elif [[ "$STRATEGY" == "in_place" ]]; then
      argocd app sync --resource '!*:Deployment:*' --resource '!*:Service:*' --prune ${ARGOCD_APP_NAME} --insecure --auth-token ${ARGOCD_AUTH_TOKEN} --server ${ARGOCD_SERVER}
    else
      argocd app sync --prune ${ARGOCD_APP_NAME} --insecure --auth-token ${ARGOCD_AUTH_TOKEN} --server ${ARGOCD_SERVER}
    fi
  - echo "Waiting for ${ARGOCD_APP_NAME} application to be synced and healthy"
  - |
    resources_to_sync=$(argocd app get ${ARGOCD_APP_NAME} --insecure --auth-token ${ARGOCD_AUTH_TOKEN} --server ${ARGOCD_SERVER} -o json | jq -r 'select(.status.resources != null) | .status.resources[] | select(.health.status and .kind != "Deployment" and .kind != "Rollout" and .kind != "Ingress" and .kind != "Service") | "\(.group // ""):\(.kind):\(.name)"')
    if [ "x${resources_to_sync}" == "x" ]; then
        echo "There are no resources to sync"
    else
        echo ${resources_to_sync}
        for resource in ${resources_to_sync}; do
            argocd app wait ${ARGOCD_APP_NAME} --resource $resource --health --sync --timeout 600 --loglevel debug --insecure --auth-token ${ARGOCD_AUTH_TOKEN} --server ${ARGOCD_SERVER}
        done
    fi
  variables:
    SOURCE_PATH: deployment
    GITLAB_RUNNER_TAG: devx-application-gitlab-runner
    ARGOCD_SERVER: "${ARGOCD_NONPROD_SERVER}"
    ARGOCD_AUTH_TOKEN: "${ARGOCD_NONPROD_SHELL_AUTH_TOKEN}"
    ENV: dev2
  extends: ".argocd_sync_resources_dev"
".argocd_sync_resources_dev3":
  stage: configure
  retry:
    max: 2
    when:
    - script_failure
  tags:
  - "${GITLAB_RUNNER_TAG}"
  before_script:
  - echo "Install yq & jq from deploy-stage.yml"
  - apk update
  - apk add jq
  - apk add yq
  - |
    if [ ! -d "$SOURCE_PATH" ]; then
      echo "$SOURCE_PATH directory does not exist. Exiting job successfully."
      exit 0
    fi
    echo "$SOURCE_PATH directory exists. Continuing with deployment."
  - apk update
  - apk add curl
  - curl -sSL -o argocd-linux-amd64 https://github.com/argoproj/argo-cd/releases/download/v2.14.9/argocd-linux-amd64
  - install -m 555 argocd-linux-amd64 /usr/local/bin/argocd
  - rm argocd-linux-amd64
  - argocd version --client
  script:
  - echo "Self Service User Guide - https://fireblocks.atlassian.net/wiki/spaces/RD/pages/1413218873/Self+Service+User+Guide"
  - SVC_NAME=$([ "$SERVICE_NAME" ] && echo $SERVICE_NAME || echo $CI_PROJECT_NAME)
  - echo "Syncing resources for ${SVC_NAME} service"
  - ARGOCD_APP_NAME=$(echo "${SVC_NAME}-${ENV}")
  - echo "Refreshing ${ARGOCD_APP_NAME} application"
  - argocd app get ${ARGOCD_APP_NAME} -owide --refresh --insecure --auth-token ${ARGOCD_AUTH_TOKEN}
    --server ${ARGOCD_SERVER}
  - echo "Syncing ${ARGOCD_APP_NAME} application"
  - |
    if [[ "$STRATEGY" == "canary" ]]; then
      argocd app sync --resource '!*:Rollout:*' --resource '!*:Service:*' --prune ${ARGOCD_APP_NAME} --insecure --auth-token ${ARGOCD_AUTH_TOKEN} --server ${ARGOCD_SERVER}
    elif [[ "$STRATEGY" == "in_place" ]]; then
      argocd app sync --resource '!*:Deployment:*' --resource '!*:Service:*' --prune ${ARGOCD_APP_NAME} --insecure --auth-token ${ARGOCD_AUTH_TOKEN} --server ${ARGOCD_SERVER}
    else
      argocd app sync --prune ${ARGOCD_APP_NAME} --insecure --auth-token ${ARGOCD_AUTH_TOKEN} --server ${ARGOCD_SERVER}
    fi
  - echo "Waiting for ${ARGOCD_APP_NAME} application to be synced and healthy"
  - |
    resources_to_sync=$(argocd app get ${ARGOCD_APP_NAME} --insecure --auth-token ${ARGOCD_AUTH_TOKEN} --server ${ARGOCD_SERVER} -o json | jq -r 'select(.status.resources != null) | .status.resources[] | select(.health.status and .kind != "Deployment" and .kind != "Rollout" and .kind != "Ingress" and .kind != "Service") | "\(.group // ""):\(.kind):\(.name)"')
    if [ "x${resources_to_sync}" == "x" ]; then
        echo "There are no resources to sync"
    else
        echo ${resources_to_sync}
        for resource in ${resources_to_sync}; do
            argocd app wait ${ARGOCD_APP_NAME} --resource $resource --health --sync --timeout 600 --loglevel debug --insecure --auth-token ${ARGOCD_AUTH_TOKEN} --server ${ARGOCD_SERVER}
        done
    fi
  variables:
    SOURCE_PATH: deployment
    GITLAB_RUNNER_TAG: devx-application-gitlab-runner
    ARGOCD_SERVER: "${ARGOCD_NONPROD_SERVER}"
    ARGOCD_AUTH_TOKEN: "${ARGOCD_NONPROD_SHELL_AUTH_TOKEN}"
    ENV: dev3
  extends: ".argocd_sync_resources_dev"
".argocd_sync_resources_dev4":
  stage: configure
  retry:
    max: 2
    when:
    - script_failure
  tags:
  - "${GITLAB_RUNNER_TAG}"
  before_script:
  - echo "Install yq & jq from deploy-stage.yml"
  - apk update
  - apk add jq
  - apk add yq
  - |
    if [ ! -d "$SOURCE_PATH" ]; then
      echo "$SOURCE_PATH directory does not exist. Exiting job successfully."
      exit 0
    fi
    echo "$SOURCE_PATH directory exists. Continuing with deployment."
  - apk update
  - apk add curl
  - curl -sSL -o argocd-linux-amd64 https://github.com/argoproj/argo-cd/releases/download/v2.14.9/argocd-linux-amd64
  - install -m 555 argocd-linux-amd64 /usr/local/bin/argocd
  - rm argocd-linux-amd64
  - argocd version --client
  script:
  - echo "Self Service User Guide - https://fireblocks.atlassian.net/wiki/spaces/RD/pages/1413218873/Self+Service+User+Guide"
  - SVC_NAME=$([ "$SERVICE_NAME" ] && echo $SERVICE_NAME || echo $CI_PROJECT_NAME)
  - echo "Syncing resources for ${SVC_NAME} service"
  - ARGOCD_APP_NAME=$(echo "${SVC_NAME}-${ENV}")
  - echo "Refreshing ${ARGOCD_APP_NAME} application"
  - argocd app get ${ARGOCD_APP_NAME} -owide --refresh --insecure --auth-token ${ARGOCD_AUTH_TOKEN}
    --server ${ARGOCD_SERVER}
  - echo "Syncing ${ARGOCD_APP_NAME} application"
  - |
    if [[ "$STRATEGY" == "canary" ]]; then
      argocd app sync --resource '!*:Rollout:*' --resource '!*:Service:*' --prune ${ARGOCD_APP_NAME} --insecure --auth-token ${ARGOCD_AUTH_TOKEN} --server ${ARGOCD_SERVER}
    elif [[ "$STRATEGY" == "in_place" ]]; then
      argocd app sync --resource '!*:Deployment:*' --resource '!*:Service:*' --prune ${ARGOCD_APP_NAME} --insecure --auth-token ${ARGOCD_AUTH_TOKEN} --server ${ARGOCD_SERVER}
    else
      argocd app sync --prune ${ARGOCD_APP_NAME} --insecure --auth-token ${ARGOCD_AUTH_TOKEN} --server ${ARGOCD_SERVER}
    fi
  - echo "Waiting for ${ARGOCD_APP_NAME} application to be synced and healthy"
  - |
    resources_to_sync=$(argocd app get ${ARGOCD_APP_NAME} --insecure --auth-token ${ARGOCD_AUTH_TOKEN} --server ${ARGOCD_SERVER} -o json | jq -r 'select(.status.resources != null) | .status.resources[] | select(.health.status and .kind != "Deployment" and .kind != "Rollout" and .kind != "Ingress" and .kind != "Service") | "\(.group // ""):\(.kind):\(.name)"')
    if [ "x${resources_to_sync}" == "x" ]; then
        echo "There are no resources to sync"
    else
        echo ${resources_to_sync}
        for resource in ${resources_to_sync}; do
            argocd app wait ${ARGOCD_APP_NAME} --resource $resource --health --sync --timeout 600 --loglevel debug --insecure --auth-token ${ARGOCD_AUTH_TOKEN} --server ${ARGOCD_SERVER}
        done
    fi
  variables:
    SOURCE_PATH: deployment
    GITLAB_RUNNER_TAG: devx-application-gitlab-runner
    ARGOCD_SERVER: "${ARGOCD_NONPROD_SERVER}"
    ARGOCD_AUTH_TOKEN: "${ARGOCD_NONPROD_SHELL_AUTH_TOKEN}"
    ENV: dev4
  extends: ".argocd_sync_resources_dev"
".argocd_sync_resources_stage":
  stage: configure
  retry:
    max: 2
    when:
    - script_failure
  tags:
  - "${GITLAB_RUNNER_TAG}"
  before_script:
  - echo "Install yq & jq from deploy-stage.yml"
  - apk update
  - apk add jq
  - apk add yq
  - |
    if [ ! -d "$SOURCE_PATH" ]; then
      echo "$SOURCE_PATH directory does not exist. Exiting job successfully."
      exit 0
    fi
    echo "$SOURCE_PATH directory exists. Continuing with deployment."
  - apk update
  - apk add curl
  - curl -sSL -o argocd-linux-amd64 https://github.com/argoproj/argo-cd/releases/download/v2.14.9/argocd-linux-amd64
  - install -m 555 argocd-linux-amd64 /usr/local/bin/argocd
  - rm argocd-linux-amd64
  - argocd version --client
  script:
  - echo "Self Service User Guide - https://fireblocks.atlassian.net/wiki/spaces/RD/pages/1413218873/Self+Service+User+Guide"
  - SVC_NAME=$([ "$SERVICE_NAME" ] && echo $SERVICE_NAME || echo $CI_PROJECT_NAME)
  - echo "Syncing resources for ${SVC_NAME} service"
  - ARGOCD_APP_NAME=$(echo "${SVC_NAME}-${ENV}")
  - echo "Refreshing ${ARGOCD_APP_NAME} application"
  - argocd app get ${ARGOCD_APP_NAME} -owide --refresh --insecure --auth-token ${ARGOCD_AUTH_TOKEN}
    --server ${ARGOCD_SERVER}
  - echo "Syncing ${ARGOCD_APP_NAME} application"
  - |
    if [[ "$STRATEGY" == "canary" ]]; then
      argocd app sync --resource '!*:Rollout:*' --resource '!*:Service:*' --prune ${ARGOCD_APP_NAME} --insecure --auth-token ${ARGOCD_AUTH_TOKEN} --server ${ARGOCD_SERVER}
    elif [[ "$STRATEGY" == "in_place" ]]; then
      argocd app sync --resource '!*:Deployment:*' --resource '!*:Service:*' --prune ${ARGOCD_APP_NAME} --insecure --auth-token ${ARGOCD_AUTH_TOKEN} --server ${ARGOCD_SERVER}
    else
      argocd app sync --prune ${ARGOCD_APP_NAME} --insecure --auth-token ${ARGOCD_AUTH_TOKEN} --server ${ARGOCD_SERVER}
    fi
  - echo "Waiting for ${ARGOCD_APP_NAME} application to be synced and healthy"
  - |
    resources_to_sync=$(argocd app get ${ARGOCD_APP_NAME} --insecure --auth-token ${ARGOCD_AUTH_TOKEN} --server ${ARGOCD_SERVER} -o json | jq -r 'select(.status.resources != null) | .status.resources[] | select(.health.status and .kind != "Deployment" and .kind != "Rollout" and .kind != "Ingress" and .kind != "Service") | "\(.group // ""):\(.kind):\(.name)"')
    if [ "x${resources_to_sync}" == "x" ]; then
        echo "There are no resources to sync"
    else
        echo ${resources_to_sync}
        for resource in ${resources_to_sync}; do
            argocd app wait ${ARGOCD_APP_NAME} --resource $resource --health --sync --timeout 600 --loglevel debug --insecure --auth-token ${ARGOCD_AUTH_TOKEN} --server ${ARGOCD_SERVER}
        done
    fi
  variables:
    SOURCE_PATH: deployment
    GITLAB_RUNNER_TAG: devx-application-gitlab-runner
    ARGOCD_SERVER: "${ARGOCD_NONPROD_SERVER}"
    ARGOCD_AUTH_TOKEN: "${ARGOCD_NONPROD_SHELL_AUTH_TOKEN}"
    ENV: stage
  extends: ".argocd_sync_resources_dev"
".argocd_sync_resources_pre1":
  stage: configure
  retry:
    max: 2
    when:
    - script_failure
  tags:
  - "${GITLAB_RUNNER_TAG}"
  before_script:
  - echo "Install yq & jq from deploy-stage.yml"
  - apk update
  - apk add jq
  - apk add yq
  - |
    if [ ! -d "$SOURCE_PATH" ]; then
      echo "$SOURCE_PATH directory does not exist. Exiting job successfully."
      exit 0
    fi
    echo "$SOURCE_PATH directory exists. Continuing with deployment."
  - apk update
  - apk add curl
  - curl -sSL -o argocd-linux-amd64 https://github.com/argoproj/argo-cd/releases/download/v2.14.9/argocd-linux-amd64
  - install -m 555 argocd-linux-amd64 /usr/local/bin/argocd
  - rm argocd-linux-amd64
  - argocd version --client
  script:
  - echo "Self Service User Guide - https://fireblocks.atlassian.net/wiki/spaces/RD/pages/1413218873/Self+Service+User+Guide"
  - SVC_NAME=$([ "$SERVICE_NAME" ] && echo $SERVICE_NAME || echo $CI_PROJECT_NAME)
  - echo "Syncing resources for ${SVC_NAME} service"
  - ARGOCD_APP_NAME=$(echo "${SVC_NAME}-${ENV}")
  - echo "Refreshing ${ARGOCD_APP_NAME} application"
  - argocd app get ${ARGOCD_APP_NAME} -owide --refresh --insecure --auth-token ${ARGOCD_AUTH_TOKEN}
    --server ${ARGOCD_SERVER}
  - echo "Syncing ${ARGOCD_APP_NAME} application"
  - |
    if [[ "$STRATEGY" == "canary" ]]; then
      argocd app sync --resource '!*:Rollout:*' --resource '!*:Service:*' --prune ${ARGOCD_APP_NAME} --insecure --auth-token ${ARGOCD_AUTH_TOKEN} --server ${ARGOCD_SERVER}
    elif [[ "$STRATEGY" == "in_place" ]]; then
      argocd app sync --resource '!*:Deployment:*' --resource '!*:Service:*' --prune ${ARGOCD_APP_NAME} --insecure --auth-token ${ARGOCD_AUTH_TOKEN} --server ${ARGOCD_SERVER}
    else
      argocd app sync --prune ${ARGOCD_APP_NAME} --insecure --auth-token ${ARGOCD_AUTH_TOKEN} --server ${ARGOCD_SERVER}
    fi
  - echo "Waiting for ${ARGOCD_APP_NAME} application to be synced and healthy"
  - |
    resources_to_sync=$(argocd app get ${ARGOCD_APP_NAME} --insecure --auth-token ${ARGOCD_AUTH_TOKEN} --server ${ARGOCD_SERVER} -o json | jq -r 'select(.status.resources != null) | .status.resources[] | select(.health.status and .kind != "Deployment" and .kind != "Rollout" and .kind != "Ingress" and .kind != "Service") | "\(.group // ""):\(.kind):\(.name)"')
    if [ "x${resources_to_sync}" == "x" ]; then
        echo "There are no resources to sync"
    else
        echo ${resources_to_sync}
        for resource in ${resources_to_sync}; do
            argocd app wait ${ARGOCD_APP_NAME} --resource $resource --health --sync --timeout 600 --loglevel debug --insecure --auth-token ${ARGOCD_AUTH_TOKEN} --server ${ARGOCD_SERVER}
        done
    fi
  variables:
    SOURCE_PATH: deployment
    GITLAB_RUNNER_TAG: devx-application-gitlab-runner
    ARGOCD_SERVER: "${ARGOCD_NONPROD_SERVER}"
    ARGOCD_AUTH_TOKEN: "${ARGOCD_NONPROD_SHELL_AUTH_TOKEN}"
    ENV: pre1
  extends: ".argocd_sync_resources_dev"
".argocd_sync_resources_dev5":
  stage: configure
  retry:
    max: 2
    when:
    - script_failure
  tags:
  - "${GITLAB_RUNNER_TAG}"
  before_script:
  - echo "Install yq & jq from deploy-stage.yml"
  - apk update
  - apk add jq
  - apk add yq
  - |
    if [ ! -d "$SOURCE_PATH" ]; then
      echo "$SOURCE_PATH directory does not exist. Exiting job successfully."
      exit 0
    fi
    echo "$SOURCE_PATH directory exists. Continuing with deployment."
  - apk update
  - apk add curl
  - curl -sSL -o argocd-linux-amd64 https://github.com/argoproj/argo-cd/releases/download/v2.14.9/argocd-linux-amd64
  - install -m 555 argocd-linux-amd64 /usr/local/bin/argocd
  - rm argocd-linux-amd64
  - argocd version --client
  script:
  - echo "Self Service User Guide - https://fireblocks.atlassian.net/wiki/spaces/RD/pages/1413218873/Self+Service+User+Guide"
  - SVC_NAME=$([ "$SERVICE_NAME" ] && echo $SERVICE_NAME || echo $CI_PROJECT_NAME)
  - echo "Syncing resources for ${SVC_NAME} service"
  - ARGOCD_APP_NAME=$(echo "${SVC_NAME}-${ENV}")
  - echo "Refreshing ${ARGOCD_APP_NAME} application"
  - argocd app get ${ARGOCD_APP_NAME} -owide --refresh --insecure --auth-token ${ARGOCD_AUTH_TOKEN}
    --server ${ARGOCD_SERVER}
  - echo "Syncing ${ARGOCD_APP_NAME} application"
  - |
    if [[ "$STRATEGY" == "canary" ]]; then
      argocd app sync --resource '!*:Rollout:*' --resource '!*:Service:*' --prune ${ARGOCD_APP_NAME} --insecure --auth-token ${ARGOCD_AUTH_TOKEN} --server ${ARGOCD_SERVER}
    elif [[ "$STRATEGY" == "in_place" ]]; then
      argocd app sync --resource '!*:Deployment:*' --resource '!*:Service:*' --prune ${ARGOCD_APP_NAME} --insecure --auth-token ${ARGOCD_AUTH_TOKEN} --server ${ARGOCD_SERVER}
    else
      argocd app sync --prune ${ARGOCD_APP_NAME} --insecure --auth-token ${ARGOCD_AUTH_TOKEN} --server ${ARGOCD_SERVER}
    fi
  - echo "Waiting for ${ARGOCD_APP_NAME} application to be synced and healthy"
  - |
    resources_to_sync=$(argocd app get ${ARGOCD_APP_NAME} --insecure --auth-token ${ARGOCD_AUTH_TOKEN} --server ${ARGOCD_SERVER} -o json | jq -r 'select(.status.resources != null) | .status.resources[] | select(.health.status and .kind != "Deployment" and .kind != "Rollout" and .kind != "Ingress" and .kind != "Service") | "\(.group // ""):\(.kind):\(.name)"')
    if [ "x${resources_to_sync}" == "x" ]; then
        echo "There are no resources to sync"
    else
        echo ${resources_to_sync}
        for resource in ${resources_to_sync}; do
            argocd app wait ${ARGOCD_APP_NAME} --resource $resource --health --sync --timeout 600 --loglevel debug --insecure --auth-token ${ARGOCD_AUTH_TOKEN} --server ${ARGOCD_SERVER}
        done
    fi
  variables:
    SOURCE_PATH: deployment
    GITLAB_RUNNER_TAG: devx-application-gitlab-runner
    ARGOCD_SERVER: "${ARGOCD_NONPROD_SERVER}"
    ARGOCD_AUTH_TOKEN: "${ARGOCD_NONPROD_SHELL_AUTH_TOKEN}"
    ENV: dev5
  extends: ".argocd_sync_resources_dev"
".argocd_sync_resources_dev6":
  stage: configure
  retry:
    max: 2
    when:
    - script_failure
  tags:
  - "${GITLAB_RUNNER_TAG}"
  before_script:
  - echo "Install yq & jq from deploy-stage.yml"
  - apk update
  - apk add jq
  - apk add yq
  - |
    if [ ! -d "$SOURCE_PATH" ]; then
      echo "$SOURCE_PATH directory does not exist. Exiting job successfully."
      exit 0
    fi
    echo "$SOURCE_PATH directory exists. Continuing with deployment."
  - apk update
  - apk add curl
  - curl -sSL -o argocd-linux-amd64 https://github.com/argoproj/argo-cd/releases/download/v2.14.9/argocd-linux-amd64
  - install -m 555 argocd-linux-amd64 /usr/local/bin/argocd
  - rm argocd-linux-amd64
  - argocd version --client
  script:
  - echo "Self Service User Guide - https://fireblocks.atlassian.net/wiki/spaces/RD/pages/1413218873/Self+Service+User+Guide"
  - SVC_NAME=$([ "$SERVICE_NAME" ] && echo $SERVICE_NAME || echo $CI_PROJECT_NAME)
  - echo "Syncing resources for ${SVC_NAME} service"
  - ARGOCD_APP_NAME=$(echo "${SVC_NAME}-${ENV}")
  - echo "Refreshing ${ARGOCD_APP_NAME} application"
  - argocd app get ${ARGOCD_APP_NAME} -owide --refresh --insecure --auth-token ${ARGOCD_AUTH_TOKEN}
    --server ${ARGOCD_SERVER}
  - echo "Syncing ${ARGOCD_APP_NAME} application"
  - |
    if [[ "$STRATEGY" == "canary" ]]; then
      argocd app sync --resource '!*:Rollout:*' --resource '!*:Service:*' --prune ${ARGOCD_APP_NAME} --insecure --auth-token ${ARGOCD_AUTH_TOKEN} --server ${ARGOCD_SERVER}
    elif [[ "$STRATEGY" == "in_place" ]]; then
      argocd app sync --resource '!*:Deployment:*' --resource '!*:Service:*' --prune ${ARGOCD_APP_NAME} --insecure --auth-token ${ARGOCD_AUTH_TOKEN} --server ${ARGOCD_SERVER}
    else
      argocd app sync --prune ${ARGOCD_APP_NAME} --insecure --auth-token ${ARGOCD_AUTH_TOKEN} --server ${ARGOCD_SERVER}
    fi
  - echo "Waiting for ${ARGOCD_APP_NAME} application to be synced and healthy"
  - |
    resources_to_sync=$(argocd app get ${ARGOCD_APP_NAME} --insecure --auth-token ${ARGOCD_AUTH_TOKEN} --server ${ARGOCD_SERVER} -o json | jq -r 'select(.status.resources != null) | .status.resources[] | select(.health.status and .kind != "Deployment" and .kind != "Rollout" and .kind != "Ingress" and .kind != "Service") | "\(.group // ""):\(.kind):\(.name)"')
    if [ "x${resources_to_sync}" == "x" ]; then
        echo "There are no resources to sync"
    else
        echo ${resources_to_sync}
        for resource in ${resources_to_sync}; do
            argocd app wait ${ARGOCD_APP_NAME} --resource $resource --health --sync --timeout 600 --loglevel debug --insecure --auth-token ${ARGOCD_AUTH_TOKEN} --server ${ARGOCD_SERVER}
        done
    fi
  variables:
    SOURCE_PATH: deployment
    GITLAB_RUNNER_TAG: devx-application-gitlab-runner
    ARGOCD_SERVER: "${ARGOCD_NONPROD_SERVER}"
    ARGOCD_AUTH_TOKEN: "${ARGOCD_NONPROD_SHELL_AUTH_TOKEN}"
    ENV: dev6
  extends: ".argocd_sync_resources_dev"
".argocd_sync_resources_dev7":
  stage: configure
  retry:
    max: 2
    when:
    - script_failure
  tags:
  - "${GITLAB_RUNNER_TAG}"
  before_script:
  - echo "Install yq & jq from deploy-stage.yml"
  - apk update
  - apk add jq
  - apk add yq
  - |
    if [ ! -d "$SOURCE_PATH" ]; then
      echo "$SOURCE_PATH directory does not exist. Exiting job successfully."
      exit 0
    fi
    echo "$SOURCE_PATH directory exists. Continuing with deployment."
  - apk update
  - apk add curl
  - curl -sSL -o argocd-linux-amd64 https://github.com/argoproj/argo-cd/releases/download/v2.14.9/argocd-linux-amd64
  - install -m 555 argocd-linux-amd64 /usr/local/bin/argocd
  - rm argocd-linux-amd64
  - argocd version --client
  script:
  - echo "Self Service User Guide - https://fireblocks.atlassian.net/wiki/spaces/RD/pages/1413218873/Self+Service+User+Guide"
  - SVC_NAME=$([ "$SERVICE_NAME" ] && echo $SERVICE_NAME || echo $CI_PROJECT_NAME)
  - echo "Syncing resources for ${SVC_NAME} service"
  - ARGOCD_APP_NAME=$(echo "${SVC_NAME}-${ENV}")
  - echo "Refreshing ${ARGOCD_APP_NAME} application"
  - argocd app get ${ARGOCD_APP_NAME} -owide --refresh --insecure --auth-token ${ARGOCD_AUTH_TOKEN}
    --server ${ARGOCD_SERVER}
  - echo "Syncing ${ARGOCD_APP_NAME} application"
  - |
    if [[ "$STRATEGY" == "canary" ]]; then
      argocd app sync --resource '!*:Rollout:*' --resource '!*:Service:*' --prune ${ARGOCD_APP_NAME} --insecure --auth-token ${ARGOCD_AUTH_TOKEN} --server ${ARGOCD_SERVER}
    elif [[ "$STRATEGY" == "in_place" ]]; then
      argocd app sync --resource '!*:Deployment:*' --resource '!*:Service:*' --prune ${ARGOCD_APP_NAME} --insecure --auth-token ${ARGOCD_AUTH_TOKEN} --server ${ARGOCD_SERVER}
    else
      argocd app sync --prune ${ARGOCD_APP_NAME} --insecure --auth-token ${ARGOCD_AUTH_TOKEN} --server ${ARGOCD_SERVER}
    fi
  - echo "Waiting for ${ARGOCD_APP_NAME} application to be synced and healthy"
  - |
    resources_to_sync=$(argocd app get ${ARGOCD_APP_NAME} --insecure --auth-token ${ARGOCD_AUTH_TOKEN} --server ${ARGOCD_SERVER} -o json | jq -r 'select(.status.resources != null) | .status.resources[] | select(.health.status and .kind != "Deployment" and .kind != "Rollout" and .kind != "Ingress" and .kind != "Service") | "\(.group // ""):\(.kind):\(.name)"')
    if [ "x${resources_to_sync}" == "x" ]; then
        echo "There are no resources to sync"
    else
        echo ${resources_to_sync}
        for resource in ${resources_to_sync}; do
            argocd app wait ${ARGOCD_APP_NAME} --resource $resource --health --sync --timeout 600 --loglevel debug --insecure --auth-token ${ARGOCD_AUTH_TOKEN} --server ${ARGOCD_SERVER}
        done
    fi
  variables:
    SOURCE_PATH: deployment
    GITLAB_RUNNER_TAG: devx-application-gitlab-runner
    ARGOCD_SERVER: "${ARGOCD_NONPROD_SERVER}"
    ARGOCD_AUTH_TOKEN: "${ARGOCD_NONPROD_SHELL_AUTH_TOKEN}"
    ENV: dev7
  extends: ".argocd_sync_resources_dev"
".argocd_sync_resources_dev8":
  stage: configure
  retry:
    max: 2
    when:
    - script_failure
  tags:
  - "${GITLAB_RUNNER_TAG}"
  before_script:
  - echo "Install yq & jq from deploy-stage.yml"
  - apk update
  - apk add jq
  - apk add yq
  - |
    if [ ! -d "$SOURCE_PATH" ]; then
      echo "$SOURCE_PATH directory does not exist. Exiting job successfully."
      exit 0
    fi
    echo "$SOURCE_PATH directory exists. Continuing with deployment."
  - apk update
  - apk add curl
  - curl -sSL -o argocd-linux-amd64 https://github.com/argoproj/argo-cd/releases/download/v2.14.9/argocd-linux-amd64
  - install -m 555 argocd-linux-amd64 /usr/local/bin/argocd
  - rm argocd-linux-amd64
  - argocd version --client
  script:
  - echo "Self Service User Guide - https://fireblocks.atlassian.net/wiki/spaces/RD/pages/1413218873/Self+Service+User+Guide"
  - SVC_NAME=$([ "$SERVICE_NAME" ] && echo $SERVICE_NAME || echo $CI_PROJECT_NAME)
  - echo "Syncing resources for ${SVC_NAME} service"
  - ARGOCD_APP_NAME=$(echo "${SVC_NAME}-${ENV}")
  - echo "Refreshing ${ARGOCD_APP_NAME} application"
  - argocd app get ${ARGOCD_APP_NAME} -owide --refresh --insecure --auth-token ${ARGOCD_AUTH_TOKEN}
    --server ${ARGOCD_SERVER}
  - echo "Syncing ${ARGOCD_APP_NAME} application"
  - |
    if [[ "$STRATEGY" == "canary" ]]; then
      argocd app sync --resource '!*:Rollout:*' --resource '!*:Service:*' --prune ${ARGOCD_APP_NAME} --insecure --auth-token ${ARGOCD_AUTH_TOKEN} --server ${ARGOCD_SERVER}
    elif [[ "$STRATEGY" == "in_place" ]]; then
      argocd app sync --resource '!*:Deployment:*' --resource '!*:Service:*' --prune ${ARGOCD_APP_NAME} --insecure --auth-token ${ARGOCD_AUTH_TOKEN} --server ${ARGOCD_SERVER}
    else
      argocd app sync --prune ${ARGOCD_APP_NAME} --insecure --auth-token ${ARGOCD_AUTH_TOKEN} --server ${ARGOCD_SERVER}
    fi
  - echo "Waiting for ${ARGOCD_APP_NAME} application to be synced and healthy"
  - |
    resources_to_sync=$(argocd app get ${ARGOCD_APP_NAME} --insecure --auth-token ${ARGOCD_AUTH_TOKEN} --server ${ARGOCD_SERVER} -o json | jq -r 'select(.status.resources != null) | .status.resources[] | select(.health.status and .kind != "Deployment" and .kind != "Rollout" and .kind != "Ingress" and .kind != "Service") | "\(.group // ""):\(.kind):\(.name)"')
    if [ "x${resources_to_sync}" == "x" ]; then
        echo "There are no resources to sync"
    else
        echo ${resources_to_sync}
        for resource in ${resources_to_sync}; do
            argocd app wait ${ARGOCD_APP_NAME} --resource $resource --health --sync --timeout 600 --loglevel debug --insecure --auth-token ${ARGOCD_AUTH_TOKEN} --server ${ARGOCD_SERVER}
        done
    fi
  variables:
    SOURCE_PATH: deployment
    GITLAB_RUNNER_TAG: devx-application-gitlab-runner
    ARGOCD_SERVER: "${ARGOCD_NONPROD_SERVER}"
    ARGOCD_AUTH_TOKEN: "${ARGOCD_NONPROD_SHELL_AUTH_TOKEN}"
    ENV: dev8
  extends: ".argocd_sync_resources_dev"
".argocd_sync_resources_dev9":
  stage: configure
  retry:
    max: 2
    when:
    - script_failure
  tags:
  - "${GITLAB_RUNNER_TAG}"
  before_script:
  - echo "Install yq & jq from deploy-stage.yml"
  - apk update
  - apk add jq
  - apk add yq
  - |
    if [ ! -d "$SOURCE_PATH" ]; then
      echo "$SOURCE_PATH directory does not exist. Exiting job successfully."
      exit 0
    fi
    echo "$SOURCE_PATH directory exists. Continuing with deployment."
  - apk update
  - apk add curl
  - curl -sSL -o argocd-linux-amd64 https://github.com/argoproj/argo-cd/releases/download/v2.14.9/argocd-linux-amd64
  - install -m 555 argocd-linux-amd64 /usr/local/bin/argocd
  - rm argocd-linux-amd64
  - argocd version --client
  script:
  - echo "Self Service User Guide - https://fireblocks.atlassian.net/wiki/spaces/RD/pages/1413218873/Self+Service+User+Guide"
  - SVC_NAME=$([ "$SERVICE_NAME" ] && echo $SERVICE_NAME || echo $CI_PROJECT_NAME)
  - echo "Syncing resources for ${SVC_NAME} service"
  - ARGOCD_APP_NAME=$(echo "${SVC_NAME}-${ENV}")
  - echo "Refreshing ${ARGOCD_APP_NAME} application"
  - argocd app get ${ARGOCD_APP_NAME} -owide --refresh --insecure --auth-token ${ARGOCD_AUTH_TOKEN}
    --server ${ARGOCD_SERVER}
  - echo "Syncing ${ARGOCD_APP_NAME} application"
  - |
    if [[ "$STRATEGY" == "canary" ]]; then
      argocd app sync --resource '!*:Rollout:*' --resource '!*:Service:*' --prune ${ARGOCD_APP_NAME} --insecure --auth-token ${ARGOCD_AUTH_TOKEN} --server ${ARGOCD_SERVER}
    elif [[ "$STRATEGY" == "in_place" ]]; then
      argocd app sync --resource '!*:Deployment:*' --resource '!*:Service:*' --prune ${ARGOCD_APP_NAME} --insecure --auth-token ${ARGOCD_AUTH_TOKEN} --server ${ARGOCD_SERVER}
    else
      argocd app sync --prune ${ARGOCD_APP_NAME} --insecure --auth-token ${ARGOCD_AUTH_TOKEN} --server ${ARGOCD_SERVER}
    fi
  - echo "Waiting for ${ARGOCD_APP_NAME} application to be synced and healthy"
  - |
    resources_to_sync=$(argocd app get ${ARGOCD_APP_NAME} --insecure --auth-token ${ARGOCD_AUTH_TOKEN} --server ${ARGOCD_SERVER} -o json | jq -r 'select(.status.resources != null) | .status.resources[] | select(.health.status and .kind != "Deployment" and .kind != "Rollout" and .kind != "Ingress" and .kind != "Service") | "\(.group // ""):\(.kind):\(.name)"')
    if [ "x${resources_to_sync}" == "x" ]; then
        echo "There are no resources to sync"
    else
        echo ${resources_to_sync}
        for resource in ${resources_to_sync}; do
            argocd app wait ${ARGOCD_APP_NAME} --resource $resource --health --sync --timeout 600 --loglevel debug --insecure --auth-token ${ARGOCD_AUTH_TOKEN} --server ${ARGOCD_SERVER}
        done
    fi
  variables:
    SOURCE_PATH: deployment
    GITLAB_RUNNER_TAG: devx-application-gitlab-runner
    ARGOCD_SERVER: "${ARGOCD_NONPROD_SERVER}"
    ARGOCD_AUTH_TOKEN: "${ARGOCD_NONPROD_SHELL_AUTH_TOKEN}"
    ENV: dev9
  extends: ".argocd_sync_resources_dev"
".argocd_sync_resources_dev10":
  stage: configure
  retry:
    max: 2
    when:
    - script_failure
  tags:
  - "${GITLAB_RUNNER_TAG}"
  before_script:
  - echo "Install yq & jq from deploy-stage.yml"
  - apk update
  - apk add jq
  - apk add yq
  - |
    if [ ! -d "$SOURCE_PATH" ]; then
      echo "$SOURCE_PATH directory does not exist. Exiting job successfully."
      exit 0
    fi
    echo "$SOURCE_PATH directory exists. Continuing with deployment."
  - apk update
  - apk add curl
  - curl -sSL -o argocd-linux-amd64 https://github.com/argoproj/argo-cd/releases/download/v2.14.9/argocd-linux-amd64
  - install -m 555 argocd-linux-amd64 /usr/local/bin/argocd
  - rm argocd-linux-amd64
  - argocd version --client
  script:
  - echo "Self Service User Guide - https://fireblocks.atlassian.net/wiki/spaces/RD/pages/1413218873/Self+Service+User+Guide"
  - SVC_NAME=$([ "$SERVICE_NAME" ] && echo $SERVICE_NAME || echo $CI_PROJECT_NAME)
  - echo "Syncing resources for ${SVC_NAME} service"
  - ARGOCD_APP_NAME=$(echo "${SVC_NAME}-${ENV}")
  - echo "Refreshing ${ARGOCD_APP_NAME} application"
  - argocd app get ${ARGOCD_APP_NAME} -owide --refresh --insecure --auth-token ${ARGOCD_AUTH_TOKEN}
    --server ${ARGOCD_SERVER}
  - echo "Syncing ${ARGOCD_APP_NAME} application"
  - |
    if [[ "$STRATEGY" == "canary" ]]; then
      argocd app sync --resource '!*:Rollout:*' --resource '!*:Service:*' --prune ${ARGOCD_APP_NAME} --insecure --auth-token ${ARGOCD_AUTH_TOKEN} --server ${ARGOCD_SERVER}
    elif [[ "$STRATEGY" == "in_place" ]]; then
      argocd app sync --resource '!*:Deployment:*' --resource '!*:Service:*' --prune ${ARGOCD_APP_NAME} --insecure --auth-token ${ARGOCD_AUTH_TOKEN} --server ${ARGOCD_SERVER}
    else
      argocd app sync --prune ${ARGOCD_APP_NAME} --insecure --auth-token ${ARGOCD_AUTH_TOKEN} --server ${ARGOCD_SERVER}
    fi
  - echo "Waiting for ${ARGOCD_APP_NAME} application to be synced and healthy"
  - |
    resources_to_sync=$(argocd app get ${ARGOCD_APP_NAME} --insecure --auth-token ${ARGOCD_AUTH_TOKEN} --server ${ARGOCD_SERVER} -o json | jq -r 'select(.status.resources != null) | .status.resources[] | select(.health.status and .kind != "Deployment" and .kind != "Rollout" and .kind != "Ingress" and .kind != "Service") | "\(.group // ""):\(.kind):\(.name)"')
    if [ "x${resources_to_sync}" == "x" ]; then
        echo "There are no resources to sync"
    else
        echo ${resources_to_sync}
        for resource in ${resources_to_sync}; do
            argocd app wait ${ARGOCD_APP_NAME} --resource $resource --health --sync --timeout 600 --loglevel debug --insecure --auth-token ${ARGOCD_AUTH_TOKEN} --server ${ARGOCD_SERVER}
        done
    fi
  variables:
    SOURCE_PATH: deployment
    GITLAB_RUNNER_TAG: devx-application-gitlab-runner
    ARGOCD_SERVER: "${ARGOCD_NONPROD_SERVER}"
    ARGOCD_AUTH_TOKEN: "${ARGOCD_NONPROD_SHELL_AUTH_TOKEN}"
    ENV: dev10
  extends: ".argocd_sync_resources_dev"
".argocd_sync_resources_dev11":
  stage: configure
  retry:
    max: 2
    when:
    - script_failure
  tags:
  - "${GITLAB_RUNNER_TAG}"
  before_script:
  - echo "Install yq & jq from deploy-stage.yml"
  - apk update
  - apk add jq
  - apk add yq
  - |
    if [ ! -d "$SOURCE_PATH" ]; then
      echo "$SOURCE_PATH directory does not exist. Exiting job successfully."
      exit 0
    fi
    echo "$SOURCE_PATH directory exists. Continuing with deployment."
  - apk update
  - apk add curl
  - curl -sSL -o argocd-linux-amd64 https://github.com/argoproj/argo-cd/releases/download/v2.14.9/argocd-linux-amd64
  - install -m 555 argocd-linux-amd64 /usr/local/bin/argocd
  - rm argocd-linux-amd64
  - argocd version --client
  script:
  - echo "Self Service User Guide - https://fireblocks.atlassian.net/wiki/spaces/RD/pages/1413218873/Self+Service+User+Guide"
  - SVC_NAME=$([ "$SERVICE_NAME" ] && echo $SERVICE_NAME || echo $CI_PROJECT_NAME)
  - echo "Syncing resources for ${SVC_NAME} service"
  - ARGOCD_APP_NAME=$(echo "${SVC_NAME}-${ENV}")
  - echo "Refreshing ${ARGOCD_APP_NAME} application"
  - argocd app get ${ARGOCD_APP_NAME} -owide --refresh --insecure --auth-token ${ARGOCD_AUTH_TOKEN}
    --server ${ARGOCD_SERVER}
  - echo "Syncing ${ARGOCD_APP_NAME} application"
  - |
    if [[ "$STRATEGY" == "canary" ]]; then
      argocd app sync --resource '!*:Rollout:*' --resource '!*:Service:*' --prune ${ARGOCD_APP_NAME} --insecure --auth-token ${ARGOCD_AUTH_TOKEN} --server ${ARGOCD_SERVER}
    elif [[ "$STRATEGY" == "in_place" ]]; then
      argocd app sync --resource '!*:Deployment:*' --resource '!*:Service:*' --prune ${ARGOCD_APP_NAME} --insecure --auth-token ${ARGOCD_AUTH_TOKEN} --server ${ARGOCD_SERVER}
    else
      argocd app sync --prune ${ARGOCD_APP_NAME} --insecure --auth-token ${ARGOCD_AUTH_TOKEN} --server ${ARGOCD_SERVER}
    fi
  - echo "Waiting for ${ARGOCD_APP_NAME} application to be synced and healthy"
  - |
    resources_to_sync=$(argocd app get ${ARGOCD_APP_NAME} --insecure --auth-token ${ARGOCD_AUTH_TOKEN} --server ${ARGOCD_SERVER} -o json | jq -r 'select(.status.resources != null) | .status.resources[] | select(.health.status and .kind != "Deployment" and .kind != "Rollout" and .kind != "Ingress" and .kind != "Service") | "\(.group // ""):\(.kind):\(.name)"')
    if [ "x${resources_to_sync}" == "x" ]; then
        echo "There are no resources to sync"
    else
        echo ${resources_to_sync}
        for resource in ${resources_to_sync}; do
            argocd app wait ${ARGOCD_APP_NAME} --resource $resource --health --sync --timeout 600 --loglevel debug --insecure --auth-token ${ARGOCD_AUTH_TOKEN} --server ${ARGOCD_SERVER}
        done
    fi
  variables:
    SOURCE_PATH: deployment
    GITLAB_RUNNER_TAG: devx-application-gitlab-runner
    ARGOCD_SERVER: "${ARGOCD_NONPROD_SERVER}"
    ARGOCD_AUTH_TOKEN: "${ARGOCD_NONPROD_SHELL_AUTH_TOKEN}"
    ENV: dev11
  extends: ".argocd_sync_resources_dev"
".argocd_sync_resources_dev12":
  stage: configure
  retry:
    max: 2
    when:
    - script_failure
  tags:
  - "${GITLAB_RUNNER_TAG}"
  before_script:
  - echo "Install yq & jq from deploy-stage.yml"
  - apk update
  - apk add jq
  - apk add yq
  - |
    if [ ! -d "$SOURCE_PATH" ]; then
      echo "$SOURCE_PATH directory does not exist. Exiting job successfully."
      exit 0
    fi
    echo "$SOURCE_PATH directory exists. Continuing with deployment."
  - apk update
  - apk add curl
  - curl -sSL -o argocd-linux-amd64 https://github.com/argoproj/argo-cd/releases/download/v2.14.9/argocd-linux-amd64
  - install -m 555 argocd-linux-amd64 /usr/local/bin/argocd
  - rm argocd-linux-amd64
  - argocd version --client
  script:
  - echo "Self Service User Guide - https://fireblocks.atlassian.net/wiki/spaces/RD/pages/1413218873/Self+Service+User+Guide"
  - SVC_NAME=$([ "$SERVICE_NAME" ] && echo $SERVICE_NAME || echo $CI_PROJECT_NAME)
  - echo "Syncing resources for ${SVC_NAME} service"
  - ARGOCD_APP_NAME=$(echo "${SVC_NAME}-${ENV}")
  - echo "Refreshing ${ARGOCD_APP_NAME} application"
  - argocd app get ${ARGOCD_APP_NAME} -owide --refresh --insecure --auth-token ${ARGOCD_AUTH_TOKEN}
    --server ${ARGOCD_SERVER}
  - echo "Syncing ${ARGOCD_APP_NAME} application"
  - |
    if [[ "$STRATEGY" == "canary" ]]; then
      argocd app sync --resource '!*:Rollout:*' --resource '!*:Service:*' --prune ${ARGOCD_APP_NAME} --insecure --auth-token ${ARGOCD_AUTH_TOKEN} --server ${ARGOCD_SERVER}
    elif [[ "$STRATEGY" == "in_place" ]]; then
      argocd app sync --resource '!*:Deployment:*' --resource '!*:Service:*' --prune ${ARGOCD_APP_NAME} --insecure --auth-token ${ARGOCD_AUTH_TOKEN} --server ${ARGOCD_SERVER}
    else
      argocd app sync --prune ${ARGOCD_APP_NAME} --insecure --auth-token ${ARGOCD_AUTH_TOKEN} --server ${ARGOCD_SERVER}
    fi
  - echo "Waiting for ${ARGOCD_APP_NAME} application to be synced and healthy"
  - |
    resources_to_sync=$(argocd app get ${ARGOCD_APP_NAME} --insecure --auth-token ${ARGOCD_AUTH_TOKEN} --server ${ARGOCD_SERVER} -o json | jq -r 'select(.status.resources != null) | .status.resources[] | select(.health.status and .kind != "Deployment" and .kind != "Rollout" and .kind != "Ingress" and .kind != "Service") | "\(.group // ""):\(.kind):\(.name)"')
    if [ "x${resources_to_sync}" == "x" ]; then
        echo "There are no resources to sync"
    else
        echo ${resources_to_sync}
        for resource in ${resources_to_sync}; do
            argocd app wait ${ARGOCD_APP_NAME} --resource $resource --health --sync --timeout 600 --loglevel debug --insecure --auth-token ${ARGOCD_AUTH_TOKEN} --server ${ARGOCD_SERVER}
        done
    fi
  variables:
    SOURCE_PATH: deployment
    GITLAB_RUNNER_TAG: devx-application-gitlab-runner
    ARGOCD_SERVER: "${ARGOCD_NONPROD_SERVER}"
    ARGOCD_AUTH_TOKEN: "${ARGOCD_NONPROD_SHELL_AUTH_TOKEN}"
    ENV: dev12
  extends: ".argocd_sync_resources_dev"
".argocd_sync_resources_dev13":
  stage: configure
  retry:
    max: 2
    when:
    - script_failure
  tags:
  - "${GITLAB_RUNNER_TAG}"
  before_script:
  - echo "Install yq & jq from deploy-stage.yml"
  - apk update
  - apk add jq
  - apk add yq
  - |
    if [ ! -d "$SOURCE_PATH" ]; then
      echo "$SOURCE_PATH directory does not exist. Exiting job successfully."
      exit 0
    fi
    echo "$SOURCE_PATH directory exists. Continuing with deployment."
  - apk update
  - apk add curl
  - curl -sSL -o argocd-linux-amd64 https://github.com/argoproj/argo-cd/releases/download/v2.14.9/argocd-linux-amd64
  - install -m 555 argocd-linux-amd64 /usr/local/bin/argocd
  - rm argocd-linux-amd64
  - argocd version --client
  script:
  - echo "Self Service User Guide - https://fireblocks.atlassian.net/wiki/spaces/RD/pages/1413218873/Self+Service+User+Guide"
  - SVC_NAME=$([ "$SERVICE_NAME" ] && echo $SERVICE_NAME || echo $CI_PROJECT_NAME)
  - echo "Syncing resources for ${SVC_NAME} service"
  - ARGOCD_APP_NAME=$(echo "${SVC_NAME}-${ENV}")
  - echo "Refreshing ${ARGOCD_APP_NAME} application"
  - argocd app get ${ARGOCD_APP_NAME} -owide --refresh --insecure --auth-token ${ARGOCD_AUTH_TOKEN}
    --server ${ARGOCD_SERVER}
  - echo "Syncing ${ARGOCD_APP_NAME} application"
  - |
    if [[ "$STRATEGY" == "canary" ]]; then
      argocd app sync --resource '!*:Rollout:*' --resource '!*:Service:*' --prune ${ARGOCD_APP_NAME} --insecure --auth-token ${ARGOCD_AUTH_TOKEN} --server ${ARGOCD_SERVER}
    elif [[ "$STRATEGY" == "in_place" ]]; then
      argocd app sync --resource '!*:Deployment:*' --resource '!*:Service:*' --prune ${ARGOCD_APP_NAME} --insecure --auth-token ${ARGOCD_AUTH_TOKEN} --server ${ARGOCD_SERVER}
    else
      argocd app sync --prune ${ARGOCD_APP_NAME} --insecure --auth-token ${ARGOCD_AUTH_TOKEN} --server ${ARGOCD_SERVER}
    fi
  - echo "Waiting for ${ARGOCD_APP_NAME} application to be synced and healthy"
  - |
    resources_to_sync=$(argocd app get ${ARGOCD_APP_NAME} --insecure --auth-token ${ARGOCD_AUTH_TOKEN} --server ${ARGOCD_SERVER} -o json | jq -r 'select(.status.resources != null) | .status.resources[] | select(.health.status and .kind != "Deployment" and .kind != "Rollout" and .kind != "Ingress" and .kind != "Service") | "\(.group // ""):\(.kind):\(.name)"')
    if [ "x${resources_to_sync}" == "x" ]; then
        echo "There are no resources to sync"
    else
        echo ${resources_to_sync}
        for resource in ${resources_to_sync}; do
            argocd app wait ${ARGOCD_APP_NAME} --resource $resource --health --sync --timeout 600 --loglevel debug --insecure --auth-token ${ARGOCD_AUTH_TOKEN} --server ${ARGOCD_SERVER}
        done
    fi
  variables:
    SOURCE_PATH: deployment
    GITLAB_RUNNER_TAG: devx-application-gitlab-runner
    ARGOCD_SERVER: "${ARGOCD_NONPROD_SERVER}"
    ARGOCD_AUTH_TOKEN: "${ARGOCD_NONPROD_SHELL_AUTH_TOKEN}"
    ENV: dev13
  extends: ".argocd_sync_resources_dev"
".argocd_sync_resources_dev14":
  stage: configure
  retry:
    max: 2
    when:
    - script_failure
  tags:
  - "${GITLAB_RUNNER_TAG}"
  before_script:
  - echo "Install yq & jq from deploy-stage.yml"
  - apk update
  - apk add jq
  - apk add yq
  - |
    if [ ! -d "$SOURCE_PATH" ]; then
      echo "$SOURCE_PATH directory does not exist. Exiting job successfully."
      exit 0
    fi
    echo "$SOURCE_PATH directory exists. Continuing with deployment."
  - apk update
  - apk add curl
  - curl -sSL -o argocd-linux-amd64 https://github.com/argoproj/argo-cd/releases/download/v2.14.9/argocd-linux-amd64
  - install -m 555 argocd-linux-amd64 /usr/local/bin/argocd
  - rm argocd-linux-amd64
  - argocd version --client
  script:
  - echo "Self Service User Guide - https://fireblocks.atlassian.net/wiki/spaces/RD/pages/1413218873/Self+Service+User+Guide"
  - SVC_NAME=$([ "$SERVICE_NAME" ] && echo $SERVICE_NAME || echo $CI_PROJECT_NAME)
  - echo "Syncing resources for ${SVC_NAME} service"
  - ARGOCD_APP_NAME=$(echo "${SVC_NAME}-${ENV}")
  - echo "Refreshing ${ARGOCD_APP_NAME} application"
  - argocd app get ${ARGOCD_APP_NAME} -owide --refresh --insecure --auth-token ${ARGOCD_AUTH_TOKEN}
    --server ${ARGOCD_SERVER}
  - echo "Syncing ${ARGOCD_APP_NAME} application"
  - |
    if [[ "$STRATEGY" == "canary" ]]; then
      argocd app sync --resource '!*:Rollout:*' --resource '!*:Service:*' --prune ${ARGOCD_APP_NAME} --insecure --auth-token ${ARGOCD_AUTH_TOKEN} --server ${ARGOCD_SERVER}
    elif [[ "$STRATEGY" == "in_place" ]]; then
      argocd app sync --resource '!*:Deployment:*' --resource '!*:Service:*' --prune ${ARGOCD_APP_NAME} --insecure --auth-token ${ARGOCD_AUTH_TOKEN} --server ${ARGOCD_SERVER}
    else
      argocd app sync --prune ${ARGOCD_APP_NAME} --insecure --auth-token ${ARGOCD_AUTH_TOKEN} --server ${ARGOCD_SERVER}
    fi
  - echo "Waiting for ${ARGOCD_APP_NAME} application to be synced and healthy"
  - |
    resources_to_sync=$(argocd app get ${ARGOCD_APP_NAME} --insecure --auth-token ${ARGOCD_AUTH_TOKEN} --server ${ARGOCD_SERVER} -o json | jq -r 'select(.status.resources != null) | .status.resources[] | select(.health.status and .kind != "Deployment" and .kind != "Rollout" and .kind != "Ingress" and .kind != "Service") | "\(.group // ""):\(.kind):\(.name)"')
    if [ "x${resources_to_sync}" == "x" ]; then
        echo "There are no resources to sync"
    else
        echo ${resources_to_sync}
        for resource in ${resources_to_sync}; do
            argocd app wait ${ARGOCD_APP_NAME} --resource $resource --health --sync --timeout 600 --loglevel debug --insecure --auth-token ${ARGOCD_AUTH_TOKEN} --server ${ARGOCD_SERVER}
        done
    fi
  variables:
    SOURCE_PATH: deployment
    GITLAB_RUNNER_TAG: devx-application-gitlab-runner
    ARGOCD_SERVER: "${ARGOCD_NONPROD_SERVER}"
    ARGOCD_AUTH_TOKEN: "${ARGOCD_NONPROD_SHELL_AUTH_TOKEN}"
    ENV: dev14
  extends: ".argocd_sync_resources_dev"
".argocd_sync_resources_dev15":
  stage: configure
  retry:
    max: 2
    when:
    - script_failure
  tags:
  - "${GITLAB_RUNNER_TAG}"
  before_script:
  - echo "Install yq & jq from deploy-stage.yml"
  - apk update
  - apk add jq
  - apk add yq
  - |
    if [ ! -d "$SOURCE_PATH" ]; then
      echo "$SOURCE_PATH directory does not exist. Exiting job successfully."
      exit 0
    fi
    echo "$SOURCE_PATH directory exists. Continuing with deployment."
  - apk update
  - apk add curl
  - curl -sSL -o argocd-linux-amd64 https://github.com/argoproj/argo-cd/releases/download/v2.14.9/argocd-linux-amd64
  - install -m 555 argocd-linux-amd64 /usr/local/bin/argocd
  - rm argocd-linux-amd64
  - argocd version --client
  script:
  - echo "Self Service User Guide - https://fireblocks.atlassian.net/wiki/spaces/RD/pages/1413218873/Self+Service+User+Guide"
  - SVC_NAME=$([ "$SERVICE_NAME" ] && echo $SERVICE_NAME || echo $CI_PROJECT_NAME)
  - echo "Syncing resources for ${SVC_NAME} service"
  - ARGOCD_APP_NAME=$(echo "${SVC_NAME}-${ENV}")
  - echo "Refreshing ${ARGOCD_APP_NAME} application"
  - argocd app get ${ARGOCD_APP_NAME} -owide --refresh --insecure --auth-token ${ARGOCD_AUTH_TOKEN}
    --server ${ARGOCD_SERVER}
  - echo "Syncing ${ARGOCD_APP_NAME} application"
  - |
    if [[ "$STRATEGY" == "canary" ]]; then
      argocd app sync --resource '!*:Rollout:*' --resource '!*:Service:*' --prune ${ARGOCD_APP_NAME} --insecure --auth-token ${ARGOCD_AUTH_TOKEN} --server ${ARGOCD_SERVER}
    elif [[ "$STRATEGY" == "in_place" ]]; then
      argocd app sync --resource '!*:Deployment:*' --resource '!*:Service:*' --prune ${ARGOCD_APP_NAME} --insecure --auth-token ${ARGOCD_AUTH_TOKEN} --server ${ARGOCD_SERVER}
    else
      argocd app sync --prune ${ARGOCD_APP_NAME} --insecure --auth-token ${ARGOCD_AUTH_TOKEN} --server ${ARGOCD_SERVER}
    fi
  - echo "Waiting for ${ARGOCD_APP_NAME} application to be synced and healthy"
  - |
    resources_to_sync=$(argocd app get ${ARGOCD_APP_NAME} --insecure --auth-token ${ARGOCD_AUTH_TOKEN} --server ${ARGOCD_SERVER} -o json | jq -r 'select(.status.resources != null) | .status.resources[] | select(.health.status and .kind != "Deployment" and .kind != "Rollout" and .kind != "Ingress" and .kind != "Service") | "\(.group // ""):\(.kind):\(.name)"')
    if [ "x${resources_to_sync}" == "x" ]; then
        echo "There are no resources to sync"
    else
        echo ${resources_to_sync}
        for resource in ${resources_to_sync}; do
            argocd app wait ${ARGOCD_APP_NAME} --resource $resource --health --sync --timeout 600 --loglevel debug --insecure --auth-token ${ARGOCD_AUTH_TOKEN} --server ${ARGOCD_SERVER}
        done
    fi
  variables:
    SOURCE_PATH: deployment
    GITLAB_RUNNER_TAG: devx-application-gitlab-runner
    ARGOCD_SERVER: "${ARGOCD_NONPROD_SERVER}"
    ARGOCD_AUTH_TOKEN: "${ARGOCD_NONPROD_SHELL_AUTH_TOKEN}"
    ENV: dev15
  extends: ".argocd_sync_resources_dev"
".argocd_sync_resources_prod-us":
  stage: configure
  retry:
    max: 2
    when:
    - script_failure
  tags:
  - "${GITLAB_RUNNER_TAG}"
  before_script:
  - echo "Install yq & jq from deploy-stage.yml"
  - apk update
  - apk add jq
  - apk add yq
  - |
    if [ ! -d "$SOURCE_PATH" ]; then
      echo "$SOURCE_PATH directory does not exist. Exiting job successfully."
      exit 0
    fi
    echo "$SOURCE_PATH directory exists. Continuing with deployment."
  - apk update
  - apk add curl
  - curl -sSL -o argocd-linux-amd64 https://github.com/argoproj/argo-cd/releases/download/v2.14.9/argocd-linux-amd64
  - install -m 555 argocd-linux-amd64 /usr/local/bin/argocd
  - rm argocd-linux-amd64
  - argocd version --client
  script:
  - echo "Self Service User Guide - https://fireblocks.atlassian.net/wiki/spaces/RD/pages/1413218873/Self+Service+User+Guide"
  - SVC_NAME=$([ "$SERVICE_NAME" ] && echo $SERVICE_NAME || echo $CI_PROJECT_NAME)
  - echo "Syncing resources for ${SVC_NAME} service"
  - ARGOCD_APP_NAME=$(echo "${SVC_NAME}-${ENV}")
  - echo "Refreshing ${ARGOCD_APP_NAME} application"
  - argocd app get ${ARGOCD_APP_NAME} -owide --refresh --insecure --auth-token ${ARGOCD_AUTH_TOKEN}
    --server ${ARGOCD_SERVER}
  - echo "Syncing ${ARGOCD_APP_NAME} application"
  - |
    if [[ "$STRATEGY" == "canary" ]]; then
      argocd app sync --resource '!*:Rollout:*' --resource '!*:Service:*' --prune ${ARGOCD_APP_NAME} --insecure --auth-token ${ARGOCD_AUTH_TOKEN} --server ${ARGOCD_SERVER}
    elif [[ "$STRATEGY" == "in_place" ]]; then
      argocd app sync --resource '!*:Deployment:*' --resource '!*:Service:*' --prune ${ARGOCD_APP_NAME} --insecure --auth-token ${ARGOCD_AUTH_TOKEN} --server ${ARGOCD_SERVER}
    else
      argocd app sync --prune ${ARGOCD_APP_NAME} --insecure --auth-token ${ARGOCD_AUTH_TOKEN} --server ${ARGOCD_SERVER}
    fi
  - echo "Waiting for ${ARGOCD_APP_NAME} application to be synced and healthy"
  - |
    resources_to_sync=$(argocd app get ${ARGOCD_APP_NAME} --insecure --auth-token ${ARGOCD_AUTH_TOKEN} --server ${ARGOCD_SERVER} -o json | jq -r 'select(.status.resources != null) | .status.resources[] | select(.health.status and .kind != "Deployment" and .kind != "Rollout" and .kind != "Ingress" and .kind != "Service") | "\(.group // ""):\(.kind):\(.name)"')
    if [ "x${resources_to_sync}" == "x" ]; then
        echo "There are no resources to sync"
    else
        echo ${resources_to_sync}
        for resource in ${resources_to_sync}; do
            argocd app wait ${ARGOCD_APP_NAME} --resource $resource --health --sync --timeout 600 --loglevel debug --insecure --auth-token ${ARGOCD_AUTH_TOKEN} --server ${ARGOCD_SERVER}
        done
    fi
  variables:
    SOURCE_PATH: deployment
    GITLAB_RUNNER_TAG: devx-application-gitlab-runner
    ARGOCD_SERVER: "${ARGOCD_PROD_SERVER}"
    ARGOCD_AUTH_TOKEN: "${ARGOCD_PROD_SHELL_AUTH_TOKEN}"
    ENV: us-prod
  extends: ".argocd_sync_resources_prod"
".argocd_sync_resources_sandbox":
  stage: configure
  retry:
    max: 2
    when:
    - script_failure
  tags:
  - "${GITLAB_RUNNER_TAG}"
  before_script:
  - echo "Install yq & jq from deploy-stage.yml"
  - apk update
  - apk add jq
  - apk add yq
  - |
    if [ ! -d "$SOURCE_PATH" ]; then
      echo "$SOURCE_PATH directory does not exist. Exiting job successfully."
      exit 0
    fi
    echo "$SOURCE_PATH directory exists. Continuing with deployment."
  - apk update
  - apk add curl
  - curl -sSL -o argocd-linux-amd64 https://github.com/argoproj/argo-cd/releases/download/v2.14.9/argocd-linux-amd64
  - install -m 555 argocd-linux-amd64 /usr/local/bin/argocd
  - rm argocd-linux-amd64
  - argocd version --client
  script:
  - echo "Self Service User Guide - https://fireblocks.atlassian.net/wiki/spaces/RD/pages/1413218873/Self+Service+User+Guide"
  - SVC_NAME=$([ "$SERVICE_NAME" ] && echo $SERVICE_NAME || echo $CI_PROJECT_NAME)
  - echo "Syncing resources for ${SVC_NAME} service"
  - ARGOCD_APP_NAME=$(echo "${SVC_NAME}-${ENV}")
  - echo "Refreshing ${ARGOCD_APP_NAME} application"
  - argocd app get ${ARGOCD_APP_NAME} -owide --refresh --insecure --auth-token ${ARGOCD_AUTH_TOKEN}
    --server ${ARGOCD_SERVER}
  - echo "Syncing ${ARGOCD_APP_NAME} application"
  - |
    if [[ "$STRATEGY" == "canary" ]]; then
      argocd app sync --resource '!*:Rollout:*' --resource '!*:Service:*' --prune ${ARGOCD_APP_NAME} --insecure --auth-token ${ARGOCD_AUTH_TOKEN} --server ${ARGOCD_SERVER}
    elif [[ "$STRATEGY" == "in_place" ]]; then
      argocd app sync --resource '!*:Deployment:*' --resource '!*:Service:*' --prune ${ARGOCD_APP_NAME} --insecure --auth-token ${ARGOCD_AUTH_TOKEN} --server ${ARGOCD_SERVER}
    else
      argocd app sync --prune ${ARGOCD_APP_NAME} --insecure --auth-token ${ARGOCD_AUTH_TOKEN} --server ${ARGOCD_SERVER}
    fi
  - echo "Waiting for ${ARGOCD_APP_NAME} application to be synced and healthy"
  - |
    resources_to_sync=$(argocd app get ${ARGOCD_APP_NAME} --insecure --auth-token ${ARGOCD_AUTH_TOKEN} --server ${ARGOCD_SERVER} -o json | jq -r 'select(.status.resources != null) | .status.resources[] | select(.health.status and .kind != "Deployment" and .kind != "Rollout" and .kind != "Ingress" and .kind != "Service") | "\(.group // ""):\(.kind):\(.name)"')
    if [ "x${resources_to_sync}" == "x" ]; then
        echo "There are no resources to sync"
    else
        echo ${resources_to_sync}
        for resource in ${resources_to_sync}; do
            argocd app wait ${ARGOCD_APP_NAME} --resource $resource --health --sync --timeout 600 --loglevel debug --insecure --auth-token ${ARGOCD_AUTH_TOKEN} --server ${ARGOCD_SERVER}
        done
    fi
  variables:
    SOURCE_PATH: deployment
    GITLAB_RUNNER_TAG: devx-application-gitlab-runner
    ARGOCD_SERVER: "${ARGOCD_PROD_SERVER}"
    ARGOCD_AUTH_TOKEN: "${ARGOCD_PROD_SHELL_AUTH_TOKEN}"
    ENV: sandbox
  extends: ".argocd_sync_resources_prod"
".argocd_sync_resources_eu-prod-fr":
  stage: configure
  retry:
    max: 2
    when:
    - script_failure
  tags:
  - "${GITLAB_RUNNER_TAG}"
  before_script:
  - echo "Install yq & jq from deploy-stage.yml"
  - apk update
  - apk add jq
  - apk add yq
  - |
    if [ ! -d "$SOURCE_PATH" ]; then
      echo "$SOURCE_PATH directory does not exist. Exiting job successfully."
      exit 0
    fi
    echo "$SOURCE_PATH directory exists. Continuing with deployment."
  - apk update
  - apk add curl
  - curl -sSL -o argocd-linux-amd64 https://github.com/argoproj/argo-cd/releases/download/v2.14.9/argocd-linux-amd64
  - install -m 555 argocd-linux-amd64 /usr/local/bin/argocd
  - rm argocd-linux-amd64
  - argocd version --client
  script:
  - echo "Self Service User Guide - https://fireblocks.atlassian.net/wiki/spaces/RD/pages/1413218873/Self+Service+User+Guide"
  - SVC_NAME=$([ "$SERVICE_NAME" ] && echo $SERVICE_NAME || echo $CI_PROJECT_NAME)
  - echo "Syncing resources for ${SVC_NAME} service"
  - ARGOCD_APP_NAME=$(echo "${SVC_NAME}-${ENV}")
  - echo "Refreshing ${ARGOCD_APP_NAME} application"
  - argocd app get ${ARGOCD_APP_NAME} -owide --refresh --insecure --auth-token ${ARGOCD_AUTH_TOKEN}
    --server ${ARGOCD_SERVER}
  - echo "Syncing ${ARGOCD_APP_NAME} application"
  - |
    if [[ "$STRATEGY" == "canary" ]]; then
      argocd app sync --resource '!*:Rollout:*' --resource '!*:Service:*' --prune ${ARGOCD_APP_NAME} --insecure --auth-token ${ARGOCD_AUTH_TOKEN} --server ${ARGOCD_SERVER}
    elif [[ "$STRATEGY" == "in_place" ]]; then
      argocd app sync --resource '!*:Deployment:*' --resource '!*:Service:*' --prune ${ARGOCD_APP_NAME} --insecure --auth-token ${ARGOCD_AUTH_TOKEN} --server ${ARGOCD_SERVER}
    else
      argocd app sync --prune ${ARGOCD_APP_NAME} --insecure --auth-token ${ARGOCD_AUTH_TOKEN} --server ${ARGOCD_SERVER}
    fi
  - echo "Waiting for ${ARGOCD_APP_NAME} application to be synced and healthy"
  - |
    resources_to_sync=$(argocd app get ${ARGOCD_APP_NAME} --insecure --auth-token ${ARGOCD_AUTH_TOKEN} --server ${ARGOCD_SERVER} -o json | jq -r 'select(.status.resources != null) | .status.resources[] | select(.health.status and .kind != "Deployment" and .kind != "Rollout" and .kind != "Ingress" and .kind != "Service") | "\(.group // ""):\(.kind):\(.name)"')
    if [ "x${resources_to_sync}" == "x" ]; then
        echo "There are no resources to sync"
    else
        echo ${resources_to_sync}
        for resource in ${resources_to_sync}; do
            argocd app wait ${ARGOCD_APP_NAME} --resource $resource --health --sync --timeout 600 --loglevel debug --insecure --auth-token ${ARGOCD_AUTH_TOKEN} --server ${ARGOCD_SERVER}
        done
    fi
  variables:
    SOURCE_PATH: deployment
    GITLAB_RUNNER_TAG: devx-application-gitlab-runner
    ARGOCD_SERVER: "${ARGOCD_PROD_SERVER}"
    ARGOCD_AUTH_TOKEN: "${ARGOCD_PROD_SHELL_AUTH_TOKEN}"
    ENV: eu-prod
  extends: ".argocd_sync_resources_prod"
".argocd_sync_resources_eu2-prod-fr":
  stage: configure
  retry:
    max: 2
    when:
    - script_failure
  tags:
  - "${GITLAB_RUNNER_TAG}"
  before_script:
  - echo "Install yq & jq from deploy-stage.yml"
  - apk update
  - apk add jq
  - apk add yq
  - |
    if [ ! -d "$SOURCE_PATH" ]; then
      echo "$SOURCE_PATH directory does not exist. Exiting job successfully."
      exit 0
    fi
    echo "$SOURCE_PATH directory exists. Continuing with deployment."
  - apk update
  - apk add curl
  - curl -sSL -o argocd-linux-amd64 https://github.com/argoproj/argo-cd/releases/download/v2.14.9/argocd-linux-amd64
  - install -m 555 argocd-linux-amd64 /usr/local/bin/argocd
  - rm argocd-linux-amd64
  - argocd version --client
  script:
  - echo "Self Service User Guide - https://fireblocks.atlassian.net/wiki/spaces/RD/pages/1413218873/Self+Service+User+Guide"
  - SVC_NAME=$([ "$SERVICE_NAME" ] && echo $SERVICE_NAME || echo $CI_PROJECT_NAME)
  - echo "Syncing resources for ${SVC_NAME} service"
  - ARGOCD_APP_NAME=$(echo "${SVC_NAME}-${ENV}")
  - echo "Refreshing ${ARGOCD_APP_NAME} application"
  - argocd app get ${ARGOCD_APP_NAME} -owide --refresh --insecure --auth-token ${ARGOCD_AUTH_TOKEN}
    --server ${ARGOCD_SERVER}
  - echo "Syncing ${ARGOCD_APP_NAME} application"
  - |
    if [[ "$STRATEGY" == "canary" ]]; then
      argocd app sync --resource '!*:Rollout:*' --resource '!*:Service:*' --prune ${ARGOCD_APP_NAME} --insecure --auth-token ${ARGOCD_AUTH_TOKEN} --server ${ARGOCD_SERVER}
    elif [[ "$STRATEGY" == "in_place" ]]; then
      argocd app sync --resource '!*:Deployment:*' --resource '!*:Service:*' --prune ${ARGOCD_APP_NAME} --insecure --auth-token ${ARGOCD_AUTH_TOKEN} --server ${ARGOCD_SERVER}
    else
      argocd app sync --prune ${ARGOCD_APP_NAME} --insecure --auth-token ${ARGOCD_AUTH_TOKEN} --server ${ARGOCD_SERVER}
    fi
  - echo "Waiting for ${ARGOCD_APP_NAME} application to be synced and healthy"
  - |
    resources_to_sync=$(argocd app get ${ARGOCD_APP_NAME} --insecure --auth-token ${ARGOCD_AUTH_TOKEN} --server ${ARGOCD_SERVER} -o json | jq -r 'select(.status.resources != null) | .status.resources[] | select(.health.status and .kind != "Deployment" and .kind != "Rollout" and .kind != "Ingress" and .kind != "Service") | "\(.group // ""):\(.kind):\(.name)"')
    if [ "x${resources_to_sync}" == "x" ]; then
        echo "There are no resources to sync"
    else
        echo ${resources_to_sync}
        for resource in ${resources_to_sync}; do
            argocd app wait ${ARGOCD_APP_NAME} --resource $resource --health --sync --timeout 600 --loglevel debug --insecure --auth-token ${ARGOCD_AUTH_TOKEN} --server ${ARGOCD_SERVER}
        done
    fi
  variables:
    SOURCE_PATH: deployment
    GITLAB_RUNNER_TAG: devx-application-gitlab-runner
    ARGOCD_SERVER: "${ARGOCD_PROD_SERVER}"
    ARGOCD_AUTH_TOKEN: "${ARGOCD_PROD_SHELL_AUTH_TOKEN}"
    ENV: eu2-prod
  extends: ".argocd_sync_resources_prod"
".argocd_sync_resources_bnym-dev":
  stage: configure
  retry:
    max: 2
    when:
    - script_failure
  tags:
  - "${GITLAB_RUNNER_TAG}"
  before_script:
  - echo "Install yq & jq from deploy-stage.yml"
  - apk update
  - apk add jq
  - apk add yq
  - |
    if [ ! -d "$SOURCE_PATH" ]; then
      echo "$SOURCE_PATH directory does not exist. Exiting job successfully."
      exit 0
    fi
    echo "$SOURCE_PATH directory exists. Continuing with deployment."
  - apk update
  - apk add curl
  - curl -sSL -o argocd-linux-amd64 https://github.com/argoproj/argo-cd/releases/download/v2.14.9/argocd-linux-amd64
  - install -m 555 argocd-linux-amd64 /usr/local/bin/argocd
  - rm argocd-linux-amd64
  - argocd version --client
  script:
  - echo "Self Service User Guide - https://fireblocks.atlassian.net/wiki/spaces/RD/pages/1413218873/Self+Service+User+Guide"
  - SVC_NAME=$([ "$SERVICE_NAME" ] && echo $SERVICE_NAME || echo $CI_PROJECT_NAME)
  - echo "Syncing resources for ${SVC_NAME} service"
  - ARGOCD_APP_NAME=$(echo "${SVC_NAME}-${ENV}")
  - echo "Refreshing ${ARGOCD_APP_NAME} application"
  - argocd app get ${ARGOCD_APP_NAME} -owide --refresh --insecure --auth-token ${ARGOCD_AUTH_TOKEN}
    --server ${ARGOCD_SERVER}
  - echo "Syncing ${ARGOCD_APP_NAME} application"
  - |
    if [[ "$STRATEGY" == "canary" ]]; then
      argocd app sync --resource '!*:Rollout:*' --resource '!*:Service:*' --prune ${ARGOCD_APP_NAME} --insecure --auth-token ${ARGOCD_AUTH_TOKEN} --server ${ARGOCD_SERVER}
    elif [[ "$STRATEGY" == "in_place" ]]; then
      argocd app sync --resource '!*:Deployment:*' --resource '!*:Service:*' --prune ${ARGOCD_APP_NAME} --insecure --auth-token ${ARGOCD_AUTH_TOKEN} --server ${ARGOCD_SERVER}
    else
      argocd app sync --prune ${ARGOCD_APP_NAME} --insecure --auth-token ${ARGOCD_AUTH_TOKEN} --server ${ARGOCD_SERVER}
    fi
  - echo "Waiting for ${ARGOCD_APP_NAME} application to be synced and healthy"
  - |
    resources_to_sync=$(argocd app get ${ARGOCD_APP_NAME} --insecure --auth-token ${ARGOCD_AUTH_TOKEN} --server ${ARGOCD_SERVER} -o json | jq -r 'select(.status.resources != null) | .status.resources[] | select(.health.status and .kind != "Deployment" and .kind != "Rollout" and .kind != "Ingress" and .kind != "Service") | "\(.group // ""):\(.kind):\(.name)"')
    if [ "x${resources_to_sync}" == "x" ]; then
        echo "There are no resources to sync"
    else
        echo ${resources_to_sync}
        for resource in ${resources_to_sync}; do
            argocd app wait ${ARGOCD_APP_NAME} --resource $resource --health --sync --timeout 600 --loglevel debug --insecure --auth-token ${ARGOCD_AUTH_TOKEN} --server ${ARGOCD_SERVER}
        done
    fi
  variables:
    SOURCE_PATH: deployment
    GITLAB_RUNNER_TAG: devx-application-gitlab-runner
    ARGOCD_SERVER: "${ARGOCD_PROD_SERVER}"
    ARGOCD_AUTH_TOKEN: "${ARGOCD_PROD_SHELL_AUTH_TOKEN}"
    ENV: bnym-dev
  extends: ".argocd_sync_resources_prod"
".argocd_sync_resources_bnym-prod":
  stage: configure
  retry:
    max: 2
    when:
    - script_failure
  tags:
  - "${GITLAB_RUNNER_TAG}"
  before_script:
  - echo "Install yq & jq from deploy-stage.yml"
  - apk update
  - apk add jq
  - apk add yq
  - |
    if [ ! -d "$SOURCE_PATH" ]; then
      echo "$SOURCE_PATH directory does not exist. Exiting job successfully."
      exit 0
    fi
    echo "$SOURCE_PATH directory exists. Continuing with deployment."
  - apk update
  - apk add curl
  - curl -sSL -o argocd-linux-amd64 https://github.com/argoproj/argo-cd/releases/download/v2.14.9/argocd-linux-amd64
  - install -m 555 argocd-linux-amd64 /usr/local/bin/argocd
  - rm argocd-linux-amd64
  - argocd version --client
  script:
  - echo "Self Service User Guide - https://fireblocks.atlassian.net/wiki/spaces/RD/pages/1413218873/Self+Service+User+Guide"
  - SVC_NAME=$([ "$SERVICE_NAME" ] && echo $SERVICE_NAME || echo $CI_PROJECT_NAME)
  - echo "Syncing resources for ${SVC_NAME} service"
  - ARGOCD_APP_NAME=$(echo "${SVC_NAME}-${ENV}")
  - echo "Refreshing ${ARGOCD_APP_NAME} application"
  - argocd app get ${ARGOCD_APP_NAME} -owide --refresh --insecure --auth-token ${ARGOCD_AUTH_TOKEN}
    --server ${ARGOCD_SERVER}
  - echo "Syncing ${ARGOCD_APP_NAME} application"
  - |
    if [[ "$STRATEGY" == "canary" ]]; then
      argocd app sync --resource '!*:Rollout:*' --resource '!*:Service:*' --prune ${ARGOCD_APP_NAME} --insecure --auth-token ${ARGOCD_AUTH_TOKEN} --server ${ARGOCD_SERVER}
    elif [[ "$STRATEGY" == "in_place" ]]; then
      argocd app sync --resource '!*:Deployment:*' --resource '!*:Service:*' --prune ${ARGOCD_APP_NAME} --insecure --auth-token ${ARGOCD_AUTH_TOKEN} --server ${ARGOCD_SERVER}
    else
      argocd app sync --prune ${ARGOCD_APP_NAME} --insecure --auth-token ${ARGOCD_AUTH_TOKEN} --server ${ARGOCD_SERVER}
    fi
  - echo "Waiting for ${ARGOCD_APP_NAME} application to be synced and healthy"
  - |
    resources_to_sync=$(argocd app get ${ARGOCD_APP_NAME} --insecure --auth-token ${ARGOCD_AUTH_TOKEN} --server ${ARGOCD_SERVER} -o json | jq -r 'select(.status.resources != null) | .status.resources[] | select(.health.status and .kind != "Deployment" and .kind != "Rollout" and .kind != "Ingress" and .kind != "Service") | "\(.group // ""):\(.kind):\(.name)"')
    if [ "x${resources_to_sync}" == "x" ]; then
        echo "There are no resources to sync"
    else
        echo ${resources_to_sync}
        for resource in ${resources_to_sync}; do
            argocd app wait ${ARGOCD_APP_NAME} --resource $resource --health --sync --timeout 600 --loglevel debug --insecure --auth-token ${ARGOCD_AUTH_TOKEN} --server ${ARGOCD_SERVER}
        done
    fi
  variables:
    SOURCE_PATH: deployment
    GITLAB_RUNNER_TAG: devx-application-gitlab-runner
    ARGOCD_SERVER: "${ARGOCD_PROD_SERVER}"
    ARGOCD_AUTH_TOKEN: "${ARGOCD_PROD_SHELL_AUTH_TOKEN}"
    ENV: bnym-prod
  extends: ".argocd_sync_resources_prod"
set_replicas_sandbox:
  image: registry.gitlab.com/fireblocks/devops/terraform/terraform-runner:v0.5.2
  environment:
    name: "$env"
  after_script:
  - rm -fr /builds/terraform/
  - echo 'Done!'
  variables:
    APP_VERSION: "$IMAGE_TAG"
    JOB: deploy_terragrunt_service_${env}
    TERRAGRUNT_PROJECT: "/builds/terraform/terragrunt/devx/apps/shell-services/${SERVICE_NAME}"
    TERRAFORM_SOURCE: "/builds/terraform/terraform//"
    TERRAGRUNT_BUCKET: fireblocks-terraform-remote-state-${env}
    TERRAGRUNT_ENV: "${env}"
    TERRAGRUNT_LOCK: terraform-state-lock-${env}
    TERRAFORM_REPO_BRANCH: main
    K8S_CLUSTER_NAME: dlg-sandbox-k8s
    AWS_REGION: us-east-2
    TERRAGRUNT_ROLE: arn:aws:iam::751886943440:role/dlg-sandbox-k8s-EKSDevRWAccessRole
    env: sandbox
  extends:
  - ".scale_replicas"
  - ".act_sandbox"
  before_script:
  - apt-get update
  - apt-get install zip unzip
  - cd /builds/
  - rm -fr /builds/terraform/
  - git clone --depth 1 --branch $TERRAFORM_REPO_BRANCH https://gitlab-ci-token:${CI_JOB_TOKEN}@gitlab.com/fireblocks/devops/terraform.git
  - curl "https://awscli.amazonaws.com/awscli-exe-linux-x86_64.zip" -o "awscliv2.zip"
  - unzip -qo awscliv2.zip
  - "./aws/install --update"
  - "$(assume-role.sh ${TERRAGRUNT_ROLE} gitlab-runner)"
  - echo ${TERRAGRUNT_PROJECT}
  - cd ${TERRAGRUNT_PROJECT}
  - curl -LO https://storage.googleapis.com/kubernetes-release/release/$(curl -s https://storage.googleapis.com/kubernetes-release/release/stable.txt)/bin/linux/amd64/kubectl
  - chmod +x ./kubectl && mv ./kubectl /usr/local/bin/kubectl
  - mkdir -p $HOME/.kube
  - aws eks update-kubeconfig --region ${AWS_REGION} --name ${K8S_CLUSTER_NAME}
  script:
  - echo ${SERVICE_NAME} ${IMAGE_TAG} ${CI_ENVIRONMENT_NAME}
  - kubectl get deployments ${SERVICE_NAME} -n $env
  - |
    if [ -z $NUM_OF_REPLICAS ]; then
      echo "NUM_OF_REPLICAS variable is not defined"
    else
      kubectl scale deployment ${SERVICE_NAME} --replicas=${NUM_OF_REPLICAS} -n $env
    fi
  - kubectl get deployments ${SERVICE_NAME} -n $env
  tags:
  - sandbox
  stage: manual-override
  needs: []
  rules:
  - if: $IS_PROD_SERVICE != "true"
    when: never
  - if: ($CI_COMMIT_BRANCH == "master" || $CI_COMMIT_BRANCH == "main")
    when: manual
    allow_failure: true
set_replicas_eu:
  image: registry.gitlab.com/fireblocks/devops/terraform/terraform-runner:v0.5.2
  environment:
    name: "$env"
  after_script:
  - rm -fr /builds/terraform/
  - echo 'Done!'
  variables:
    APP_VERSION: "$IMAGE_TAG"
    JOB: deploy_terragrunt_service_${env}
    TERRAGRUNT_PROJECT: "/builds/terraform/terragrunt/devx/apps/shell-services/${SERVICE_NAME}"
    TERRAFORM_SOURCE: "/builds/terraform/terraform//"
    TERRAGRUNT_BUCKET: fireblocks-terraform-remote-state-${env}
    TERRAGRUNT_ENV: "${env}"
    TERRAGRUNT_LOCK: terraform-state-lock-${env}
    TERRAFORM_REPO_BRANCH: main
    AWS_REGION: eu-central-1
    TERRAGRUNT_ROLE: arn:aws:iam::455399297295:role/eu-prod-fr-shell-EKSDevRWAccessRole
    env: eu-prod
    K8S_CLUSTER_NAME: eu-prod
  extends:
  - ".scale_replicas"
  - ".act_eu"
  before_script:
  - apt-get update
  - apt-get install zip unzip
  - cd /builds/
  - rm -fr /builds/terraform/
  - git clone --depth 1 --branch $TERRAFORM_REPO_BRANCH https://gitlab-ci-token:${CI_JOB_TOKEN}@gitlab.com/fireblocks/devops/terraform.git
  - curl "https://awscli.amazonaws.com/awscli-exe-linux-x86_64.zip" -o "awscliv2.zip"
  - unzip -qo awscliv2.zip
  - "./aws/install --update"
  - "$(assume-role.sh ${TERRAGRUNT_ROLE} gitlab-runner)"
  - echo ${TERRAGRUNT_PROJECT}
  - cd ${TERRAGRUNT_PROJECT}
  - curl -LO https://storage.googleapis.com/kubernetes-release/release/$(curl -s https://storage.googleapis.com/kubernetes-release/release/stable.txt)/bin/linux/amd64/kubectl
  - chmod +x ./kubectl && mv ./kubectl /usr/local/bin/kubectl
  - mkdir -p $HOME/.kube
  - aws eks update-kubeconfig --region ${AWS_REGION} --name ${K8S_CLUSTER_NAME}
  script:
  - echo ${SERVICE_NAME} ${IMAGE_TAG} ${CI_ENVIRONMENT_NAME}
  - kubectl get deployments ${SERVICE_NAME} -n $env
  - |
    if [ -z $NUM_OF_REPLICAS ]; then
      echo "NUM_OF_REPLICAS variable is not defined"
    else
      kubectl scale deployment ${SERVICE_NAME} --replicas=${NUM_OF_REPLICAS} -n $env
    fi
  - kubectl get deployments ${SERVICE_NAME} -n $env
  tags:
  - eu-prod-fr
  stage: manual-override
  needs: []
  rules:
  - if: $IS_PROD_SERVICE != "true"
    when: never
  - if: ($CI_COMMIT_BRANCH == "master" || $CI_COMMIT_BRANCH == "main")
    when: manual
    allow_failure: true
set_replicas_eu2:
  image: registry.gitlab.com/fireblocks/devops/terraform/terraform-runner:v0.5.2
  environment:
    name: "$env"
  after_script:
  - rm -fr /builds/terraform/
  - echo 'Done!'
  variables:
    APP_VERSION: "$IMAGE_TAG"
    JOB: deploy_terragrunt_service_${env}
    TERRAGRUNT_PROJECT: "/builds/terraform/terragrunt/devx/apps/shell-services/${SERVICE_NAME}"
    TERRAFORM_SOURCE: "/builds/terraform/terraform//"
    TERRAGRUNT_BUCKET: fireblocks-terraform-remote-state-${env}
    TERRAGRUNT_ENV: "${env}"
    TERRAGRUNT_LOCK: terraform-state-lock-${env}
    TERRAFORM_REPO_BRANCH: main
    AWS_REGION: eu-central-1
    TERRAGRUNT_ROLE: arn:aws:iam::803035224331:role/eu2-prod-fr-shell-EKSDevRWAccessRole
    env: eu2-prod
    K8S_CLUSTER_NAME: eu2-prod
  extends:
  - ".scale_replicas"
  - ".act_eu2"
  before_script:
  - apt-get update
  - apt-get install zip unzip
  - cd /builds/
  - rm -fr /builds/terraform/
  - git clone --depth 1 --branch $TERRAFORM_REPO_BRANCH https://gitlab-ci-token:${CI_JOB_TOKEN}@gitlab.com/fireblocks/devops/terraform.git
  - curl "https://awscli.amazonaws.com/awscli-exe-linux-x86_64.zip" -o "awscliv2.zip"
  - unzip -qo awscliv2.zip
  - "./aws/install --update"
  - "$(assume-role.sh ${TERRAGRUNT_ROLE} gitlab-runner)"
  - echo ${TERRAGRUNT_PROJECT}
  - cd ${TERRAGRUNT_PROJECT}
  - curl -LO https://storage.googleapis.com/kubernetes-release/release/$(curl -s https://storage.googleapis.com/kubernetes-release/release/stable.txt)/bin/linux/amd64/kubectl
  - chmod +x ./kubectl && mv ./kubectl /usr/local/bin/kubectl
  - mkdir -p $HOME/.kube
  - aws eks update-kubeconfig --region ${AWS_REGION} --name ${K8S_CLUSTER_NAME}
  script:
  - echo ${SERVICE_NAME} ${IMAGE_TAG} ${CI_ENVIRONMENT_NAME}
  - kubectl get deployments ${SERVICE_NAME} -n $env
  - |
    if [ -z $NUM_OF_REPLICAS ]; then
      echo "NUM_OF_REPLICAS variable is not defined"
    else
      kubectl scale deployment ${SERVICE_NAME} --replicas=${NUM_OF_REPLICAS} -n $env
    fi
  - kubectl get deployments ${SERVICE_NAME} -n $env
  tags:
  - eu2-prod-fr
  stage: manual-override
  needs: []
  rules:
  - if: $IS_PROD_SERVICE != "true"
    when: never
  - if: ($CI_COMMIT_BRANCH == "master" || $CI_COMMIT_BRANCH == "main")
    when: manual
    allow_failure: true
set_replicas_bnym-dev:
  image: registry.gitlab.com/fireblocks/devops/terraform/terraform-runner:v0.5.2
  environment:
    name: "$env"
  after_script:
  - rm -fr /builds/terraform/
  - echo 'Done!'
  variables:
    APP_VERSION: "$IMAGE_TAG"
    JOB: deploy_terragrunt_service_${env}
    TERRAGRUNT_PROJECT: "/builds/terraform/terragrunt/devx/apps/shell-services/${SERVICE_NAME}"
    TERRAFORM_SOURCE: "/builds/terraform/terraform//"
    TERRAGRUNT_BUCKET: fireblocks-terraform-remote-state-${env}
    TERRAGRUNT_ENV: "${env}"
    TERRAGRUNT_LOCK: terraform-state-lock-${env}
    TERRAFORM_REPO_BRANCH: main
    AWS_REGION: us-east-2
    TERRAGRUNT_ROLE: arn:aws:iam::414623400063:role/useast2-bnym-dev-sh-k8s-EKSDevRWAccessRole
    env: bnym-dev-shell
    K8S_CLUSTER_NAME: bnym-dev-shell
  extends:
  - ".scale_replicas"
  - ".act_bnym-dev"
  before_script:
  - apt-get update
  - apt-get install zip unzip
  - cd /builds/
  - rm -fr /builds/terraform/
  - git clone --depth 1 --branch $TERRAFORM_REPO_BRANCH https://gitlab-ci-token:${CI_JOB_TOKEN}@gitlab.com/fireblocks/devops/terraform.git
  - curl "https://awscli.amazonaws.com/awscli-exe-linux-x86_64.zip" -o "awscliv2.zip"
  - unzip -qo awscliv2.zip
  - "./aws/install --update"
  - "$(assume-role.sh ${TERRAGRUNT_ROLE} gitlab-runner)"
  - echo ${TERRAGRUNT_PROJECT}
  - cd ${TERRAGRUNT_PROJECT}
  - curl -LO https://storage.googleapis.com/kubernetes-release/release/$(curl -s https://storage.googleapis.com/kubernetes-release/release/stable.txt)/bin/linux/amd64/kubectl
  - chmod +x ./kubectl && mv ./kubectl /usr/local/bin/kubectl
  - mkdir -p $HOME/.kube
  - aws eks update-kubeconfig --region ${AWS_REGION} --name ${K8S_CLUSTER_NAME}
  script:
  - echo ${SERVICE_NAME} ${IMAGE_TAG} ${CI_ENVIRONMENT_NAME}
  - kubectl get deployments ${SERVICE_NAME} -n $env
  - |
    if [ -z $NUM_OF_REPLICAS ]; then
      echo "NUM_OF_REPLICAS variable is not defined"
    else
      kubectl scale deployment ${SERVICE_NAME} --replicas=${NUM_OF_REPLICAS} -n $env
    fi
  - kubectl get deployments ${SERVICE_NAME} -n $env
  tags:
  - bnym-dev
  stage: manual-override
  needs: []
  rules:
  - if: $IS_PROD_SERVICE != "true"
    when: never
  - if: ($CI_COMMIT_BRANCH == "master" || $CI_COMMIT_BRANCH == "main")
    when: manual
    allow_failure: true
get_deployment_data_sandbox:
  image: registry.gitlab.com/fireblocks/devops/terraform/terraform-runner:v0.5.2
  environment:
    name: "$env"
  after_script:
  - rm -fr /builds/terraform/
  - echo 'Done!'
  variables:
    APP_VERSION: "$IMAGE_TAG"
    JOB: deploy_terragrunt_service_${env}
    TERRAGRUNT_PROJECT: "/builds/terraform/terragrunt/devx/apps/shell-services/${SERVICE_NAME}"
    TERRAFORM_SOURCE: "/builds/terraform/terraform//"
    TERRAGRUNT_BUCKET: fireblocks-terraform-remote-state-${env}
    TERRAGRUNT_ENV: "${env}"
    TERRAGRUNT_LOCK: terraform-state-lock-${env}
    TERRAFORM_REPO_BRANCH: main
    K8S_CLUSTER_NAME: dlg-sandbox-k8s
    AWS_REGION: us-east-2
    TERRAGRUNT_ROLE: arn:aws:iam::751886943440:role/dlg-sandbox-k8s-EKSDevRWAccessRole
    env: sandbox
  extends:
  - ".get_deployment_data"
  - ".act_sandbox"
  before_script:
  - apt-get update
  - apt-get install zip unzip
  - cd /builds/
  - rm -fr /builds/terraform/
  - git clone --depth 1 --branch $TERRAFORM_REPO_BRANCH https://gitlab-ci-token:${CI_JOB_TOKEN}@gitlab.com/fireblocks/devops/terraform.git
  - curl "https://awscli.amazonaws.com/awscli-exe-linux-x86_64.zip" -o "awscliv2.zip"
  - unzip -qo awscliv2.zip
  - "./aws/install --update"
  - "$(assume-role.sh ${TERRAGRUNT_ROLE} gitlab-runner)"
  - echo ${TERRAGRUNT_PROJECT}
  - cd ${TERRAGRUNT_PROJECT}
  - curl -LO https://storage.googleapis.com/kubernetes-release/release/$(curl -s https://storage.googleapis.com/kubernetes-release/release/stable.txt)/bin/linux/amd64/kubectl
  - chmod +x ./kubectl && mv ./kubectl /usr/local/bin/kubectl
  - mkdir -p $HOME/.kube
  - aws eks update-kubeconfig --region ${AWS_REGION} --name ${K8S_CLUSTER_NAME}
  script:
  - echo ${SERVICE_NAME} ${IMAGE_TAG} ${CI_ENVIRONMENT_NAME}
  - kubectl get deployments ${SERVICE_NAME} -n $env
  tags:
  - sandbox
  stage: manual-override
  needs: []
  rules:
  - if: $IS_PROD_SERVICE != "true"
    when: never
  - if: ($CI_COMMIT_BRANCH == "master" || $CI_COMMIT_BRANCH == "main")
    when: manual
    allow_failure: true
manual:docker-stop-ProdUS:
  tags:
  - "$RUNNER_NAME"
  environment:
    name: "${ENVIRONMENT_NAME}"
  script:
  - echo "stopping ${SERVICE_NAME} on ${RUNNER_NAME}"
  - docker stop ${SERVICE_NAME} || /bin/true
  stage: manual-override
  needs: []
  extends: ".docker_stop"
  rules:
  - if: $CI_COMMIT_BRANCH == "master" || $CI_COMMIT_BRANCH == "main"
    when: manual
    allow_failure: true
  variables:
    ENVIRONMENT_NAME: production
  parallel:
    matrix:
    - RUNNER_NAME: prod-services-1
    - RUNNER_NAME: prod-services-2
    - RUNNER_NAME: prod-services-3
    - RUNNER_NAME: prod-services-4
    - RUNNER_NAME: prod-services-5
    - RUNNER_NAME: prod-services-6
    - RUNNER_NAME: prod-services-7
    - RUNNER_NAME: prod-services-8
    - RUNNER_NAME: prod-services-9
    - RUNNER_NAME: prod-services-10
    - RUNNER_NAME: prod-services-11
    - RUNNER_NAME: prod-services-12
    - RUNNER_NAME: prod-services-13
    - RUNNER_NAME: prod-services-14
    - RUNNER_NAME: prod-services-15
    - RUNNER_NAME: prod-services-16
    - RUNNER_NAME: prod-services-17
    - RUNNER_NAME: prod-services-18
    - RUNNER_NAME: prod-services-19
    - RUNNER_NAME: prod-services-20
    - RUNNER_NAME: prod-services-21
    - RUNNER_NAME: prod-services-22
    - RUNNER_NAME: prod-services-23
    - RUNNER_NAME: prod-services-24
    - RUNNER_NAME: prod-services-25
    - RUNNER_NAME: prod-services-26
    - RUNNER_NAME: prod-services-27
    - RUNNER_NAME: prod-services-28
    - RUNNER_NAME: prod-services-29
    - RUNNER_NAME: prod-services-30
    - RUNNER_NAME: prod-services-31
    - RUNNER_NAME: prod-services-32
    - RUNNER_NAME: prod-services-33
    - RUNNER_NAME: prod-services-34
    - RUNNER_NAME: prod-services-35
    - RUNNER_NAME: prod-services-36
    - RUNNER_NAME: prod-services-37
    - RUNNER_NAME: prod-services-38
    - RUNNER_NAME: prod-services-39
    - RUNNER_NAME: prod-services-40
    - RUNNER_NAME: prod-services-41
    - RUNNER_NAME: prod-services-42
    - RUNNER_NAME: prod-services-43
    - RUNNER_NAME: prod-services-44
    - RUNNER_NAME: prod-services-45
    - RUNNER_NAME: prod-services-46
    - RUNNER_NAME: prod-services-47
    - RUNNER_NAME: prod-services-48
    - RUNNER_NAME: prod-services-49
    - RUNNER_NAME: prod-services-50
    - RUNNER_NAME: prod-services-51
    - RUNNER_NAME: prod-services-51
    - RUNNER_NAME: prod-services-52
    - RUNNER_NAME: prod-services-53
    - RUNNER_NAME: prod-services-54
    - RUNNER_NAME: prod-services-55
    - RUNNER_NAME: prod-services-56
    - RUNNER_NAME: prod-services-57
    - RUNNER_NAME: prod-services-58
    - RUNNER_NAME: prod-services-59
manual:docker-stop-Pre1:
  tags:
  - "$RUNNER_NAME"
  environment:
    name: "${ENVIRONMENT_NAME}"
  script:
  - echo "stopping ${SERVICE_NAME} on ${RUNNER_NAME}"
  - docker stop ${SERVICE_NAME} || /bin/true
  extends: ".docker_stop"
  stage: manual-override
  needs: []
  rules:
  - if: $CI_COMMIT_BRANCH == "master" || $CI_COMMIT_BRANCH == "main"
    when: manual
    allow_failure: true
  variables:
    ENVIRONMENT_NAME: pre1
    RUNNER_NAME: pre1-services-1
manual:deploy_prod-sandbox:
  image: registry.gitlab.com/fireblocks/devops/terraform/terraform-runner:v0.5.2
  stage: manual-override
  after_script:
  - rm -fr /builds/terraform/
  - echo 'Done!'
  before_script:
  - apt-get update
  - apt-get install -y curl
  - curl -fsSL https://deb.nodesource.com/setup_18.x | bash -
  - apt install -y nodejs
  - npm install -g yarn
  - touch .npmrc
  - npm config set --location=user @fireblocks:registry https://gitlab.com/api/v4/packages/npm/
  - npm config set --location=user '//gitlab.com/api/v4/packages/npm/:_authToken'
    "${NPM_REG_TOKEN}"
  - npm config set --location=user '//gitlab.com/api/v4/projects/20565764/packages/npm/:_authToken'
    "${NPM_REG_TOKEN}"
  - echo "@fireblocks:registry=https://gitlab.com/api/v4/packages/npm/">>.npmrc
  - echo "//gitlab.com/api/v4/packages/npm/:_authToken=${NPM_REG_TOKEN}">>.npmrc
  - echo "//gitlab.com/api/v4/projects/20565764/packages/npm/:_authToken=${NPM_REG_TOKEN}">>.npmrc
  - yarn global add @fireblocks/fb-cli
  - echo "validating configuration diffs in case it's a quick-rollback deployment"
  - cd /builds/
  - rm -fr /builds/terraform/
  - git clone --depth 1 --branch $TERRAFORM_REPO_BRANCH https://gitlab-ci-token:${CI_JOB_TOKEN}@gitlab.com/fireblocks/devops/terraform.git
  - "$(assume-role.sh ${TERRAGRUNT_ROLE} gitlab-runner)"
  - echo ${TERRAGRUNT_PROJECT}
  - echo looking for ${CI_PROJECT_DIR}/configurations/${TERRAGRUNT_ENV}.yaml
  - echo looking for ${CI_PROJECT_DIR}/configurations/${TERRAGRUNT_ENV}.${SERVICE_NAME}.yaml
  - if [[ ${COPY_CONFIG}="true" && -f ${CI_PROJECT_DIR}/configurations/ ]]; then ls
    ${CI_PROJECT_DIR}/configurations/ ; fi
  - if [[ ${COPY_CONFIG}="true" && -f ${CI_PROJECT_DIR}/configurations/${TERRAGRUNT_ENV}.yaml
    ]] ; then cp ${CI_PROJECT_DIR}/configurations/${TERRAGRUNT_ENV}.yaml ${TERRAGRUNT_PROJECT}/${TERRAGRUNT_ENV}.yaml
    ; fi
  - if [[ ${COPY_CONFIG}="true" && -f ${CI_PROJECT_DIR}/configurations/${TERRAGRUNT_ENV}/env.yaml
    ]] ; then cp ${CI_PROJECT_DIR}/configurations/${TERRAGRUNT_ENV}/env.yaml ${TERRAGRUNT_PROJECT}/${TERRAGRUNT_ENV}/env.yaml
    ; fi
  - if [[ ${COPY_CONFIG}="true" && -f ${CI_PROJECT_DIR}/configurations/${TERRAGRUNT_ENV}.${SERVICE_NAME}.yaml
    ]] ; then cp ${CI_PROJECT_DIR}/configurations/${TERRAGRUNT_ENV}.${SERVICE_NAME}.yaml
    ${TERRAGRUNT_PROJECT}/${TERRAGRUNT_ENV}.yaml ; fi
  - cd ${TERRAGRUNT_PROJECT}
  script:
  - echo ${SERVICE_NAME} ${IMAGE_TAG} ${CI_ENVIRONMENT_NAME} TERRAGRUNT_ENV:${TERRAGRUNT_ENV}
  - terragrunt init
  - terragrunt apply --auto-approve --var service_tag=${IMAGE_TAG}
  environment:
    name: "$env"
  variables:
    APP_VERSION: "$IMAGE_TAG"
    JOB: deploy_terragrunt_service_${TERRAGRUNT_ENV}
    TERRAGRUNT_PROJECT: "/builds/terraform/terragrunt/devx/apps/shell-services/${SERVICE_NAME}"
    TERRAFORM_SOURCE: "/builds/terraform/terraform//"
    TERRAGRUNT_BUCKET: fireblocks-terraform-remote-state-${TERRAGRUNT_ENV}
    TERRAGRUNT_LOCK: terraform-state-lock-${TERRAGRUNT_ENV}
    TERRAFORM_REPO_BRANCH: main
    GITLAB_TOKEN: "${ARGOCD_GITLAB_ACCESS_TOKEN}"
    DIFF_FILE: "${CI_PROJECT_DIR}/config_diff.txt"
    AWS_REGION: us-east-2
    TERRAGRUNT_ROLE: arn:aws:iam::751886943440:role/dlg-sandbox-k8s-EKSDevRWAccessRole
    TERRAGRUNT_ENV: sandbox
    env: sandbox
  artifacts:
    paths:
    - "${CI_PROJECT_DIR}/config_diff.txt"
    when: on_failure
  extends: ".deploy_sandbox:after_build"
  tags:
  - sandbox
  needs:
  - job: build-image
  - job: manual:config_sandbox
    optional: true
  rules:
  - if: $IS_PROD_SERVICE != "true"
    when: never
  - if: $CI_COMMIT_BRANCH == "master" || $CI_COMMIT_BRANCH == "main"
    when: manual
    allow_failure: true
manual:deploy_eu-prod-fr:
  image: registry.gitlab.com/fireblocks/devops/terraform/terraform-runner:v0.5.2
  stage: manual-override
  after_script:
  - rm -fr /builds/terraform/
  - echo 'Done!'
  before_script:
  - apt-get update
  - apt-get install -y curl
  - curl -fsSL https://deb.nodesource.com/setup_18.x | bash -
  - apt install -y nodejs
  - npm install -g yarn
  - touch .npmrc
  - npm config set --location=user @fireblocks:registry https://gitlab.com/api/v4/packages/npm/
  - npm config set --location=user '//gitlab.com/api/v4/packages/npm/:_authToken'
    "${NPM_REG_TOKEN}"
  - npm config set --location=user '//gitlab.com/api/v4/projects/20565764/packages/npm/:_authToken'
    "${NPM_REG_TOKEN}"
  - echo "@fireblocks:registry=https://gitlab.com/api/v4/packages/npm/">>.npmrc
  - echo "//gitlab.com/api/v4/packages/npm/:_authToken=${NPM_REG_TOKEN}">>.npmrc
  - echo "//gitlab.com/api/v4/projects/20565764/packages/npm/:_authToken=${NPM_REG_TOKEN}">>.npmrc
  - yarn global add @fireblocks/fb-cli
  - echo "validating configuration diffs in case it's a quick-rollback deployment"
  - cd /builds/
  - rm -fr /builds/terraform/
  - git clone --depth 1 --branch $TERRAFORM_REPO_BRANCH https://gitlab-ci-token:${CI_JOB_TOKEN}@gitlab.com/fireblocks/devops/terraform.git
  - "$(assume-role.sh ${TERRAGRUNT_ROLE} gitlab-runner)"
  - echo ${TERRAGRUNT_PROJECT}
  - echo looking for ${CI_PROJECT_DIR}/configurations/${TERRAGRUNT_ENV}.yaml
  - echo looking for ${CI_PROJECT_DIR}/configurations/${TERRAGRUNT_ENV}.${SERVICE_NAME}.yaml
  - if [[ ${COPY_CONFIG}="true" && -f ${CI_PROJECT_DIR}/configurations/ ]]; then ls
    ${CI_PROJECT_DIR}/configurations/ ; fi
  - if [[ ${COPY_CONFIG}="true" && -f ${CI_PROJECT_DIR}/configurations/${TERRAGRUNT_ENV}.yaml
    ]] ; then cp ${CI_PROJECT_DIR}/configurations/${TERRAGRUNT_ENV}.yaml ${TERRAGRUNT_PROJECT}/${TERRAGRUNT_ENV}.yaml
    ; fi
  - if [[ ${COPY_CONFIG}="true" && -f ${CI_PROJECT_DIR}/configurations/${TERRAGRUNT_ENV}/env.yaml
    ]] ; then cp ${CI_PROJECT_DIR}/configurations/${TERRAGRUNT_ENV}/env.yaml ${TERRAGRUNT_PROJECT}/${TERRAGRUNT_ENV}/env.yaml
    ; fi
  - if [[ ${COPY_CONFIG}="true" && -f ${CI_PROJECT_DIR}/configurations/${TERRAGRUNT_ENV}.${SERVICE_NAME}.yaml
    ]] ; then cp ${CI_PROJECT_DIR}/configurations/${TERRAGRUNT_ENV}.${SERVICE_NAME}.yaml
    ${TERRAGRUNT_PROJECT}/${TERRAGRUNT_ENV}.yaml ; fi
  - cd ${TERRAGRUNT_PROJECT}
  script:
  - echo ${SERVICE_NAME} ${IMAGE_TAG} ${CI_ENVIRONMENT_NAME} TERRAGRUNT_ENV:${TERRAGRUNT_ENV}
  - terragrunt init
  - terragrunt apply --auto-approve --var service_tag=${IMAGE_TAG}
  environment:
    name: "$env"
  variables:
    APP_VERSION: "$IMAGE_TAG"
    JOB: deploy_terragrunt_service_${TERRAGRUNT_ENV}
    TERRAGRUNT_PROJECT: "/builds/terraform/terragrunt/devx/apps/shell-services/${SERVICE_NAME}"
    TERRAFORM_SOURCE: "/builds/terraform/terraform//"
    TERRAGRUNT_BUCKET: fireblocks-terraform-remote-state-${TERRAGRUNT_ENV}
    TERRAGRUNT_LOCK: terraform-state-lock-${TERRAGRUNT_ENV}
    TERRAFORM_REPO_BRANCH: main
    GITLAB_TOKEN: "${ARGOCD_GITLAB_ACCESS_TOKEN}"
    DIFF_FILE: "${CI_PROJECT_DIR}/config_diff.txt"
    AWS_REGION: eu-central-1
    TERRAGRUNT_ROLE: arn:aws:iam::455399297295:role/eu-prod-fr-shell-EKSDevRWAccessRole
    TERRAGRUNT_ENV: eu-prod-fr
    env: eu-prod
  artifacts:
    paths:
    - "${CI_PROJECT_DIR}/config_diff.txt"
    when: on_failure
  extends: ".deploy_eu-prod-fr:after_build"
  tags:
  - eu-prod-fr
  needs:
  - job: build-image
  - job: manual:config_eu-prod-fr
    optional: true
  rules:
  - if: $IS_PROD_SERVICE != "true"
    when: never
  - if: $CI_COMMIT_BRANCH == "master" || $CI_COMMIT_BRANCH == "main"
    when: manual
    allow_failure: true
manual:deploy_eu2-prod-fr:
  image: registry.gitlab.com/fireblocks/devops/terraform/terraform-runner:v0.5.2
  stage: manual-override
  after_script:
  - rm -fr /builds/terraform/
  - echo 'Done!'
  before_script:
  - apt-get update
  - apt-get install -y curl
  - curl -fsSL https://deb.nodesource.com/setup_18.x | bash -
  - apt install -y nodejs
  - npm install -g yarn
  - touch .npmrc
  - npm config set --location=user @fireblocks:registry https://gitlab.com/api/v4/packages/npm/
  - npm config set --location=user '//gitlab.com/api/v4/packages/npm/:_authToken'
    "${NPM_REG_TOKEN}"
  - npm config set --location=user '//gitlab.com/api/v4/projects/20565764/packages/npm/:_authToken'
    "${NPM_REG_TOKEN}"
  - echo "@fireblocks:registry=https://gitlab.com/api/v4/packages/npm/">>.npmrc
  - echo "//gitlab.com/api/v4/packages/npm/:_authToken=${NPM_REG_TOKEN}">>.npmrc
  - echo "//gitlab.com/api/v4/projects/20565764/packages/npm/:_authToken=${NPM_REG_TOKEN}">>.npmrc
  - yarn global add @fireblocks/fb-cli
  - echo "validating configuration diffs in case it's a quick-rollback deployment"
  - cd /builds/
  - rm -fr /builds/terraform/
  - git clone --depth 1 --branch $TERRAFORM_REPO_BRANCH https://gitlab-ci-token:${CI_JOB_TOKEN}@gitlab.com/fireblocks/devops/terraform.git
  - "$(assume-role.sh ${TERRAGRUNT_ROLE} gitlab-runner)"
  - echo ${TERRAGRUNT_PROJECT}
  - echo looking for ${CI_PROJECT_DIR}/configurations/${TERRAGRUNT_ENV}.yaml
  - echo looking for ${CI_PROJECT_DIR}/configurations/${TERRAGRUNT_ENV}.${SERVICE_NAME}.yaml
  - if [[ ${COPY_CONFIG}="true" && -f ${CI_PROJECT_DIR}/configurations/ ]]; then ls
    ${CI_PROJECT_DIR}/configurations/ ; fi
  - if [[ ${COPY_CONFIG}="true" && -f ${CI_PROJECT_DIR}/configurations/${TERRAGRUNT_ENV}.yaml
    ]] ; then cp ${CI_PROJECT_DIR}/configurations/${TERRAGRUNT_ENV}.yaml ${TERRAGRUNT_PROJECT}/${TERRAGRUNT_ENV}.yaml
    ; fi
  - if [[ ${COPY_CONFIG}="true" && -f ${CI_PROJECT_DIR}/configurations/${TERRAGRUNT_ENV}/env.yaml
    ]] ; then cp ${CI_PROJECT_DIR}/configurations/${TERRAGRUNT_ENV}/env.yaml ${TERRAGRUNT_PROJECT}/${TERRAGRUNT_ENV}/env.yaml
    ; fi
  - if [[ ${COPY_CONFIG}="true" && -f ${CI_PROJECT_DIR}/configurations/${TERRAGRUNT_ENV}.${SERVICE_NAME}.yaml
    ]] ; then cp ${CI_PROJECT_DIR}/configurations/${TERRAGRUNT_ENV}.${SERVICE_NAME}.yaml
    ${TERRAGRUNT_PROJECT}/${TERRAGRUNT_ENV}.yaml ; fi
  - cd ${TERRAGRUNT_PROJECT}
  script:
  - echo ${SERVICE_NAME} ${IMAGE_TAG} ${CI_ENVIRONMENT_NAME} TERRAGRUNT_ENV:${TERRAGRUNT_ENV}
  - terragrunt init
  - terragrunt apply --auto-approve --var service_tag=${IMAGE_TAG}
  environment:
    name: "$env"
  variables:
    APP_VERSION: "$IMAGE_TAG"
    JOB: deploy_terragrunt_service_${TERRAGRUNT_ENV}
    TERRAGRUNT_PROJECT: "/builds/terraform/terragrunt/devx/apps/shell-services/${SERVICE_NAME}"
    TERRAFORM_SOURCE: "/builds/terraform/terraform//"
    TERRAGRUNT_BUCKET: fireblocks-terraform-remote-state-${TERRAGRUNT_ENV}
    TERRAGRUNT_LOCK: terraform-state-lock-${TERRAGRUNT_ENV}
    TERRAFORM_REPO_BRANCH: main
    GITLAB_TOKEN: "${ARGOCD_GITLAB_ACCESS_TOKEN}"
    DIFF_FILE: "${CI_PROJECT_DIR}/config_diff.txt"
    AWS_REGION: eu-central-1
    TERRAGRUNT_ROLE: arn:aws:iam::803035224331:role/eu2-prod-fr-shell-EKSDevRWAccessRole
    TERRAGRUNT_ENV: eu2-prod-fr-shell
    env: eu2-prod
  artifacts:
    paths:
    - "${CI_PROJECT_DIR}/config_diff.txt"
    when: on_failure
  extends: ".deploy_eu2-prod-fr:after_build"
  tags:
  - eu2-prod-fr
  needs:
  - job: build-image
  - job: manual:config_eu2-prod-fr
    optional: true
  rules:
  - if: $IS_PROD_SERVICE != "true"
    when: never
  - if: $CI_COMMIT_BRANCH == "master" || $CI_COMMIT_BRANCH == "main"
    when: manual
    allow_failure: true
manual:deploy_bnym-dev:
  image: registry.gitlab.com/fireblocks/devops/terraform/terraform-runner:v0.5.2
  stage: manual-override
  after_script:
  - rm -fr /builds/terraform/
  - echo 'Done!'
  before_script:
  - apt-get update
  - apt-get install -y curl
  - curl -fsSL https://deb.nodesource.com/setup_18.x | bash -
  - apt install -y nodejs
  - npm install -g yarn
  - touch .npmrc
  - npm config set --location=user @fireblocks:registry https://gitlab.com/api/v4/packages/npm/
  - npm config set --location=user '//gitlab.com/api/v4/packages/npm/:_authToken'
    "${NPM_REG_TOKEN}"
  - npm config set --location=user '//gitlab.com/api/v4/projects/20565764/packages/npm/:_authToken'
    "${NPM_REG_TOKEN}"
  - echo "@fireblocks:registry=https://gitlab.com/api/v4/packages/npm/">>.npmrc
  - echo "//gitlab.com/api/v4/packages/npm/:_authToken=${NPM_REG_TOKEN}">>.npmrc
  - echo "//gitlab.com/api/v4/projects/20565764/packages/npm/:_authToken=${NPM_REG_TOKEN}">>.npmrc
  - yarn global add @fireblocks/fb-cli
  - echo "validating configuration diffs in case it's a quick-rollback deployment"
  - cd /builds/
  - rm -fr /builds/terraform/
  - git clone --depth 1 --branch $TERRAFORM_REPO_BRANCH https://gitlab-ci-token:${CI_JOB_TOKEN}@gitlab.com/fireblocks/devops/terraform.git
  - "$(assume-role.sh ${TERRAGRUNT_ROLE} gitlab-runner)"
  - echo ${TERRAGRUNT_PROJECT}
  - echo looking for ${CI_PROJECT_DIR}/configurations/${TERRAGRUNT_ENV}.yaml
  - echo looking for ${CI_PROJECT_DIR}/configurations/${TERRAGRUNT_ENV}.${SERVICE_NAME}.yaml
  - if [[ ${COPY_CONFIG}="true" && -f ${CI_PROJECT_DIR}/configurations/ ]]; then ls
    ${CI_PROJECT_DIR}/configurations/ ; fi
  - if [[ ${COPY_CONFIG}="true" && -f ${CI_PROJECT_DIR}/configurations/${TERRAGRUNT_ENV}.yaml
    ]] ; then cp ${CI_PROJECT_DIR}/configurations/${TERRAGRUNT_ENV}.yaml ${TERRAGRUNT_PROJECT}/${TERRAGRUNT_ENV}.yaml
    ; fi
  - if [[ ${COPY_CONFIG}="true" && -f ${CI_PROJECT_DIR}/configurations/${TERRAGRUNT_ENV}/env.yaml
    ]] ; then cp ${CI_PROJECT_DIR}/configurations/${TERRAGRUNT_ENV}/env.yaml ${TERRAGRUNT_PROJECT}/${TERRAGRUNT_ENV}/env.yaml
    ; fi
  - if [[ ${COPY_CONFIG}="true" && -f ${CI_PROJECT_DIR}/configurations/${TERRAGRUNT_ENV}.${SERVICE_NAME}.yaml
    ]] ; then cp ${CI_PROJECT_DIR}/configurations/${TERRAGRUNT_ENV}.${SERVICE_NAME}.yaml
    ${TERRAGRUNT_PROJECT}/${TERRAGRUNT_ENV}.yaml ; fi
  - cd ${TERRAGRUNT_PROJECT}
  script:
  - echo ${SERVICE_NAME} ${IMAGE_TAG} ${CI_ENVIRONMENT_NAME} TERRAGRUNT_ENV:${TERRAGRUNT_ENV}
  - terragrunt init
  - terragrunt apply --auto-approve --var service_tag=${IMAGE_TAG}
  environment:
    name: "$env"
  variables:
    APP_VERSION: "$IMAGE_TAG"
    JOB: deploy_terragrunt_service_${TERRAGRUNT_ENV}
    TERRAGRUNT_PROJECT: "/builds/terraform/terragrunt/devx/apps/shell-services/${SERVICE_NAME}"
    TERRAFORM_SOURCE: "/builds/terraform/terraform//"
    TERRAGRUNT_BUCKET: fireblocks-terraform-remote-state-${TERRAGRUNT_ENV}
    TERRAGRUNT_LOCK: terraform-state-lock-${TERRAGRUNT_ENV}
    TERRAFORM_REPO_BRANCH: main
    GITLAB_TOKEN: "${ARGOCD_GITLAB_ACCESS_TOKEN}"
    DIFF_FILE: "${CI_PROJECT_DIR}/config_diff.txt"
    AWS_REGION: us-east-2
    TERRAGRUNT_ROLE: arn:aws:iam::414623400063:role/useast2-bnym-dev-sh-k8s-EKSDevRWAccessRole
    TERRAGRUNT_ENV: bnym-dev-shell
    env: bnym-dev
  artifacts:
    paths:
    - "${CI_PROJECT_DIR}/config_diff.txt"
    when: on_failure
  extends: ".deploy_bnym-dev-shell:after_build"
  tags:
  - bnym-dev
  needs:
  - job: build-image
  - job: manual:config_bnym-dev
    optional: true
  rules:
  - if: $IS_PROD_SERVICE != "true"
    when: never
  - if: $CI_COMMIT_BRANCH == "master" || $CI_COMMIT_BRANCH == "main"
    when: manual
    allow_failure: true
".deploy_prod_us_manual":
  stage: manual-override
  allow_failure: false
  before_script:
  - ''
  variables:
    DOCKER_STOP_TIMEOUT: 5
  script:
  - echo ${SERVICE_NAME} ${IMAGE_TAG} ${CI_ENVIRONMENT_NAME}
  - echo "started docker login $(date +"%T")"
  - docker login -u gitlab-ci-token -p $CI_JOB_TOKEN $CI_REGISTRY
  - echo "finished docker login $(date +"%T")"
  - echo "/secrets/${DOCKER_COMPOSE_PATH_PROD_US}"
  - if [ ! -f /secrets/${DOCKER_COMPOSE_PATH_PROD_US} ]; then echo "Missing docker-compose
    file /secrets/${DOCKER_COMPOSE_PATH_PROD_US}" && exit; fi
  - echo "Started docker compose pull $(date +"%T")";
  - docker-compose -f /secrets/${DOCKER_COMPOSE_PATH_PROD_US} pull;
  - echo "Finished docker compose pull $(date +"%T")";
  - echo "started docker-compose down $(date +"%T")"
  - docker-compose -f /secrets/${DOCKER_COMPOSE_PATH_PROD_US} -p $CONTAINER_NAME down
    -t $DOCKER_STOP_TIMEOUT
  - echo "finished docker-compose down $(date +"%T")"
  - echo $DOCKER_COMPOSE_PATH_PROD_US $DOCKER_STOP_TIMEOUT $CONTAINER_NAME
  - while [[ "$(docker ps --format '{{.Names}}' --filter name=${CONTAINER_NAME})"
    == "${CONTAINER_NAME}" ]]; do sleep 1; done;
  - echo "started docker compose up $(date +"%T")"
  - docker-compose -f /secrets/${DOCKER_COMPOSE_PATH_PROD_US} -p $CONTAINER_NAME up
    -d
  - echo "finished docker compose up $(date +"%T")"
  - echo "started docker rmi execution $(date +"%T")"
  - echo "${CI_REGISTRY_IMAGE}"
  - "(docker images ${CI_REGISTRY_IMAGE}/ci_build/* -q | xargs docker rmi -f) || /bin/true"
  - echo "finished docker rmi execution $(date +"%T")"
  extends: ".deploy_prod_us_common"
  tags:
  - "$RUNNER_NAME"
  needs:
  - job: build-image
  - job: manual:config_prod-us
    optional: true
  rules:
  - if: $IS_PROD_SERVICE != "true"
    when: never
  - if: $CI_COMMIT_BRANCH == "master" || $CI_COMMIT_BRANCH == "main"
    when: manual
    allow_failure: true
manual:deploy_prod-US:
  stage: manual-override
  allow_failure: false
  before_script:
  - ''
  variables:
    DOCKER_STOP_TIMEOUT: 5
  script:
  - echo ${SERVICE_NAME} ${IMAGE_TAG} ${CI_ENVIRONMENT_NAME}
  - echo "started docker login $(date +"%T")"
  - docker login -u gitlab-ci-token -p $CI_JOB_TOKEN $CI_REGISTRY
  - echo "finished docker login $(date +"%T")"
  - echo "/secrets/${DOCKER_COMPOSE_PATH_PROD_US}"
  - if [ ! -f /secrets/${DOCKER_COMPOSE_PATH_PROD_US} ]; then echo "Missing docker-compose
    file /secrets/${DOCKER_COMPOSE_PATH_PROD_US}" && exit; fi
  - echo "Started docker compose pull $(date +"%T")";
  - docker-compose -f /secrets/${DOCKER_COMPOSE_PATH_PROD_US} pull;
  - echo "Finished docker compose pull $(date +"%T")";
  - echo "started docker-compose down $(date +"%T")"
  - docker-compose -f /secrets/${DOCKER_COMPOSE_PATH_PROD_US} -p $CONTAINER_NAME down
    -t $DOCKER_STOP_TIMEOUT
  - echo "finished docker-compose down $(date +"%T")"
  - echo $DOCKER_COMPOSE_PATH_PROD_US $DOCKER_STOP_TIMEOUT $CONTAINER_NAME
  - while [[ "$(docker ps --format '{{.Names}}' --filter name=${CONTAINER_NAME})"
    == "${CONTAINER_NAME}" ]]; do sleep 1; done;
  - echo "started docker compose up $(date +"%T")"
  - docker-compose -f /secrets/${DOCKER_COMPOSE_PATH_PROD_US} -p $CONTAINER_NAME up
    -d
  - echo "finished docker compose up $(date +"%T")"
  - echo "started docker rmi execution $(date +"%T")"
  - echo "${CI_REGISTRY_IMAGE}"
  - "(docker images ${CI_REGISTRY_IMAGE}/ci_build/* -q | xargs docker rmi -f) || /bin/true"
  - echo "finished docker rmi execution $(date +"%T")"
  extends: ".deploy_prod_us_manual"
  tags:
  - "$RUNNER_NAME"
  needs:
  - job: build-image
  - job: manual:config_prod-us
    optional: true
  rules:
  - if: $IS_PROD_SERVICE != "true"
    when: never
  - if: $CI_COMMIT_BRANCH == "master" || $CI_COMMIT_BRANCH == "main"
    when: manual
    allow_failure: true
  parallel:
    matrix:
    - RUNNER_NAME: prod-services-1
    - RUNNER_NAME: prod-services-2
    - RUNNER_NAME: prod-services-3
    - RUNNER_NAME: prod-services-4
    - RUNNER_NAME: prod-services-5
    - RUNNER_NAME: prod-services-6
    - RUNNER_NAME: prod-services-7
    - RUNNER_NAME: prod-services-8
    - RUNNER_NAME: prod-services-9
    - RUNNER_NAME: prod-services-10
    - RUNNER_NAME: prod-services-11
    - RUNNER_NAME: prod-services-12
    - RUNNER_NAME: prod-services-13
    - RUNNER_NAME: prod-services-14
    - RUNNER_NAME: prod-services-15
    - RUNNER_NAME: prod-services-16
    - RUNNER_NAME: prod-services-17
    - RUNNER_NAME: prod-services-18
    - RUNNER_NAME: prod-services-19
    - RUNNER_NAME: prod-services-20
    - RUNNER_NAME: prod-services-21
    - RUNNER_NAME: prod-services-22
    - RUNNER_NAME: prod-services-23
    - RUNNER_NAME: prod-services-24
    - RUNNER_NAME: prod-services-25
    - RUNNER_NAME: prod-services-26
    - RUNNER_NAME: prod-services-27
    - RUNNER_NAME: prod-services-28
    - RUNNER_NAME: prod-services-29
    - RUNNER_NAME: prod-services-30
    - RUNNER_NAME: prod-services-31
    - RUNNER_NAME: prod-services-32
    - RUNNER_NAME: prod-services-33
    - RUNNER_NAME: prod-services-34
    - RUNNER_NAME: prod-services-35
    - RUNNER_NAME: prod-services-36
    - RUNNER_NAME: prod-services-37
    - RUNNER_NAME: prod-services-38
    - RUNNER_NAME: prod-services-39
    - RUNNER_NAME: prod-services-40
    - RUNNER_NAME: prod-services-41
    - RUNNER_NAME: prod-services-42
    - RUNNER_NAME: prod-services-43
    - RUNNER_NAME: prod-services-44
    - RUNNER_NAME: prod-services-45
    - RUNNER_NAME: prod-services-46
    - RUNNER_NAME: prod-services-47
    - RUNNER_NAME: prod-services-48
    - RUNNER_NAME: prod-services-49
    - RUNNER_NAME: prod-services-50
    - RUNNER_NAME: prod-services-51
    - RUNNER_NAME: prod-services-52
    - RUNNER_NAME: prod-services-53
    - RUNNER_NAME: prod-services-54
    - RUNNER_NAME: prod-services-55
    - RUNNER_NAME: prod-services-56
    - RUNNER_NAME: prod-services-57
    - RUNNER_NAME: prod-services-58
    - RUNNER_NAME: prod-services-59
".manual:config":
  stage: manual-override
  needs: []
  rules:
  - if: $IS_PROD_SERVICE != "true"
    when: never
  - if: ($CI_COMMIT_BRANCH == "master" || $CI_COMMIT_BRANCH == "main") && $CI_CONFIG_MANAGEMENT_ENABLED
      == "true"
    when: manual
    allow_failure: true
manual:config_prod-us:
  image: registry.gitlab.com/fireblocks/devops/terraform/terraform-runner:v0.5.4
  retry: 2
  rules:
  - if: $IS_PROD_SERVICE != "true"
    when: never
  - if: ($CI_COMMIT_BRANCH == "master" || $CI_COMMIT_BRANCH == "main") && $CI_CONFIG_MANAGEMENT_ENABLED
      == "true"
    when: manual
    allow_failure: true
  tags:
  - dev-common-runner
  after_script:
  - rm -fr /builds/terraform/
  - echo 'Done!'
  before_script:
  - apt install unzip
  - curl "https://awscli.amazonaws.com/awscli-exe-linux-x86_64.zip" -o "awscliv2.zip"
  - unzip -q awscliv2.zip
  - "./aws/install"
  - cd /builds/
  - |
    yq --version || (echo "please install yq" && exit 1)
    json_list="["
    if [[ -f "${CUSTOM_PARAM_LIST}" ]]; then
      for custom_config in $(cat $CUSTOM_PARAM_LIST | jq -c '.[]'); do
        config_prefix=$(echo $custom_config | jq -r '.prefix' | envsubst)
        config_path=$(echo $custom_config | jq -r '.path' | envsubst)
        if yq -e $config_path; then
          json_list="${json_list}
          {
            \"prefix\": \"${config_prefix}\",
            \"path\": \"${config_path}\"
          },"
        fi
      done
    else
      if [ -f $COMMON_FILE_PATH ]; then
        json_list="${json_list}
        {
          \"prefix\": \"/${ENV_NAME}/${SERVICE_NAME}/common\",
          \"path\": \"${COMMON_FILE_PATH}\"
        },"
      fi
      if yq -e $ENV_FILE_PATH; then
        json_list="${json_list}
        {
          \"prefix\": \"/${ENV_NAME}/${SERVICE_NAME}\",
          \"path\": \"${ENV_FILE_PATH}\"
        },"
      fi
    fi
    json_list="${json_list%?}]"
    export PARAMS_LIST=${json_list}
    echo "PARAMS_LIST: ${PARAMS_LIST}"
  - rm -fr /builds/terraform/
  - git clone https://gitlab-ci-token:${CI_JOB_TOKEN}@gitlab.com/fireblocks/devops/terraform.git
  - cd /builds/terraform
  - "$(python3 switch-devx-env.py us-prod-legacy)"
  - echo ${TERRAGRUNT_PROJECT}
  - cd ${TERRAGRUNT_PROJECT}
  script:
  - echo ${SERVICE_NAME} ${IMAGE_TAG} ${CI_ENVIRONMENT_NAME}
  - terragrunt apply --auto-approve --terragrunt-non-interactive --var "parameter_files=${PARAMS_LIST}"
  variables:
    TERRAGRUNT_PROJECT: "/builds/terraform/terragrunt/devx/parameter-store"
    COMMON_FILE_PATH: "${CI_PROJECT_DIR}/configurations/common/parameters.yaml"
    ENV_FILE_PATH: "${CI_PROJECT_DIR}/configurations/${ENV_NAME}/parameters.yaml"
    CUSTOM_PARAM_LIST: "${CI_PROJECT_DIR}/configurations/custom-param-configuration.json"
    AWS_REGION: us-east-2
    ENV_NAME: prod-us
  extends:
  - ".config_prod-us"
  - ".manual:config"
  stage: manual-override
  needs: []
manual:config_sandbox:
  image: registry.gitlab.com/fireblocks/devops/terraform/terraform-runner:v0.5.4
  retry: 2
  rules:
  - if: $IS_PROD_SERVICE != "true"
    when: never
  - if: ($CI_COMMIT_BRANCH == "master" || $CI_COMMIT_BRANCH == "main") && $CI_CONFIG_MANAGEMENT_ENABLED
      == "true"
    when: manual
    allow_failure: true
  after_script:
  - rm -fr /builds/terraform/
  - echo 'Done!'
  before_script:
  - cd /builds/
  - |
    yq --version || (echo "please install yq" && exit 1)
    json_list="["
    if [[ -f "${CUSTOM_PARAM_LIST}" ]]; then
      for custom_config in $(cat $CUSTOM_PARAM_LIST | jq -c '.[]'); do
        config_prefix=$(echo $custom_config | jq -r '.prefix' | envsubst)
        config_path=$(echo $custom_config | jq -r '.path' | envsubst)
        if yq -e $config_path; then
          json_list="${json_list}
          {
            \"prefix\": \"${config_prefix}\",
            \"path\": \"${config_path}\"
          },"
        fi
      done
    else
      if [ -f $COMMON_FILE_PATH ]; then
        json_list="${json_list}
        {
          \"prefix\": \"/${ENV_NAME}/${SERVICE_NAME}/common\",
          \"path\": \"${COMMON_FILE_PATH}\"
        },"
      fi
      if yq -e $ENV_FILE_PATH; then
        json_list="${json_list}
        {
          \"prefix\": \"/${ENV_NAME}/${SERVICE_NAME}\",
          \"path\": \"${ENV_FILE_PATH}\"
        },"
      fi
    fi
    json_list="${json_list%?}]"
    export PARAMS_LIST=${json_list}
    echo "PARAMS_LIST: ${PARAMS_LIST}"
  - rm -fr /builds/terraform/
  - git clone https://gitlab-ci-token:${CI_JOB_TOKEN}@gitlab.com/fireblocks/devops/terraform.git
  - "$(assume-role.sh ${TERRAGRUNT_ROLE} gitlab-runner)"
  - cd /builds/terraform
  - "$(python3 switch-devx-env.py ${TERRAFORM_ENV_NAME})"
  - echo ${TERRAGRUNT_PROJECT}
  - cd ${TERRAGRUNT_PROJECT}
  script:
  - echo ${SERVICE_NAME} ${IMAGE_TAG} ${CI_ENVIRONMENT_NAME}
  - terragrunt apply --auto-approve --terragrunt-non-interactive --var "parameter_files=${PARAMS_LIST}"
  variables:
    TERRAGRUNT_PROJECT: "/builds/terraform/terragrunt/devx/parameter-store"
    TERRAFORM_ENV_NAME: "${ENV_NAME}"
    COMMON_FILE_PATH: "${CI_PROJECT_DIR}/configurations/common/parameters.yaml"
    ENV_FILE_PATH: "${CI_PROJECT_DIR}/configurations/${ENV_NAME}/parameters.yaml"
    CUSTOM_PARAM_LIST: "${CI_PROJECT_DIR}/configurations/custom-param-configuration.json"
    AWS_REGION: us-east-2
    TERRAGRUNT_ROLE: arn:aws:iam::751886943440:role/gitlab-runner-parameter-store-role
    ENV_NAME: sandbox
  extends:
  - ".config_sandbox"
  - ".manual:config"
  tags:
  - shared-sandbox
  stage: manual-override
  needs: []
manual:config_eu-prod-fr:
  image: registry.gitlab.com/fireblocks/devops/terraform/terraform-runner:v0.5.4
  retry: 2
  rules:
  - if: $IS_PROD_SERVICE != "true"
    when: never
  - if: ($CI_COMMIT_BRANCH == "master" || $CI_COMMIT_BRANCH == "main") && $CI_CONFIG_MANAGEMENT_ENABLED
      == "true"
    when: manual
    allow_failure: true
  after_script:
  - rm -fr /builds/terraform/
  - echo 'Done!'
  before_script:
  - cd /builds/
  - |
    yq --version || (echo "please install yq" && exit 1)
    json_list="["
    if [[ -f "${CUSTOM_PARAM_LIST}" ]]; then
      for custom_config in $(cat $CUSTOM_PARAM_LIST | jq -c '.[]'); do
        config_prefix=$(echo $custom_config | jq -r '.prefix' | envsubst)
        config_path=$(echo $custom_config | jq -r '.path' | envsubst)
        if yq -e $config_path; then
          json_list="${json_list}
          {
            \"prefix\": \"${config_prefix}\",
            \"path\": \"${config_path}\"
          },"
        fi
      done
    else
      if [ -f $COMMON_FILE_PATH ]; then
        json_list="${json_list}
        {
          \"prefix\": \"/${ENV_NAME}/${SERVICE_NAME}/common\",
          \"path\": \"${COMMON_FILE_PATH}\"
        },"
      fi
      if yq -e $ENV_FILE_PATH; then
        json_list="${json_list}
        {
          \"prefix\": \"/${ENV_NAME}/${SERVICE_NAME}\",
          \"path\": \"${ENV_FILE_PATH}\"
        },"
      fi
    fi
    json_list="${json_list%?}]"
    export PARAMS_LIST=${json_list}
    echo "PARAMS_LIST: ${PARAMS_LIST}"
  - rm -fr /builds/terraform/
  - git clone https://gitlab-ci-token:${CI_JOB_TOKEN}@gitlab.com/fireblocks/devops/terraform.git
  - "$(assume-role.sh ${TERRAGRUNT_ROLE} gitlab-runner)"
  - cd /builds/terraform
  - "$(python3 switch-devx-env.py ${TERRAFORM_ENV_NAME})"
  - echo ${TERRAGRUNT_PROJECT}
  - cd ${TERRAGRUNT_PROJECT}
  script:
  - echo ${SERVICE_NAME} ${IMAGE_TAG} ${CI_ENVIRONMENT_NAME}
  - terragrunt apply --auto-approve --terragrunt-non-interactive --var "parameter_files=${PARAMS_LIST}"
  variables:
    TERRAGRUNT_PROJECT: "/builds/terraform/terragrunt/devx/parameter-store"
    TERRAFORM_ENV_NAME: eu-prod-fr
    COMMON_FILE_PATH: "${CI_PROJECT_DIR}/configurations/common/parameters.yaml"
    ENV_FILE_PATH: "${CI_PROJECT_DIR}/configurations/${ENV_NAME}/parameters.yaml"
    CUSTOM_PARAM_LIST: "${CI_PROJECT_DIR}/configurations/custom-param-configuration.json"
    AWS_REGION: eu-central-1
    TERRAGRUNT_ROLE: arn:aws:iam::455399297295:role/eu-prod-fr-shell-EKSDevRWAccessRole
    ENV_NAME: eu-prod
  extends:
  - ".config_eu-prod-fr"
  - ".manual:config"
  tags:
  - eu-prod-fr
  stage: manual-override
  needs: []
manual:config_eu2-prod-fr:
  image: registry.gitlab.com/fireblocks/devops/terraform/terraform-runner:v0.5.4
  retry: 2
  rules:
  - if: $IS_PROD_SERVICE != "true"
    when: never
  - if: ($CI_COMMIT_BRANCH == "master" || $CI_COMMIT_BRANCH == "main") && $CI_CONFIG_MANAGEMENT_ENABLED
      == "true"
    when: manual
    allow_failure: true
  after_script:
  - rm -fr /builds/terraform/
  - echo 'Done!'
  before_script:
  - cd /builds/
  - |
    yq --version || (echo "please install yq" && exit 1)
    json_list="["
    if [[ -f "${CUSTOM_PARAM_LIST}" ]]; then
      for custom_config in $(cat $CUSTOM_PARAM_LIST | jq -c '.[]'); do
        config_prefix=$(echo $custom_config | jq -r '.prefix' | envsubst)
        config_path=$(echo $custom_config | jq -r '.path' | envsubst)
        if yq -e $config_path; then
          json_list="${json_list}
          {
            \"prefix\": \"${config_prefix}\",
            \"path\": \"${config_path}\"
          },"
        fi
      done
    else
      if [ -f $COMMON_FILE_PATH ]; then
        json_list="${json_list}
        {
          \"prefix\": \"/${ENV_NAME}/${SERVICE_NAME}/common\",
          \"path\": \"${COMMON_FILE_PATH}\"
        },"
      fi
      if yq -e $ENV_FILE_PATH; then
        json_list="${json_list}
        {
          \"prefix\": \"/${ENV_NAME}/${SERVICE_NAME}\",
          \"path\": \"${ENV_FILE_PATH}\"
        },"
      fi
    fi
    json_list="${json_list%?}]"
    export PARAMS_LIST=${json_list}
    echo "PARAMS_LIST: ${PARAMS_LIST}"
  - rm -fr /builds/terraform/
  - git clone https://gitlab-ci-token:${CI_JOB_TOKEN}@gitlab.com/fireblocks/devops/terraform.git
  - "$(assume-role.sh ${TERRAGRUNT_ROLE} gitlab-runner)"
  - cd /builds/terraform
  - "$(python3 switch-devx-env.py ${TERRAFORM_ENV_NAME})"
  - echo ${TERRAGRUNT_PROJECT}
  - cd ${TERRAGRUNT_PROJECT}
  script:
  - echo ${SERVICE_NAME} ${IMAGE_TAG} ${CI_ENVIRONMENT_NAME}
  - terragrunt apply --auto-approve --terragrunt-non-interactive --var "parameter_files=${PARAMS_LIST}"
  variables:
    TERRAGRUNT_PROJECT: "/builds/terraform/terragrunt/devx/parameter-store"
    TERRAFORM_ENV_NAME: eu2-prod-fr-shell
    COMMON_FILE_PATH: "${CI_PROJECT_DIR}/configurations/common/parameters.yaml"
    ENV_FILE_PATH: "${CI_PROJECT_DIR}/configurations/${ENV_NAME}/parameters.yaml"
    CUSTOM_PARAM_LIST: "${CI_PROJECT_DIR}/configurations/custom-param-configuration.json"
    AWS_REGION: eu-central-1
    TERRAGRUNT_ROLE: arn:aws:iam::803035224331:role/gitlab-runner-parameter-store-role
    ENV_NAME: eu2-prod
  extends:
  - ".config_eu2-prod-fr"
  - ".manual:config"
  tags:
  - shared-eu2-prod
  stage: manual-override
  needs: []
manual:config_bnym-dev:
  image: registry.gitlab.com/fireblocks/devops/terraform/terraform-runner:v0.5.4
  retry: 2
  rules:
  - if: $IS_PROD_SERVICE != "true"
    when: never
  - if: ($CI_COMMIT_BRANCH == "master" || $CI_COMMIT_BRANCH == "main") && $CI_CONFIG_MANAGEMENT_ENABLED
      == "true"
    when: manual
    allow_failure: true
  after_script:
  - rm -fr /builds/terraform/
  - echo 'Done!'
  before_script:
  - cd /builds/
  - |
    yq --version || (echo "please install yq" && exit 1)
    json_list="["
    if [[ -f "${CUSTOM_PARAM_LIST}" ]]; then
      for custom_config in $(cat $CUSTOM_PARAM_LIST | jq -c '.[]'); do
        config_prefix=$(echo $custom_config | jq -r '.prefix' | envsubst)
        config_path=$(echo $custom_config | jq -r '.path' | envsubst)
        if yq -e $config_path; then
          json_list="${json_list}
          {
            \"prefix\": \"${config_prefix}\",
            \"path\": \"${config_path}\"
          },"
        fi
      done
    else
      if [ -f $COMMON_FILE_PATH ]; then
        json_list="${json_list}
        {
          \"prefix\": \"/${ENV_NAME}/${SERVICE_NAME}/common\",
          \"path\": \"${COMMON_FILE_PATH}\"
        },"
      fi
      if yq -e $ENV_FILE_PATH; then
        json_list="${json_list}
        {
          \"prefix\": \"/${ENV_NAME}/${SERVICE_NAME}\",
          \"path\": \"${ENV_FILE_PATH}\"
        },"
      fi
    fi
    json_list="${json_list%?}]"
    export PARAMS_LIST=${json_list}
    echo "PARAMS_LIST: ${PARAMS_LIST}"
  - rm -fr /builds/terraform/
  - git clone https://gitlab-ci-token:${CI_JOB_TOKEN}@gitlab.com/fireblocks/devops/terraform.git
  - "$(assume-role.sh ${TERRAGRUNT_ROLE} gitlab-runner)"
  - cd /builds/terraform
  - "$(python3 switch-devx-env.py ${TERRAFORM_ENV_NAME})"
  - echo ${TERRAGRUNT_PROJECT}
  - cd ${TERRAGRUNT_PROJECT}
  script:
  - echo ${SERVICE_NAME} ${IMAGE_TAG} ${CI_ENVIRONMENT_NAME}
  - terragrunt apply --auto-approve --terragrunt-non-interactive --var "parameter_files=${PARAMS_LIST}"
  variables:
    TERRAGRUNT_PROJECT: "/builds/terraform/terragrunt/devx/parameter-store"
    TERRAFORM_ENV_NAME: bnym-dev-shell
    COMMON_FILE_PATH: "${CI_PROJECT_DIR}/configurations/common/parameters.yaml"
    ENV_FILE_PATH: "${CI_PROJECT_DIR}/configurations/${ENV_NAME}/parameters.yaml"
    CUSTOM_PARAM_LIST: "${CI_PROJECT_DIR}/configurations/custom-param-configuration.json"
    AWS_REGION: us-east-2
    TERRAGRUNT_ROLE: arn:aws:iam::414623400063:role/gitlab-runner-parameter-store-role
    ENV_NAME: bnym-dev
  extends:
  - ".config_bnym-dev"
  - ".manual:config"
  tags:
  - shared-bnym-dev
  stage: manual-override
  needs: []
manual:config_bnym-prod:
  image: registry.gitlab.com/fireblocks/devops/terraform/terraform-runner:v0.5.4
  retry: 2
  rules:
  - if: $IS_PROD_SERVICE != "true"
    when: never
  - if: ($CI_COMMIT_BRANCH == "master" || $CI_COMMIT_BRANCH == "main") && $CI_CONFIG_MANAGEMENT_ENABLED
      == "true"
    when: manual
    allow_failure: true
  after_script:
  - rm -fr /builds/terraform/
  - echo 'Done!'
  before_script:
  - cd /builds/
  - |
    yq --version || (echo "please install yq" && exit 1)
    json_list="["
    if [[ -f "${CUSTOM_PARAM_LIST}" ]]; then
      for custom_config in $(cat $CUSTOM_PARAM_LIST | jq -c '.[]'); do
        config_prefix=$(echo $custom_config | jq -r '.prefix' | envsubst)
        config_path=$(echo $custom_config | jq -r '.path' | envsubst)
        if yq -e $config_path; then
          json_list="${json_list}
          {
            \"prefix\": \"${config_prefix}\",
            \"path\": \"${config_path}\"
          },"
        fi
      done
    else
      if [ -f $COMMON_FILE_PATH ]; then
        json_list="${json_list}
        {
          \"prefix\": \"/${ENV_NAME}/${SERVICE_NAME}/common\",
          \"path\": \"${COMMON_FILE_PATH}\"
        },"
      fi
      if yq -e $ENV_FILE_PATH; then
        json_list="${json_list}
        {
          \"prefix\": \"/${ENV_NAME}/${SERVICE_NAME}\",
          \"path\": \"${ENV_FILE_PATH}\"
        },"
      fi
    fi
    json_list="${json_list%?}]"
    export PARAMS_LIST=${json_list}
    echo "PARAMS_LIST: ${PARAMS_LIST}"
  - rm -fr /builds/terraform/
  - git clone https://gitlab-ci-token:${CI_JOB_TOKEN}@gitlab.com/fireblocks/devops/terraform.git
  - "$(assume-role.sh ${TERRAGRUNT_ROLE} gitlab-runner)"
  - cd /builds/terraform
  - "$(python3 switch-devx-env.py ${TERRAFORM_ENV_NAME})"
  - echo ${TERRAGRUNT_PROJECT}
  - cd ${TERRAGRUNT_PROJECT}
  script:
  - echo ${SERVICE_NAME} ${IMAGE_TAG} ${CI_ENVIRONMENT_NAME}
  - terragrunt apply --auto-approve --terragrunt-non-interactive --var "parameter_files=${PARAMS_LIST}"
  variables:
    TERRAGRUNT_PROJECT: "/builds/terraform/terragrunt/devx/parameter-store"
    TERRAFORM_ENV_NAME: bnym-prod-shell
    COMMON_FILE_PATH: "${CI_PROJECT_DIR}/configurations/common/parameters.yaml"
    ENV_FILE_PATH: "${CI_PROJECT_DIR}/configurations/${ENV_NAME}/parameters.yaml"
    CUSTOM_PARAM_LIST: "${CI_PROJECT_DIR}/configurations/custom-param-configuration.json"
    AWS_REGION: us-east-2
    TERRAGRUNT_ROLE: arn:aws:iam::296106167418:role/gitlab-runner-parameter-store-role
    ENV_NAME: bnym-prod
  extends:
  - ".config_bnym-prod"
  - ".manual:config"
  tags:
  - shared-bnym-prod
  stage: manual-override
  needs: []
".manual:deploy_resources":
  stage: manual-override
  needs: []
  rules:
  - if: $IS_PROD_SERVICE != "true"
    when: never
  - if: ($CI_COMMIT_BRANCH == "master" || $CI_COMMIT_BRANCH == "main") && $CI_CONFIG_MANAGEMENT_ENABLED
      == "true"
    when: manual
    allow_failure: true
manual:publish_resources_prod-us:
  stage: manual-override
  retry:
    max: 2
    when:
    - script_failure
  tags:
  - "${GITLAB_RUNNER_TAG}"
  before_script:
  - printf "%s:%s\n" DESTINATION_REPO "$DESTINATION_REPO" DESTINATION_PROJECT_ID "$DESTINATION_PROJECT_ID"
    SOURCE_PATH "$SOURCE_PATH" DESTINATION_PATH "$DESTINATION_PATH" STATE_BRANCH "$STATE_BRANCH"
    GITLAB_API_URL "$GITLAB_API_URL"
  - |
    if [ ! -d "$SOURCE_PATH" ]; then
      echo "$SOURCE_PATH directory does not exist. Exiting job successfully."
      exit 0
    fi
    echo "$SOURCE_PATH directory exists. Continuing with deployment."
  - - apk update
    - apk add curl jq yq py3-pip
    - pip3 install --upgrade pip
    - pip3 install yamllint
    - pip3 install yamale --break-system-packages
    - npm install -g ajv-cli
    - echo "Configuring Git"
    - echo "https://argocd-ci-push:${ARGOCD_GITLAB_ACCESS_TOKEN}@gitlab.com" > ~/.git-credentials
    - git remote set-url origin https://argocd-ci-push:${ARGOCD_GITLAB_ACCESS_TOKEN}@gitlab.com/fireblocks/devops/iac/argocd.git
    - git config --global user.email "devops@fireblocks.com"
    - git config --global user.name "argocd-ci-push"
    - git config --global credential.helper store
    - touch .npmrc
    - npm config set --location=user @fireblocks:registry https://gitlab.com/api/v4/packages/npm/
    - npm config set --location=user '//gitlab.com/api/v4/packages/npm/:_authToken'
      "${NPM_REG_TOKEN}"
    - npm config set --location=user '//gitlab.com/api/v4/projects/20565764/packages/npm/:_authToken'
      "${NPM_REG_TOKEN}"
    - echo "@fireblocks:registry=https://gitlab.com/api/v4/packages/npm/">>.npmrc
    - echo "//gitlab.com/api/v4/packages/npm/:_authToken=${NPM_REG_TOKEN}">>.npmrc
    - echo "//gitlab.com/api/v4/projects/20565764/packages/npm/:_authToken=${NPM_REG_TOKEN}">>.npmrc
    - yarn global add @fireblocks/fb-cli
  script:
  - - echo "Self Service User Guide - https://fireblocks.atlassian.net/wiki/spaces/RD/pages/1413218873/Self+Service+User+Guide"
    - SVC_NAME=$([ "$SERVICE_NAME" ] && echo $SERVICE_NAME || echo $CI_PROJECT_NAME)
    - echo "Verifying deployment folder for ${SVC_NAME} service"
    - git clone ${DESTINATION_REPO} mono_repo
    - cd mono_repo
    - git fetch --all
    - git checkout ${STATE_BRANCH}
    - git pull origin ${STATE_BRANCH} --no-rebase
    - cd ../${SOURCE_PATH}
    - |
      # Define the paths
      values_file="values.yaml"

      # Check for values.yaml in the deployment folder
      if [ ! -f "$values_file" ]; then
          echo "Error: The values.yaml file is missing in the ${SOURCE_PATH} folder."
          exit 1
      fi

      echo "Success: All required files are present"
    - |
      # Directory to check
      DIR_TO_CHECK="overrides/"

      # List of allowed files
      ALLOWED_PATTERN=$(printf "|%s" "nonprod-tier.yaml" "prod-tier.yaml" "iac-dev.yaml" "localstack.yaml" "dev1.yaml" "dev2.yaml" "dev3.yaml" "dev4.yaml" "dev5.yaml" "dev6.yaml" "dev7.yaml" "dev8.yaml" "dev9.yaml" "dev10.yaml" "dev11.yaml" "dev11.yaml" "dev12.yaml" "dev13.yaml" "dev14.yaml" "dev15.yaml" "pre1.yaml" "stage.yaml" "sandbox.yaml" "eu-prod.yaml" "eu2-prod.yaml" "bnym-dev.yaml" "bnym-prod.yaml" "us-prod.yaml" | cut -c 2-)

      # Flag to track if there are disallowed files
      DISALLOWED_FOUND=false

      # Check for files in the directory that are not in the allowed list
      for file in "$DIR_TO_CHECK"/*; do
        # Get the base name of the file
        filename=$(basename "$file")

        # Check if the filename is in the allowed list
        if [[ ! $filename =~ ^($ALLOWED_PATTERN)$ ]]; then
          echo "Disallowed file found: $filename"
          DISALLOWED_FOUND=true
        fi
      done

      # Final output
      if $DISALLOWED_FOUND; then
        echo "Some files are not allowed."
        exit 1
      else
        echo "All files are allowed."
      fi
    - echo "Linting deployment yaml files"
    - cp ../mono_repo/services/schema/*.yaml .
    - cp ../mono_repo/services/schema/appconfig_schema.json .
    - cp ../mono_repo/services/schema/main_appconfig.json appconfig.json
    - cp ../mono_repo/services/schema/yamllint_rules.yaml yamllint_rules.yaml
    - yamllint --list-files **/*.yaml *.yaml
    - yamllint -s **/*.yaml *.yaml -c yamllint_rules.yaml
    - echo "Validating deployment yaml schema"
    - yamale -s base_values_schema.yaml values.yaml
    - yamale -s tier_values_schema.yaml overrides/prod-tier.yaml
    - yamale -s tier_values_schema.yaml overrides/nonprod-tier.yaml
    - |
      # Iterate over all yaml files in the overrides folder
      for file in overrides/*.yaml; do
          # Extract the filename from the path
          filename=$(basename -- "$file")

          # Check if the file is not prod-tier.yaml or nonprod-tier.yaml
          if [[ "$filename" != "prod-tier.yaml" ]] && [[ "$filename" != "nonprod-tier.yaml" ]]; then
              # Run yamale command on the file
              yamale -s env_values_schema.yaml "$file"
          fi
      done
    - "# Iterate over all yaml files in the overrides folder - validate_resources.sh\nif
      [[ -v ENGINE && \"$ENGINE\" == \"argocd\" ]]; then\n  export CD_INFRA_PROJECT_ID=61508954\n
      \ curl --header \"PRIVATE-TOKEN: $CD_CPU_RAM_REQUEST_LIMIT_READ_ONLY\"  \"https://gitlab.com/api/v4/projects/$CD_INFRA_PROJECT_ID/repository/files/ci-infra%2Fscripts%2Fvalidate_resources.sh/raw?ref=main\"
      -o \"$CI_PROJECT_DIR/validate_resources.sh\"\n  echo \"chmod +x $CI_PROJECT_DIR/validate_resources.sh\"
      \n  chmod +x \"$CI_PROJECT_DIR/validate_resources.sh\"\n  echo \"Searching for
      environments values files...\" \n  ENV_FILES_LIST=$(yamllint --list-files **/*.yaml
      *.yaml | grep -vE 'env_values_schema\\.yaml|tier_values_schema\\.yaml|base_values_schema\\.yaml|yamllint_rules\\.yaml|.*prod-tier\\.yaml|values.yaml'
      || true)\n  if [[ -n \"$ENV_FILES_LIST\" ]]; then\n    echo \"Found environments
      values files\"\n    while IFS= read -r file; do\n      filename=$(basename --
      \"$file\")\n      if [[ \"$filename\" =~ ^(dev[1-9]|dev10|stage|pre1).yaml$
      ]]; then\n        tier_file=\"overrides/nonprod-tier.yaml\"\n      else\n        tier_file=\"overrides/prod-tier.yaml\"
      \ \n      fi\n      echo \"values.yaml <-- $tier_file <-- $file\"\n      yq
      eval-all '. as $item ireduce ({}; . * $item)' values.yaml \"$tier_file\" \"$file\"
      | bash \"$CI_PROJECT_DIR/validate_resources.sh\" -\n    done <<< \"$ENV_FILES_LIST\"\n
      \ else\n    echo \"No environments values files were found. Continuing to the
      tier files.\"\n  fi\necho \"values.yaml <-- overrides/nonprod-tier.yaml\"\nyq
      eval-all '. as $item ireduce ({}; . * $item)' values.yaml overrides/nonprod-tier.yaml
      | bash \"$CI_PROJECT_DIR/validate_resources.sh\" -\necho \"values.yaml <-- overrides/prod-tier.yaml\"
      \nyq eval-all '. as $item ireduce ({}; . * $item)' values.yaml overrides/prod-tier.yaml
      | bash \"$CI_PROJECT_DIR/validate_resources.sh\" -\nelse\n  echo \"Skipping
      resource validation: ENGINE is not set to 'argocd'.\"\nfi\n"
    - ajv validate -s appconfig_schema.json -d appconfig.json
    - echo "Resources verified successfully"
    - echo "Validate filter_policy if exists - should be a valid JSON object"
    - fb deployment:validate . --filter-policy
  - cd ../mono_repo
  - ENV_DESTINATION_PATH=$(echo "${DESTINATION_PATH}/${SVC_NAME}/${ENV}")
  - echo "Copying ${SOURCE_PATH} folder from ${SVC_NAME} service to argocd mono repo
    destination folder at ${ENV_DESTINATION_PATH}"
  - mkdir -pv ${ENV_DESTINATION_PATH}/overrides
  - rm ${ENV_DESTINATION_PATH}/overrides/${ENV}.yaml || true
  - cp  ../${SOURCE_PATH}/values.yaml ${ENV_DESTINATION_PATH}
  - cp ../${SOURCE_PATH}/overrides/${ENV}.yaml  ${ENV_DESTINATION_PATH}/overrides
    || true
  - cp ../${SOURCE_PATH}/overrides/*-tier.yaml  ${ENV_DESTINATION_PATH}/overrides
    || true
  - if [ ! -f ${ENV_DESTINATION_PATH}/appconfig.json ]; then cp ../mono_repo/services/schema/main_appconfig.json
    ${ENV_DESTINATION_PATH}/appconfig.json; fi
  - git status
  - echo "Adding changes to Git"
  - git add ${DESTINATION_PATH}
  - git status
  - COUNT=$(git diff --numstat ${STATE_BRANCH} | awk '{added += $1; deleted += $2}
    END {print added + deleted}')
  - |
    if [ "$COUNT" -eq 0 ]; then
      echo "No changes detected under ${CI_PROJECT_NAME}/${SOURCE_PATH}, exiting"
      exit 0
    fi
  - echo "Committing changes"
  - git commit -m "${CI_JOB_NAME}"
  - echo "Pushing changes to remote"
  - git pull --rebase
  - git status
  - "MAX_RETRIES=3\nINITIAL_DELAY=5\nsuccess=false\n\nfor attempt in $(seq 1 $MAX_RETRIES);
    do\n  if git push; then\n    echo -e \"\\e[32mPush successful\\e[0m\"\n    success=true\n
    \   break\n  else\n    echo -e \"\\e[33mPush failed, retrying ($attempt/$MAX_RETRIES)...\\e[0m\"\n
    \   git pull --rebase\n    \n    # Calculate backoff delay (5s, then 10s, then
    20s)\n    BACKOFF_DELAY=$((INITIAL_DELAY * 2**(attempt-1)))\n    echo \"Waiting
    ${BACKOFF_DELAY} seconds before next attempt...\"\n    sleep $BACKOFF_DELAY\n
    \ fi\ndone\n\nif [ \"$success\" != \"true\" ]; then\n  echo -e \"\\e[31mFailed
    to push after $MAX_RETRIES attempts\\e[0m\"\n  exit 1\nfi\n"
  - git status
  - echo "Resources published to argocd mono repo"
  variables:
    DESTINATION_REPO: https://gitlab.com/fireblocks/devops/iac/argocd.git
    DESTINATION_PROJECT_ID: 50521873
    SOURCE_PATH: deployment
    DESTINATION_PATH: services/shell
    STATE_BRANCH: main
    GITLAB_API_URL: https://gitlab.com/api/v4/projects
    TEMPLATE_REF: "$TEMPLATE_REF"
    GITLAB_RUNNER_TAG: us-prod-application-gitlab-runner
    ENV: us-prod
  extends:
  - ".publish_resources_prod-us"
  - ".manual:deploy_resources"
  needs: []
  rules:
  - if: $IS_PROD_SERVICE != "true"
    when: never
  - if: ($CI_COMMIT_BRANCH == "master" || $CI_COMMIT_BRANCH == "main") && $CI_CONFIG_MANAGEMENT_ENABLED
      == "true"
    when: manual
    allow_failure: true
manual:argocd_sync_resources_prod-us:
  stage: manual-override
  retry:
    max: 2
    when:
    - script_failure
  tags:
  - "${GITLAB_RUNNER_TAG}"
  before_script:
  - echo "Install yq & jq from deploy-stage.yml"
  - apk update
  - apk add jq
  - apk add yq
  - |
    if [ ! -d "$SOURCE_PATH" ]; then
      echo "$SOURCE_PATH directory does not exist. Exiting job successfully."
      exit 0
    fi
    echo "$SOURCE_PATH directory exists. Continuing with deployment."
  - apk update
  - apk add curl
  - curl -sSL -o argocd-linux-amd64 https://github.com/argoproj/argo-cd/releases/download/v2.14.9/argocd-linux-amd64
  - install -m 555 argocd-linux-amd64 /usr/local/bin/argocd
  - rm argocd-linux-amd64
  - argocd version --client
  script:
  - echo "Self Service User Guide - https://fireblocks.atlassian.net/wiki/spaces/RD/pages/1413218873/Self+Service+User+Guide"
  - SVC_NAME=$([ "$SERVICE_NAME" ] && echo $SERVICE_NAME || echo $CI_PROJECT_NAME)
  - echo "Syncing resources for ${SVC_NAME} service"
  - ARGOCD_APP_NAME=$(echo "${SVC_NAME}-${ENV}")
  - echo "Refreshing ${ARGOCD_APP_NAME} application"
  - argocd app get ${ARGOCD_APP_NAME} -owide --refresh --insecure --auth-token ${ARGOCD_AUTH_TOKEN}
    --server ${ARGOCD_SERVER}
  - echo "Syncing ${ARGOCD_APP_NAME} application"
  - |
    if [[ "$STRATEGY" == "canary" ]]; then
      argocd app sync --resource '!*:Rollout:*' --resource '!*:Service:*' --prune ${ARGOCD_APP_NAME} --insecure --auth-token ${ARGOCD_AUTH_TOKEN} --server ${ARGOCD_SERVER}
    elif [[ "$STRATEGY" == "in_place" ]]; then
      argocd app sync --resource '!*:Deployment:*' --resource '!*:Service:*' --prune ${ARGOCD_APP_NAME} --insecure --auth-token ${ARGOCD_AUTH_TOKEN} --server ${ARGOCD_SERVER}
    else
      argocd app sync --prune ${ARGOCD_APP_NAME} --insecure --auth-token ${ARGOCD_AUTH_TOKEN} --server ${ARGOCD_SERVER}
    fi
  - echo "Waiting for ${ARGOCD_APP_NAME} application to be synced and healthy"
  - |
    resources_to_sync=$(argocd app get ${ARGOCD_APP_NAME} --insecure --auth-token ${ARGOCD_AUTH_TOKEN} --server ${ARGOCD_SERVER} -o json | jq -r 'select(.status.resources != null) | .status.resources[] | select(.health.status and .kind != "Deployment" and .kind != "Rollout" and .kind != "Ingress" and .kind != "Service") | "\(.group // ""):\(.kind):\(.name)"')
    if [ "x${resources_to_sync}" == "x" ]; then
        echo "There are no resources to sync"
    else
        echo ${resources_to_sync}
        for resource in ${resources_to_sync}; do
            argocd app wait ${ARGOCD_APP_NAME} --resource $resource --health --sync --timeout 600 --loglevel debug --insecure --auth-token ${ARGOCD_AUTH_TOKEN} --server ${ARGOCD_SERVER}
        done
    fi
  variables:
    SOURCE_PATH: deployment
    GITLAB_RUNNER_TAG: devx-application-gitlab-runner
    ARGOCD_SERVER: "${ARGOCD_PROD_SERVER}"
    ARGOCD_AUTH_TOKEN: "${ARGOCD_PROD_SHELL_AUTH_TOKEN}"
    ENV: us-prod
  extends:
  - ".argocd_sync_resources_prod-us"
  - ".manual:deploy_resources"
  needs:
  - manual:publish_resources_prod-us
  rules:
  - if: $IS_PROD_SERVICE != "true"
    when: never
  - if: ($CI_COMMIT_BRANCH == "master" || $CI_COMMIT_BRANCH == "main") && $CI_CONFIG_MANAGEMENT_ENABLED
      == "true"
    when: manual
    allow_failure: true
manual:publish_resources_sandbox:
  stage: manual-override
  retry:
    max: 2
    when:
    - script_failure
  tags:
  - "${GITLAB_RUNNER_TAG}"
  before_script:
  - printf "%s:%s\n" DESTINATION_REPO "$DESTINATION_REPO" DESTINATION_PROJECT_ID "$DESTINATION_PROJECT_ID"
    SOURCE_PATH "$SOURCE_PATH" DESTINATION_PATH "$DESTINATION_PATH" STATE_BRANCH "$STATE_BRANCH"
    GITLAB_API_URL "$GITLAB_API_URL"
  - |
    if [ ! -d "$SOURCE_PATH" ]; then
      echo "$SOURCE_PATH directory does not exist. Exiting job successfully."
      exit 0
    fi
    echo "$SOURCE_PATH directory exists. Continuing with deployment."
  - - apk update
    - apk add curl jq yq py3-pip
    - pip3 install --upgrade pip
    - pip3 install yamllint
    - pip3 install yamale --break-system-packages
    - npm install -g ajv-cli
    - echo "Configuring Git"
    - echo "https://argocd-ci-push:${ARGOCD_GITLAB_ACCESS_TOKEN}@gitlab.com" > ~/.git-credentials
    - git remote set-url origin https://argocd-ci-push:${ARGOCD_GITLAB_ACCESS_TOKEN}@gitlab.com/fireblocks/devops/iac/argocd.git
    - git config --global user.email "devops@fireblocks.com"
    - git config --global user.name "argocd-ci-push"
    - git config --global credential.helper store
    - touch .npmrc
    - npm config set --location=user @fireblocks:registry https://gitlab.com/api/v4/packages/npm/
    - npm config set --location=user '//gitlab.com/api/v4/packages/npm/:_authToken'
      "${NPM_REG_TOKEN}"
    - npm config set --location=user '//gitlab.com/api/v4/projects/20565764/packages/npm/:_authToken'
      "${NPM_REG_TOKEN}"
    - echo "@fireblocks:registry=https://gitlab.com/api/v4/packages/npm/">>.npmrc
    - echo "//gitlab.com/api/v4/packages/npm/:_authToken=${NPM_REG_TOKEN}">>.npmrc
    - echo "//gitlab.com/api/v4/projects/20565764/packages/npm/:_authToken=${NPM_REG_TOKEN}">>.npmrc
    - yarn global add @fireblocks/fb-cli
  script:
  - - echo "Self Service User Guide - https://fireblocks.atlassian.net/wiki/spaces/RD/pages/1413218873/Self+Service+User+Guide"
    - SVC_NAME=$([ "$SERVICE_NAME" ] && echo $SERVICE_NAME || echo $CI_PROJECT_NAME)
    - echo "Verifying deployment folder for ${SVC_NAME} service"
    - git clone ${DESTINATION_REPO} mono_repo
    - cd mono_repo
    - git fetch --all
    - git checkout ${STATE_BRANCH}
    - git pull origin ${STATE_BRANCH} --no-rebase
    - cd ../${SOURCE_PATH}
    - |
      # Define the paths
      values_file="values.yaml"

      # Check for values.yaml in the deployment folder
      if [ ! -f "$values_file" ]; then
          echo "Error: The values.yaml file is missing in the ${SOURCE_PATH} folder."
          exit 1
      fi

      echo "Success: All required files are present"
    - |
      # Directory to check
      DIR_TO_CHECK="overrides/"

      # List of allowed files
      ALLOWED_PATTERN=$(printf "|%s" "nonprod-tier.yaml" "prod-tier.yaml" "iac-dev.yaml" "localstack.yaml" "dev1.yaml" "dev2.yaml" "dev3.yaml" "dev4.yaml" "dev5.yaml" "dev6.yaml" "dev7.yaml" "dev8.yaml" "dev9.yaml" "dev10.yaml" "dev11.yaml" "dev11.yaml" "dev12.yaml" "dev13.yaml" "dev14.yaml" "dev15.yaml" "pre1.yaml" "stage.yaml" "sandbox.yaml" "eu-prod.yaml" "eu2-prod.yaml" "bnym-dev.yaml" "bnym-prod.yaml" "us-prod.yaml" | cut -c 2-)

      # Flag to track if there are disallowed files
      DISALLOWED_FOUND=false

      # Check for files in the directory that are not in the allowed list
      for file in "$DIR_TO_CHECK"/*; do
        # Get the base name of the file
        filename=$(basename "$file")

        # Check if the filename is in the allowed list
        if [[ ! $filename =~ ^($ALLOWED_PATTERN)$ ]]; then
          echo "Disallowed file found: $filename"
          DISALLOWED_FOUND=true
        fi
      done

      # Final output
      if $DISALLOWED_FOUND; then
        echo "Some files are not allowed."
        exit 1
      else
        echo "All files are allowed."
      fi
    - echo "Linting deployment yaml files"
    - cp ../mono_repo/services/schema/*.yaml .
    - cp ../mono_repo/services/schema/appconfig_schema.json .
    - cp ../mono_repo/services/schema/main_appconfig.json appconfig.json
    - cp ../mono_repo/services/schema/yamllint_rules.yaml yamllint_rules.yaml
    - yamllint --list-files **/*.yaml *.yaml
    - yamllint -s **/*.yaml *.yaml -c yamllint_rules.yaml
    - echo "Validating deployment yaml schema"
    - yamale -s base_values_schema.yaml values.yaml
    - yamale -s tier_values_schema.yaml overrides/prod-tier.yaml
    - yamale -s tier_values_schema.yaml overrides/nonprod-tier.yaml
    - |
      # Iterate over all yaml files in the overrides folder
      for file in overrides/*.yaml; do
          # Extract the filename from the path
          filename=$(basename -- "$file")

          # Check if the file is not prod-tier.yaml or nonprod-tier.yaml
          if [[ "$filename" != "prod-tier.yaml" ]] && [[ "$filename" != "nonprod-tier.yaml" ]]; then
              # Run yamale command on the file
              yamale -s env_values_schema.yaml "$file"
          fi
      done
    - "# Iterate over all yaml files in the overrides folder - validate_resources.sh\nif
      [[ -v ENGINE && \"$ENGINE\" == \"argocd\" ]]; then\n  export CD_INFRA_PROJECT_ID=61508954\n
      \ curl --header \"PRIVATE-TOKEN: $CD_CPU_RAM_REQUEST_LIMIT_READ_ONLY\"  \"https://gitlab.com/api/v4/projects/$CD_INFRA_PROJECT_ID/repository/files/ci-infra%2Fscripts%2Fvalidate_resources.sh/raw?ref=main\"
      -o \"$CI_PROJECT_DIR/validate_resources.sh\"\n  echo \"chmod +x $CI_PROJECT_DIR/validate_resources.sh\"
      \n  chmod +x \"$CI_PROJECT_DIR/validate_resources.sh\"\n  echo \"Searching for
      environments values files...\" \n  ENV_FILES_LIST=$(yamllint --list-files **/*.yaml
      *.yaml | grep -vE 'env_values_schema\\.yaml|tier_values_schema\\.yaml|base_values_schema\\.yaml|yamllint_rules\\.yaml|.*prod-tier\\.yaml|values.yaml'
      || true)\n  if [[ -n \"$ENV_FILES_LIST\" ]]; then\n    echo \"Found environments
      values files\"\n    while IFS= read -r file; do\n      filename=$(basename --
      \"$file\")\n      if [[ \"$filename\" =~ ^(dev[1-9]|dev10|stage|pre1).yaml$
      ]]; then\n        tier_file=\"overrides/nonprod-tier.yaml\"\n      else\n        tier_file=\"overrides/prod-tier.yaml\"
      \ \n      fi\n      echo \"values.yaml <-- $tier_file <-- $file\"\n      yq
      eval-all '. as $item ireduce ({}; . * $item)' values.yaml \"$tier_file\" \"$file\"
      | bash \"$CI_PROJECT_DIR/validate_resources.sh\" -\n    done <<< \"$ENV_FILES_LIST\"\n
      \ else\n    echo \"No environments values files were found. Continuing to the
      tier files.\"\n  fi\necho \"values.yaml <-- overrides/nonprod-tier.yaml\"\nyq
      eval-all '. as $item ireduce ({}; . * $item)' values.yaml overrides/nonprod-tier.yaml
      | bash \"$CI_PROJECT_DIR/validate_resources.sh\" -\necho \"values.yaml <-- overrides/prod-tier.yaml\"
      \nyq eval-all '. as $item ireduce ({}; . * $item)' values.yaml overrides/prod-tier.yaml
      | bash \"$CI_PROJECT_DIR/validate_resources.sh\" -\nelse\n  echo \"Skipping
      resource validation: ENGINE is not set to 'argocd'.\"\nfi\n"
    - ajv validate -s appconfig_schema.json -d appconfig.json
    - echo "Resources verified successfully"
    - echo "Validate filter_policy if exists - should be a valid JSON object"
    - fb deployment:validate . --filter-policy
  - cd ../mono_repo
  - ENV_DESTINATION_PATH=$(echo "${DESTINATION_PATH}/${SVC_NAME}/${ENV}")
  - echo "Copying ${SOURCE_PATH} folder from ${SVC_NAME} service to argocd mono repo
    destination folder at ${ENV_DESTINATION_PATH}"
  - mkdir -pv ${ENV_DESTINATION_PATH}/overrides
  - rm ${ENV_DESTINATION_PATH}/overrides/${ENV}.yaml || true
  - cp  ../${SOURCE_PATH}/values.yaml ${ENV_DESTINATION_PATH}
  - cp ../${SOURCE_PATH}/overrides/${ENV}.yaml  ${ENV_DESTINATION_PATH}/overrides
    || true
  - cp ../${SOURCE_PATH}/overrides/*-tier.yaml  ${ENV_DESTINATION_PATH}/overrides
    || true
  - if [ ! -f ${ENV_DESTINATION_PATH}/appconfig.json ]; then cp ../mono_repo/services/schema/main_appconfig.json
    ${ENV_DESTINATION_PATH}/appconfig.json; fi
  - git status
  - echo "Adding changes to Git"
  - git add ${DESTINATION_PATH}
  - git status
  - COUNT=$(git diff --numstat ${STATE_BRANCH} | awk '{added += $1; deleted += $2}
    END {print added + deleted}')
  - |
    if [ "$COUNT" -eq 0 ]; then
      echo "No changes detected under ${CI_PROJECT_NAME}/${SOURCE_PATH}, exiting"
      exit 0
    fi
  - echo "Committing changes"
  - git commit -m "${CI_JOB_NAME}"
  - echo "Pushing changes to remote"
  - git pull --rebase
  - git status
  - "MAX_RETRIES=3\nINITIAL_DELAY=5\nsuccess=false\n\nfor attempt in $(seq 1 $MAX_RETRIES);
    do\n  if git push; then\n    echo -e \"\\e[32mPush successful\\e[0m\"\n    success=true\n
    \   break\n  else\n    echo -e \"\\e[33mPush failed, retrying ($attempt/$MAX_RETRIES)...\\e[0m\"\n
    \   git pull --rebase\n    \n    # Calculate backoff delay (5s, then 10s, then
    20s)\n    BACKOFF_DELAY=$((INITIAL_DELAY * 2**(attempt-1)))\n    echo \"Waiting
    ${BACKOFF_DELAY} seconds before next attempt...\"\n    sleep $BACKOFF_DELAY\n
    \ fi\ndone\n\nif [ \"$success\" != \"true\" ]; then\n  echo -e \"\\e[31mFailed
    to push after $MAX_RETRIES attempts\\e[0m\"\n  exit 1\nfi\n"
  - git status
  - echo "Resources published to argocd mono repo"
  variables:
    DESTINATION_REPO: https://gitlab.com/fireblocks/devops/iac/argocd.git
    DESTINATION_PROJECT_ID: 50521873
    SOURCE_PATH: deployment
    DESTINATION_PATH: services/shell
    STATE_BRANCH: main
    GITLAB_API_URL: https://gitlab.com/api/v4/projects
    TEMPLATE_REF: "$TEMPLATE_REF"
    GITLAB_RUNNER_TAG: sandbox-application-gitlab-runner
    ENV: sandbox
  extends:
  - ".publish_resources_sandbox"
  - ".manual:deploy_resources"
  needs: []
  rules:
  - if: $IS_PROD_SERVICE != "true"
    when: never
  - if: ($CI_COMMIT_BRANCH == "master" || $CI_COMMIT_BRANCH == "main") && $CI_CONFIG_MANAGEMENT_ENABLED
      == "true"
    when: manual
    allow_failure: true
manual:argocd_sync_resources_sandbox:
  stage: manual-override
  retry:
    max: 2
    when:
    - script_failure
  tags:
  - "${GITLAB_RUNNER_TAG}"
  before_script:
  - echo "Install yq & jq from deploy-stage.yml"
  - apk update
  - apk add jq
  - apk add yq
  - |
    if [ ! -d "$SOURCE_PATH" ]; then
      echo "$SOURCE_PATH directory does not exist. Exiting job successfully."
      exit 0
    fi
    echo "$SOURCE_PATH directory exists. Continuing with deployment."
  - apk update
  - apk add curl
  - curl -sSL -o argocd-linux-amd64 https://github.com/argoproj/argo-cd/releases/download/v2.14.9/argocd-linux-amd64
  - install -m 555 argocd-linux-amd64 /usr/local/bin/argocd
  - rm argocd-linux-amd64
  - argocd version --client
  script:
  - echo "Self Service User Guide - https://fireblocks.atlassian.net/wiki/spaces/RD/pages/1413218873/Self+Service+User+Guide"
  - SVC_NAME=$([ "$SERVICE_NAME" ] && echo $SERVICE_NAME || echo $CI_PROJECT_NAME)
  - echo "Syncing resources for ${SVC_NAME} service"
  - ARGOCD_APP_NAME=$(echo "${SVC_NAME}-${ENV}")
  - echo "Refreshing ${ARGOCD_APP_NAME} application"
  - argocd app get ${ARGOCD_APP_NAME} -owide --refresh --insecure --auth-token ${ARGOCD_AUTH_TOKEN}
    --server ${ARGOCD_SERVER}
  - echo "Syncing ${ARGOCD_APP_NAME} application"
  - |
    if [[ "$STRATEGY" == "canary" ]]; then
      argocd app sync --resource '!*:Rollout:*' --resource '!*:Service:*' --prune ${ARGOCD_APP_NAME} --insecure --auth-token ${ARGOCD_AUTH_TOKEN} --server ${ARGOCD_SERVER}
    elif [[ "$STRATEGY" == "in_place" ]]; then
      argocd app sync --resource '!*:Deployment:*' --resource '!*:Service:*' --prune ${ARGOCD_APP_NAME} --insecure --auth-token ${ARGOCD_AUTH_TOKEN} --server ${ARGOCD_SERVER}
    else
      argocd app sync --prune ${ARGOCD_APP_NAME} --insecure --auth-token ${ARGOCD_AUTH_TOKEN} --server ${ARGOCD_SERVER}
    fi
  - echo "Waiting for ${ARGOCD_APP_NAME} application to be synced and healthy"
  - |
    resources_to_sync=$(argocd app get ${ARGOCD_APP_NAME} --insecure --auth-token ${ARGOCD_AUTH_TOKEN} --server ${ARGOCD_SERVER} -o json | jq -r 'select(.status.resources != null) | .status.resources[] | select(.health.status and .kind != "Deployment" and .kind != "Rollout" and .kind != "Ingress" and .kind != "Service") | "\(.group // ""):\(.kind):\(.name)"')
    if [ "x${resources_to_sync}" == "x" ]; then
        echo "There are no resources to sync"
    else
        echo ${resources_to_sync}
        for resource in ${resources_to_sync}; do
            argocd app wait ${ARGOCD_APP_NAME} --resource $resource --health --sync --timeout 600 --loglevel debug --insecure --auth-token ${ARGOCD_AUTH_TOKEN} --server ${ARGOCD_SERVER}
        done
    fi
  variables:
    SOURCE_PATH: deployment
    GITLAB_RUNNER_TAG: devx-application-gitlab-runner
    ARGOCD_SERVER: "${ARGOCD_PROD_SERVER}"
    ARGOCD_AUTH_TOKEN: "${ARGOCD_PROD_SHELL_AUTH_TOKEN}"
    ENV: sandbox
  extends:
  - ".argocd_sync_resources_sandbox"
  - ".manual:deploy_resources"
  needs:
  - manual:publish_resources_sandbox
  rules:
  - if: $IS_PROD_SERVICE != "true"
    when: never
  - if: ($CI_COMMIT_BRANCH == "master" || $CI_COMMIT_BRANCH == "main") && $CI_CONFIG_MANAGEMENT_ENABLED
      == "true"
    when: manual
    allow_failure: true
manual:publish_resources_eu-prod-fr:
  stage: manual-override
  retry:
    max: 2
    when:
    - script_failure
  tags:
  - "${GITLAB_RUNNER_TAG}"
  before_script:
  - printf "%s:%s\n" DESTINATION_REPO "$DESTINATION_REPO" DESTINATION_PROJECT_ID "$DESTINATION_PROJECT_ID"
    SOURCE_PATH "$SOURCE_PATH" DESTINATION_PATH "$DESTINATION_PATH" STATE_BRANCH "$STATE_BRANCH"
    GITLAB_API_URL "$GITLAB_API_URL"
  - |
    if [ ! -d "$SOURCE_PATH" ]; then
      echo "$SOURCE_PATH directory does not exist. Exiting job successfully."
      exit 0
    fi
    echo "$SOURCE_PATH directory exists. Continuing with deployment."
  - - apk update
    - apk add curl jq yq py3-pip
    - pip3 install --upgrade pip
    - pip3 install yamllint
    - pip3 install yamale --break-system-packages
    - npm install -g ajv-cli
    - echo "Configuring Git"
    - echo "https://argocd-ci-push:${ARGOCD_GITLAB_ACCESS_TOKEN}@gitlab.com" > ~/.git-credentials
    - git remote set-url origin https://argocd-ci-push:${ARGOCD_GITLAB_ACCESS_TOKEN}@gitlab.com/fireblocks/devops/iac/argocd.git
    - git config --global user.email "devops@fireblocks.com"
    - git config --global user.name "argocd-ci-push"
    - git config --global credential.helper store
    - touch .npmrc
    - npm config set --location=user @fireblocks:registry https://gitlab.com/api/v4/packages/npm/
    - npm config set --location=user '//gitlab.com/api/v4/packages/npm/:_authToken'
      "${NPM_REG_TOKEN}"
    - npm config set --location=user '//gitlab.com/api/v4/projects/20565764/packages/npm/:_authToken'
      "${NPM_REG_TOKEN}"
    - echo "@fireblocks:registry=https://gitlab.com/api/v4/packages/npm/">>.npmrc
    - echo "//gitlab.com/api/v4/packages/npm/:_authToken=${NPM_REG_TOKEN}">>.npmrc
    - echo "//gitlab.com/api/v4/projects/20565764/packages/npm/:_authToken=${NPM_REG_TOKEN}">>.npmrc
    - yarn global add @fireblocks/fb-cli
  script:
  - - echo "Self Service User Guide - https://fireblocks.atlassian.net/wiki/spaces/RD/pages/1413218873/Self+Service+User+Guide"
    - SVC_NAME=$([ "$SERVICE_NAME" ] && echo $SERVICE_NAME || echo $CI_PROJECT_NAME)
    - echo "Verifying deployment folder for ${SVC_NAME} service"
    - git clone ${DESTINATION_REPO} mono_repo
    - cd mono_repo
    - git fetch --all
    - git checkout ${STATE_BRANCH}
    - git pull origin ${STATE_BRANCH} --no-rebase
    - cd ../${SOURCE_PATH}
    - |
      # Define the paths
      values_file="values.yaml"

      # Check for values.yaml in the deployment folder
      if [ ! -f "$values_file" ]; then
          echo "Error: The values.yaml file is missing in the ${SOURCE_PATH} folder."
          exit 1
      fi

      echo "Success: All required files are present"
    - |
      # Directory to check
      DIR_TO_CHECK="overrides/"

      # List of allowed files
      ALLOWED_PATTERN=$(printf "|%s" "nonprod-tier.yaml" "prod-tier.yaml" "iac-dev.yaml" "localstack.yaml" "dev1.yaml" "dev2.yaml" "dev3.yaml" "dev4.yaml" "dev5.yaml" "dev6.yaml" "dev7.yaml" "dev8.yaml" "dev9.yaml" "dev10.yaml" "dev11.yaml" "dev11.yaml" "dev12.yaml" "dev13.yaml" "dev14.yaml" "dev15.yaml" "pre1.yaml" "stage.yaml" "sandbox.yaml" "eu-prod.yaml" "eu2-prod.yaml" "bnym-dev.yaml" "bnym-prod.yaml" "us-prod.yaml" | cut -c 2-)

      # Flag to track if there are disallowed files
      DISALLOWED_FOUND=false

      # Check for files in the directory that are not in the allowed list
      for file in "$DIR_TO_CHECK"/*; do
        # Get the base name of the file
        filename=$(basename "$file")

        # Check if the filename is in the allowed list
        if [[ ! $filename =~ ^($ALLOWED_PATTERN)$ ]]; then
          echo "Disallowed file found: $filename"
          DISALLOWED_FOUND=true
        fi
      done

      # Final output
      if $DISALLOWED_FOUND; then
        echo "Some files are not allowed."
        exit 1
      else
        echo "All files are allowed."
      fi
    - echo "Linting deployment yaml files"
    - cp ../mono_repo/services/schema/*.yaml .
    - cp ../mono_repo/services/schema/appconfig_schema.json .
    - cp ../mono_repo/services/schema/main_appconfig.json appconfig.json
    - cp ../mono_repo/services/schema/yamllint_rules.yaml yamllint_rules.yaml
    - yamllint --list-files **/*.yaml *.yaml
    - yamllint -s **/*.yaml *.yaml -c yamllint_rules.yaml
    - echo "Validating deployment yaml schema"
    - yamale -s base_values_schema.yaml values.yaml
    - yamale -s tier_values_schema.yaml overrides/prod-tier.yaml
    - yamale -s tier_values_schema.yaml overrides/nonprod-tier.yaml
    - |
      # Iterate over all yaml files in the overrides folder
      for file in overrides/*.yaml; do
          # Extract the filename from the path
          filename=$(basename -- "$file")

          # Check if the file is not prod-tier.yaml or nonprod-tier.yaml
          if [[ "$filename" != "prod-tier.yaml" ]] && [[ "$filename" != "nonprod-tier.yaml" ]]; then
              # Run yamale command on the file
              yamale -s env_values_schema.yaml "$file"
          fi
      done
    - "# Iterate over all yaml files in the overrides folder - validate_resources.sh\nif
      [[ -v ENGINE && \"$ENGINE\" == \"argocd\" ]]; then\n  export CD_INFRA_PROJECT_ID=61508954\n
      \ curl --header \"PRIVATE-TOKEN: $CD_CPU_RAM_REQUEST_LIMIT_READ_ONLY\"  \"https://gitlab.com/api/v4/projects/$CD_INFRA_PROJECT_ID/repository/files/ci-infra%2Fscripts%2Fvalidate_resources.sh/raw?ref=main\"
      -o \"$CI_PROJECT_DIR/validate_resources.sh\"\n  echo \"chmod +x $CI_PROJECT_DIR/validate_resources.sh\"
      \n  chmod +x \"$CI_PROJECT_DIR/validate_resources.sh\"\n  echo \"Searching for
      environments values files...\" \n  ENV_FILES_LIST=$(yamllint --list-files **/*.yaml
      *.yaml | grep -vE 'env_values_schema\\.yaml|tier_values_schema\\.yaml|base_values_schema\\.yaml|yamllint_rules\\.yaml|.*prod-tier\\.yaml|values.yaml'
      || true)\n  if [[ -n \"$ENV_FILES_LIST\" ]]; then\n    echo \"Found environments
      values files\"\n    while IFS= read -r file; do\n      filename=$(basename --
      \"$file\")\n      if [[ \"$filename\" =~ ^(dev[1-9]|dev10|stage|pre1).yaml$
      ]]; then\n        tier_file=\"overrides/nonprod-tier.yaml\"\n      else\n        tier_file=\"overrides/prod-tier.yaml\"
      \ \n      fi\n      echo \"values.yaml <-- $tier_file <-- $file\"\n      yq
      eval-all '. as $item ireduce ({}; . * $item)' values.yaml \"$tier_file\" \"$file\"
      | bash \"$CI_PROJECT_DIR/validate_resources.sh\" -\n    done <<< \"$ENV_FILES_LIST\"\n
      \ else\n    echo \"No environments values files were found. Continuing to the
      tier files.\"\n  fi\necho \"values.yaml <-- overrides/nonprod-tier.yaml\"\nyq
      eval-all '. as $item ireduce ({}; . * $item)' values.yaml overrides/nonprod-tier.yaml
      | bash \"$CI_PROJECT_DIR/validate_resources.sh\" -\necho \"values.yaml <-- overrides/prod-tier.yaml\"
      \nyq eval-all '. as $item ireduce ({}; . * $item)' values.yaml overrides/prod-tier.yaml
      | bash \"$CI_PROJECT_DIR/validate_resources.sh\" -\nelse\n  echo \"Skipping
      resource validation: ENGINE is not set to 'argocd'.\"\nfi\n"
    - ajv validate -s appconfig_schema.json -d appconfig.json
    - echo "Resources verified successfully"
    - echo "Validate filter_policy if exists - should be a valid JSON object"
    - fb deployment:validate . --filter-policy
  - cd ../mono_repo
  - ENV_DESTINATION_PATH=$(echo "${DESTINATION_PATH}/${SVC_NAME}/${ENV}")
  - echo "Copying ${SOURCE_PATH} folder from ${SVC_NAME} service to argocd mono repo
    destination folder at ${ENV_DESTINATION_PATH}"
  - mkdir -pv ${ENV_DESTINATION_PATH}/overrides
  - rm ${ENV_DESTINATION_PATH}/overrides/${ENV}.yaml || true
  - cp  ../${SOURCE_PATH}/values.yaml ${ENV_DESTINATION_PATH}
  - cp ../${SOURCE_PATH}/overrides/${ENV}.yaml  ${ENV_DESTINATION_PATH}/overrides
    || true
  - cp ../${SOURCE_PATH}/overrides/*-tier.yaml  ${ENV_DESTINATION_PATH}/overrides
    || true
  - if [ ! -f ${ENV_DESTINATION_PATH}/appconfig.json ]; then cp ../mono_repo/services/schema/main_appconfig.json
    ${ENV_DESTINATION_PATH}/appconfig.json; fi
  - git status
  - echo "Adding changes to Git"
  - git add ${DESTINATION_PATH}
  - git status
  - COUNT=$(git diff --numstat ${STATE_BRANCH} | awk '{added += $1; deleted += $2}
    END {print added + deleted}')
  - |
    if [ "$COUNT" -eq 0 ]; then
      echo "No changes detected under ${CI_PROJECT_NAME}/${SOURCE_PATH}, exiting"
      exit 0
    fi
  - echo "Committing changes"
  - git commit -m "${CI_JOB_NAME}"
  - echo "Pushing changes to remote"
  - git pull --rebase
  - git status
  - "MAX_RETRIES=3\nINITIAL_DELAY=5\nsuccess=false\n\nfor attempt in $(seq 1 $MAX_RETRIES);
    do\n  if git push; then\n    echo -e \"\\e[32mPush successful\\e[0m\"\n    success=true\n
    \   break\n  else\n    echo -e \"\\e[33mPush failed, retrying ($attempt/$MAX_RETRIES)...\\e[0m\"\n
    \   git pull --rebase\n    \n    # Calculate backoff delay (5s, then 10s, then
    20s)\n    BACKOFF_DELAY=$((INITIAL_DELAY * 2**(attempt-1)))\n    echo \"Waiting
    ${BACKOFF_DELAY} seconds before next attempt...\"\n    sleep $BACKOFF_DELAY\n
    \ fi\ndone\n\nif [ \"$success\" != \"true\" ]; then\n  echo -e \"\\e[31mFailed
    to push after $MAX_RETRIES attempts\\e[0m\"\n  exit 1\nfi\n"
  - git status
  - echo "Resources published to argocd mono repo"
  variables:
    DESTINATION_REPO: https://gitlab.com/fireblocks/devops/iac/argocd.git
    DESTINATION_PROJECT_ID: 50521873
    SOURCE_PATH: deployment
    DESTINATION_PATH: services/shell
    STATE_BRANCH: main
    GITLAB_API_URL: https://gitlab.com/api/v4/projects
    TEMPLATE_REF: "$TEMPLATE_REF"
    GITLAB_RUNNER_TAG: eu-prod-fr-application-gitlab-runner
    ENV: eu-prod
  extends:
  - ".publish_resources_eu-prod-fr"
  - ".manual:deploy_resources"
  needs: []
  rules:
  - if: $IS_PROD_SERVICE != "true"
    when: never
  - if: ($CI_COMMIT_BRANCH == "master" || $CI_COMMIT_BRANCH == "main") && $CI_CONFIG_MANAGEMENT_ENABLED
      == "true"
    when: manual
    allow_failure: true
manual:argocd_sync_resources_eu-prod-fr:
  stage: manual-override
  retry:
    max: 2
    when:
    - script_failure
  tags:
  - "${GITLAB_RUNNER_TAG}"
  before_script:
  - echo "Install yq & jq from deploy-stage.yml"
  - apk update
  - apk add jq
  - apk add yq
  - |
    if [ ! -d "$SOURCE_PATH" ]; then
      echo "$SOURCE_PATH directory does not exist. Exiting job successfully."
      exit 0
    fi
    echo "$SOURCE_PATH directory exists. Continuing with deployment."
  - apk update
  - apk add curl
  - curl -sSL -o argocd-linux-amd64 https://github.com/argoproj/argo-cd/releases/download/v2.14.9/argocd-linux-amd64
  - install -m 555 argocd-linux-amd64 /usr/local/bin/argocd
  - rm argocd-linux-amd64
  - argocd version --client
  script:
  - echo "Self Service User Guide - https://fireblocks.atlassian.net/wiki/spaces/RD/pages/1413218873/Self+Service+User+Guide"
  - SVC_NAME=$([ "$SERVICE_NAME" ] && echo $SERVICE_NAME || echo $CI_PROJECT_NAME)
  - echo "Syncing resources for ${SVC_NAME} service"
  - ARGOCD_APP_NAME=$(echo "${SVC_NAME}-${ENV}")
  - echo "Refreshing ${ARGOCD_APP_NAME} application"
  - argocd app get ${ARGOCD_APP_NAME} -owide --refresh --insecure --auth-token ${ARGOCD_AUTH_TOKEN}
    --server ${ARGOCD_SERVER}
  - echo "Syncing ${ARGOCD_APP_NAME} application"
  - |
    if [[ "$STRATEGY" == "canary" ]]; then
      argocd app sync --resource '!*:Rollout:*' --resource '!*:Service:*' --prune ${ARGOCD_APP_NAME} --insecure --auth-token ${ARGOCD_AUTH_TOKEN} --server ${ARGOCD_SERVER}
    elif [[ "$STRATEGY" == "in_place" ]]; then
      argocd app sync --resource '!*:Deployment:*' --resource '!*:Service:*' --prune ${ARGOCD_APP_NAME} --insecure --auth-token ${ARGOCD_AUTH_TOKEN} --server ${ARGOCD_SERVER}
    else
      argocd app sync --prune ${ARGOCD_APP_NAME} --insecure --auth-token ${ARGOCD_AUTH_TOKEN} --server ${ARGOCD_SERVER}
    fi
  - echo "Waiting for ${ARGOCD_APP_NAME} application to be synced and healthy"
  - |
    resources_to_sync=$(argocd app get ${ARGOCD_APP_NAME} --insecure --auth-token ${ARGOCD_AUTH_TOKEN} --server ${ARGOCD_SERVER} -o json | jq -r 'select(.status.resources != null) | .status.resources[] | select(.health.status and .kind != "Deployment" and .kind != "Rollout" and .kind != "Ingress" and .kind != "Service") | "\(.group // ""):\(.kind):\(.name)"')
    if [ "x${resources_to_sync}" == "x" ]; then
        echo "There are no resources to sync"
    else
        echo ${resources_to_sync}
        for resource in ${resources_to_sync}; do
            argocd app wait ${ARGOCD_APP_NAME} --resource $resource --health --sync --timeout 600 --loglevel debug --insecure --auth-token ${ARGOCD_AUTH_TOKEN} --server ${ARGOCD_SERVER}
        done
    fi
  variables:
    SOURCE_PATH: deployment
    GITLAB_RUNNER_TAG: devx-application-gitlab-runner
    ARGOCD_SERVER: "${ARGOCD_PROD_SERVER}"
    ARGOCD_AUTH_TOKEN: "${ARGOCD_PROD_SHELL_AUTH_TOKEN}"
    ENV: eu-prod
  extends:
  - ".argocd_sync_resources_eu-prod-fr"
  - ".manual:deploy_resources"
  needs:
  - manual:publish_resources_eu-prod-fr
  rules:
  - if: $IS_PROD_SERVICE != "true"
    when: never
  - if: ($CI_COMMIT_BRANCH == "master" || $CI_COMMIT_BRANCH == "main") && $CI_CONFIG_MANAGEMENT_ENABLED
      == "true"
    when: manual
    allow_failure: true
manual:publish_resources_eu2-prod-fr:
  stage: manual-override
  retry:
    max: 2
    when:
    - script_failure
  tags:
  - "${GITLAB_RUNNER_TAG}"
  before_script:
  - printf "%s:%s\n" DESTINATION_REPO "$DESTINATION_REPO" DESTINATION_PROJECT_ID "$DESTINATION_PROJECT_ID"
    SOURCE_PATH "$SOURCE_PATH" DESTINATION_PATH "$DESTINATION_PATH" STATE_BRANCH "$STATE_BRANCH"
    GITLAB_API_URL "$GITLAB_API_URL"
  - |
    if [ ! -d "$SOURCE_PATH" ]; then
      echo "$SOURCE_PATH directory does not exist. Exiting job successfully."
      exit 0
    fi
    echo "$SOURCE_PATH directory exists. Continuing with deployment."
  - - apk update
    - apk add curl jq yq py3-pip
    - pip3 install --upgrade pip
    - pip3 install yamllint
    - pip3 install yamale --break-system-packages
    - npm install -g ajv-cli
    - echo "Configuring Git"
    - echo "https://argocd-ci-push:${ARGOCD_GITLAB_ACCESS_TOKEN}@gitlab.com" > ~/.git-credentials
    - git remote set-url origin https://argocd-ci-push:${ARGOCD_GITLAB_ACCESS_TOKEN}@gitlab.com/fireblocks/devops/iac/argocd.git
    - git config --global user.email "devops@fireblocks.com"
    - git config --global user.name "argocd-ci-push"
    - git config --global credential.helper store
    - touch .npmrc
    - npm config set --location=user @fireblocks:registry https://gitlab.com/api/v4/packages/npm/
    - npm config set --location=user '//gitlab.com/api/v4/packages/npm/:_authToken'
      "${NPM_REG_TOKEN}"
    - npm config set --location=user '//gitlab.com/api/v4/projects/20565764/packages/npm/:_authToken'
      "${NPM_REG_TOKEN}"
    - echo "@fireblocks:registry=https://gitlab.com/api/v4/packages/npm/">>.npmrc
    - echo "//gitlab.com/api/v4/packages/npm/:_authToken=${NPM_REG_TOKEN}">>.npmrc
    - echo "//gitlab.com/api/v4/projects/20565764/packages/npm/:_authToken=${NPM_REG_TOKEN}">>.npmrc
    - yarn global add @fireblocks/fb-cli
  script:
  - - echo "Self Service User Guide - https://fireblocks.atlassian.net/wiki/spaces/RD/pages/1413218873/Self+Service+User+Guide"
    - SVC_NAME=$([ "$SERVICE_NAME" ] && echo $SERVICE_NAME || echo $CI_PROJECT_NAME)
    - echo "Verifying deployment folder for ${SVC_NAME} service"
    - git clone ${DESTINATION_REPO} mono_repo
    - cd mono_repo
    - git fetch --all
    - git checkout ${STATE_BRANCH}
    - git pull origin ${STATE_BRANCH} --no-rebase
    - cd ../${SOURCE_PATH}
    - |
      # Define the paths
      values_file="values.yaml"

      # Check for values.yaml in the deployment folder
      if [ ! -f "$values_file" ]; then
          echo "Error: The values.yaml file is missing in the ${SOURCE_PATH} folder."
          exit 1
      fi

      echo "Success: All required files are present"
    - |
      # Directory to check
      DIR_TO_CHECK="overrides/"

      # List of allowed files
      ALLOWED_PATTERN=$(printf "|%s" "nonprod-tier.yaml" "prod-tier.yaml" "iac-dev.yaml" "localstack.yaml" "dev1.yaml" "dev2.yaml" "dev3.yaml" "dev4.yaml" "dev5.yaml" "dev6.yaml" "dev7.yaml" "dev8.yaml" "dev9.yaml" "dev10.yaml" "dev11.yaml" "dev11.yaml" "dev12.yaml" "dev13.yaml" "dev14.yaml" "dev15.yaml" "pre1.yaml" "stage.yaml" "sandbox.yaml" "eu-prod.yaml" "eu2-prod.yaml" "bnym-dev.yaml" "bnym-prod.yaml" "us-prod.yaml" | cut -c 2-)

      # Flag to track if there are disallowed files
      DISALLOWED_FOUND=false

      # Check for files in the directory that are not in the allowed list
      for file in "$DIR_TO_CHECK"/*; do
        # Get the base name of the file
        filename=$(basename "$file")

        # Check if the filename is in the allowed list
        if [[ ! $filename =~ ^($ALLOWED_PATTERN)$ ]]; then
          echo "Disallowed file found: $filename"
          DISALLOWED_FOUND=true
        fi
      done

      # Final output
      if $DISALLOWED_FOUND; then
        echo "Some files are not allowed."
        exit 1
      else
        echo "All files are allowed."
      fi
    - echo "Linting deployment yaml files"
    - cp ../mono_repo/services/schema/*.yaml .
    - cp ../mono_repo/services/schema/appconfig_schema.json .
    - cp ../mono_repo/services/schema/main_appconfig.json appconfig.json
    - cp ../mono_repo/services/schema/yamllint_rules.yaml yamllint_rules.yaml
    - yamllint --list-files **/*.yaml *.yaml
    - yamllint -s **/*.yaml *.yaml -c yamllint_rules.yaml
    - echo "Validating deployment yaml schema"
    - yamale -s base_values_schema.yaml values.yaml
    - yamale -s tier_values_schema.yaml overrides/prod-tier.yaml
    - yamale -s tier_values_schema.yaml overrides/nonprod-tier.yaml
    - |
      # Iterate over all yaml files in the overrides folder
      for file in overrides/*.yaml; do
          # Extract the filename from the path
          filename=$(basename -- "$file")

          # Check if the file is not prod-tier.yaml or nonprod-tier.yaml
          if [[ "$filename" != "prod-tier.yaml" ]] && [[ "$filename" != "nonprod-tier.yaml" ]]; then
              # Run yamale command on the file
              yamale -s env_values_schema.yaml "$file"
          fi
      done
    - "# Iterate over all yaml files in the overrides folder - validate_resources.sh\nif
      [[ -v ENGINE && \"$ENGINE\" == \"argocd\" ]]; then\n  export CD_INFRA_PROJECT_ID=61508954\n
      \ curl --header \"PRIVATE-TOKEN: $CD_CPU_RAM_REQUEST_LIMIT_READ_ONLY\"  \"https://gitlab.com/api/v4/projects/$CD_INFRA_PROJECT_ID/repository/files/ci-infra%2Fscripts%2Fvalidate_resources.sh/raw?ref=main\"
      -o \"$CI_PROJECT_DIR/validate_resources.sh\"\n  echo \"chmod +x $CI_PROJECT_DIR/validate_resources.sh\"
      \n  chmod +x \"$CI_PROJECT_DIR/validate_resources.sh\"\n  echo \"Searching for
      environments values files...\" \n  ENV_FILES_LIST=$(yamllint --list-files **/*.yaml
      *.yaml | grep -vE 'env_values_schema\\.yaml|tier_values_schema\\.yaml|base_values_schema\\.yaml|yamllint_rules\\.yaml|.*prod-tier\\.yaml|values.yaml'
      || true)\n  if [[ -n \"$ENV_FILES_LIST\" ]]; then\n    echo \"Found environments
      values files\"\n    while IFS= read -r file; do\n      filename=$(basename --
      \"$file\")\n      if [[ \"$filename\" =~ ^(dev[1-9]|dev10|stage|pre1).yaml$
      ]]; then\n        tier_file=\"overrides/nonprod-tier.yaml\"\n      else\n        tier_file=\"overrides/prod-tier.yaml\"
      \ \n      fi\n      echo \"values.yaml <-- $tier_file <-- $file\"\n      yq
      eval-all '. as $item ireduce ({}; . * $item)' values.yaml \"$tier_file\" \"$file\"
      | bash \"$CI_PROJECT_DIR/validate_resources.sh\" -\n    done <<< \"$ENV_FILES_LIST\"\n
      \ else\n    echo \"No environments values files were found. Continuing to the
      tier files.\"\n  fi\necho \"values.yaml <-- overrides/nonprod-tier.yaml\"\nyq
      eval-all '. as $item ireduce ({}; . * $item)' values.yaml overrides/nonprod-tier.yaml
      | bash \"$CI_PROJECT_DIR/validate_resources.sh\" -\necho \"values.yaml <-- overrides/prod-tier.yaml\"
      \nyq eval-all '. as $item ireduce ({}; . * $item)' values.yaml overrides/prod-tier.yaml
      | bash \"$CI_PROJECT_DIR/validate_resources.sh\" -\nelse\n  echo \"Skipping
      resource validation: ENGINE is not set to 'argocd'.\"\nfi\n"
    - ajv validate -s appconfig_schema.json -d appconfig.json
    - echo "Resources verified successfully"
    - echo "Validate filter_policy if exists - should be a valid JSON object"
    - fb deployment:validate . --filter-policy
  - cd ../mono_repo
  - ENV_DESTINATION_PATH=$(echo "${DESTINATION_PATH}/${SVC_NAME}/${ENV}")
  - echo "Copying ${SOURCE_PATH} folder from ${SVC_NAME} service to argocd mono repo
    destination folder at ${ENV_DESTINATION_PATH}"
  - mkdir -pv ${ENV_DESTINATION_PATH}/overrides
  - rm ${ENV_DESTINATION_PATH}/overrides/${ENV}.yaml || true
  - cp  ../${SOURCE_PATH}/values.yaml ${ENV_DESTINATION_PATH}
  - cp ../${SOURCE_PATH}/overrides/${ENV}.yaml  ${ENV_DESTINATION_PATH}/overrides
    || true
  - cp ../${SOURCE_PATH}/overrides/*-tier.yaml  ${ENV_DESTINATION_PATH}/overrides
    || true
  - if [ ! -f ${ENV_DESTINATION_PATH}/appconfig.json ]; then cp ../mono_repo/services/schema/main_appconfig.json
    ${ENV_DESTINATION_PATH}/appconfig.json; fi
  - git status
  - echo "Adding changes to Git"
  - git add ${DESTINATION_PATH}
  - git status
  - COUNT=$(git diff --numstat ${STATE_BRANCH} | awk '{added += $1; deleted += $2}
    END {print added + deleted}')
  - |
    if [ "$COUNT" -eq 0 ]; then
      echo "No changes detected under ${CI_PROJECT_NAME}/${SOURCE_PATH}, exiting"
      exit 0
    fi
  - echo "Committing changes"
  - git commit -m "${CI_JOB_NAME}"
  - echo "Pushing changes to remote"
  - git pull --rebase
  - git status
  - "MAX_RETRIES=3\nINITIAL_DELAY=5\nsuccess=false\n\nfor attempt in $(seq 1 $MAX_RETRIES);
    do\n  if git push; then\n    echo -e \"\\e[32mPush successful\\e[0m\"\n    success=true\n
    \   break\n  else\n    echo -e \"\\e[33mPush failed, retrying ($attempt/$MAX_RETRIES)...\\e[0m\"\n
    \   git pull --rebase\n    \n    # Calculate backoff delay (5s, then 10s, then
    20s)\n    BACKOFF_DELAY=$((INITIAL_DELAY * 2**(attempt-1)))\n    echo \"Waiting
    ${BACKOFF_DELAY} seconds before next attempt...\"\n    sleep $BACKOFF_DELAY\n
    \ fi\ndone\n\nif [ \"$success\" != \"true\" ]; then\n  echo -e \"\\e[31mFailed
    to push after $MAX_RETRIES attempts\\e[0m\"\n  exit 1\nfi\n"
  - git status
  - echo "Resources published to argocd mono repo"
  variables:
    DESTINATION_REPO: https://gitlab.com/fireblocks/devops/iac/argocd.git
    DESTINATION_PROJECT_ID: 50521873
    SOURCE_PATH: deployment
    DESTINATION_PATH: services/shell
    STATE_BRANCH: main
    GITLAB_API_URL: https://gitlab.com/api/v4/projects
    TEMPLATE_REF: "$TEMPLATE_REF"
    GITLAB_RUNNER_TAG: eu2-prod-fr-application-gitlab-runner
    ENV: eu2-prod
  extends:
  - ".publish_resources_eu2-prod-fr"
  - ".manual:deploy_resources"
  needs: []
  rules:
  - if: $IS_PROD_SERVICE != "true"
    when: never
  - if: ($CI_COMMIT_BRANCH == "master" || $CI_COMMIT_BRANCH == "main") && $CI_CONFIG_MANAGEMENT_ENABLED
      == "true"
    when: manual
    allow_failure: true
manual:argocd_sync_resources_eu2-prod-fr:
  stage: manual-override
  retry:
    max: 2
    when:
    - script_failure
  tags:
  - "${GITLAB_RUNNER_TAG}"
  before_script:
  - echo "Install yq & jq from deploy-stage.yml"
  - apk update
  - apk add jq
  - apk add yq
  - |
    if [ ! -d "$SOURCE_PATH" ]; then
      echo "$SOURCE_PATH directory does not exist. Exiting job successfully."
      exit 0
    fi
    echo "$SOURCE_PATH directory exists. Continuing with deployment."
  - apk update
  - apk add curl
  - curl -sSL -o argocd-linux-amd64 https://github.com/argoproj/argo-cd/releases/download/v2.14.9/argocd-linux-amd64
  - install -m 555 argocd-linux-amd64 /usr/local/bin/argocd
  - rm argocd-linux-amd64
  - argocd version --client
  script:
  - echo "Self Service User Guide - https://fireblocks.atlassian.net/wiki/spaces/RD/pages/1413218873/Self+Service+User+Guide"
  - SVC_NAME=$([ "$SERVICE_NAME" ] && echo $SERVICE_NAME || echo $CI_PROJECT_NAME)
  - echo "Syncing resources for ${SVC_NAME} service"
  - ARGOCD_APP_NAME=$(echo "${SVC_NAME}-${ENV}")
  - echo "Refreshing ${ARGOCD_APP_NAME} application"
  - argocd app get ${ARGOCD_APP_NAME} -owide --refresh --insecure --auth-token ${ARGOCD_AUTH_TOKEN}
    --server ${ARGOCD_SERVER}
  - echo "Syncing ${ARGOCD_APP_NAME} application"
  - |
    if [[ "$STRATEGY" == "canary" ]]; then
      argocd app sync --resource '!*:Rollout:*' --resource '!*:Service:*' --prune ${ARGOCD_APP_NAME} --insecure --auth-token ${ARGOCD_AUTH_TOKEN} --server ${ARGOCD_SERVER}
    elif [[ "$STRATEGY" == "in_place" ]]; then
      argocd app sync --resource '!*:Deployment:*' --resource '!*:Service:*' --prune ${ARGOCD_APP_NAME} --insecure --auth-token ${ARGOCD_AUTH_TOKEN} --server ${ARGOCD_SERVER}
    else
      argocd app sync --prune ${ARGOCD_APP_NAME} --insecure --auth-token ${ARGOCD_AUTH_TOKEN} --server ${ARGOCD_SERVER}
    fi
  - echo "Waiting for ${ARGOCD_APP_NAME} application to be synced and healthy"
  - |
    resources_to_sync=$(argocd app get ${ARGOCD_APP_NAME} --insecure --auth-token ${ARGOCD_AUTH_TOKEN} --server ${ARGOCD_SERVER} -o json | jq -r 'select(.status.resources != null) | .status.resources[] | select(.health.status and .kind != "Deployment" and .kind != "Rollout" and .kind != "Ingress" and .kind != "Service") | "\(.group // ""):\(.kind):\(.name)"')
    if [ "x${resources_to_sync}" == "x" ]; then
        echo "There are no resources to sync"
    else
        echo ${resources_to_sync}
        for resource in ${resources_to_sync}; do
            argocd app wait ${ARGOCD_APP_NAME} --resource $resource --health --sync --timeout 600 --loglevel debug --insecure --auth-token ${ARGOCD_AUTH_TOKEN} --server ${ARGOCD_SERVER}
        done
    fi
  variables:
    SOURCE_PATH: deployment
    GITLAB_RUNNER_TAG: devx-application-gitlab-runner
    ARGOCD_SERVER: "${ARGOCD_PROD_SERVER}"
    ARGOCD_AUTH_TOKEN: "${ARGOCD_PROD_SHELL_AUTH_TOKEN}"
    ENV: eu2-prod
  extends:
  - ".argocd_sync_resources_eu2-prod-fr"
  - ".manual:deploy_resources"
  needs:
  - manual:publish_resources_eu2-prod-fr
  rules:
  - if: $IS_PROD_SERVICE != "true"
    when: never
  - if: ($CI_COMMIT_BRANCH == "master" || $CI_COMMIT_BRANCH == "main") && $CI_CONFIG_MANAGEMENT_ENABLED
      == "true"
    when: manual
    allow_failure: true
manual:publish_resources_bnym-dev:
  stage: manual-override
  retry:
    max: 2
    when:
    - script_failure
  tags:
  - "${GITLAB_RUNNER_TAG}"
  before_script:
  - printf "%s:%s\n" DESTINATION_REPO "$DESTINATION_REPO" DESTINATION_PROJECT_ID "$DESTINATION_PROJECT_ID"
    SOURCE_PATH "$SOURCE_PATH" DESTINATION_PATH "$DESTINATION_PATH" STATE_BRANCH "$STATE_BRANCH"
    GITLAB_API_URL "$GITLAB_API_URL"
  - |
    if [ ! -d "$SOURCE_PATH" ]; then
      echo "$SOURCE_PATH directory does not exist. Exiting job successfully."
      exit 0
    fi
    echo "$SOURCE_PATH directory exists. Continuing with deployment."
  - - apk update
    - apk add curl jq yq py3-pip
    - pip3 install --upgrade pip
    - pip3 install yamllint
    - pip3 install yamale --break-system-packages
    - npm install -g ajv-cli
    - echo "Configuring Git"
    - echo "https://argocd-ci-push:${ARGOCD_GITLAB_ACCESS_TOKEN}@gitlab.com" > ~/.git-credentials
    - git remote set-url origin https://argocd-ci-push:${ARGOCD_GITLAB_ACCESS_TOKEN}@gitlab.com/fireblocks/devops/iac/argocd.git
    - git config --global user.email "devops@fireblocks.com"
    - git config --global user.name "argocd-ci-push"
    - git config --global credential.helper store
    - touch .npmrc
    - npm config set --location=user @fireblocks:registry https://gitlab.com/api/v4/packages/npm/
    - npm config set --location=user '//gitlab.com/api/v4/packages/npm/:_authToken'
      "${NPM_REG_TOKEN}"
    - npm config set --location=user '//gitlab.com/api/v4/projects/20565764/packages/npm/:_authToken'
      "${NPM_REG_TOKEN}"
    - echo "@fireblocks:registry=https://gitlab.com/api/v4/packages/npm/">>.npmrc
    - echo "//gitlab.com/api/v4/packages/npm/:_authToken=${NPM_REG_TOKEN}">>.npmrc
    - echo "//gitlab.com/api/v4/projects/20565764/packages/npm/:_authToken=${NPM_REG_TOKEN}">>.npmrc
    - yarn global add @fireblocks/fb-cli
  script:
  - - echo "Self Service User Guide - https://fireblocks.atlassian.net/wiki/spaces/RD/pages/1413218873/Self+Service+User+Guide"
    - SVC_NAME=$([ "$SERVICE_NAME" ] && echo $SERVICE_NAME || echo $CI_PROJECT_NAME)
    - echo "Verifying deployment folder for ${SVC_NAME} service"
    - git clone ${DESTINATION_REPO} mono_repo
    - cd mono_repo
    - git fetch --all
    - git checkout ${STATE_BRANCH}
    - git pull origin ${STATE_BRANCH} --no-rebase
    - cd ../${SOURCE_PATH}
    - |
      # Define the paths
      values_file="values.yaml"

      # Check for values.yaml in the deployment folder
      if [ ! -f "$values_file" ]; then
          echo "Error: The values.yaml file is missing in the ${SOURCE_PATH} folder."
          exit 1
      fi

      echo "Success: All required files are present"
    - |
      # Directory to check
      DIR_TO_CHECK="overrides/"

      # List of allowed files
      ALLOWED_PATTERN=$(printf "|%s" "nonprod-tier.yaml" "prod-tier.yaml" "iac-dev.yaml" "localstack.yaml" "dev1.yaml" "dev2.yaml" "dev3.yaml" "dev4.yaml" "dev5.yaml" "dev6.yaml" "dev7.yaml" "dev8.yaml" "dev9.yaml" "dev10.yaml" "dev11.yaml" "dev11.yaml" "dev12.yaml" "dev13.yaml" "dev14.yaml" "dev15.yaml" "pre1.yaml" "stage.yaml" "sandbox.yaml" "eu-prod.yaml" "eu2-prod.yaml" "bnym-dev.yaml" "bnym-prod.yaml" "us-prod.yaml" | cut -c 2-)

      # Flag to track if there are disallowed files
      DISALLOWED_FOUND=false

      # Check for files in the directory that are not in the allowed list
      for file in "$DIR_TO_CHECK"/*; do
        # Get the base name of the file
        filename=$(basename "$file")

        # Check if the filename is in the allowed list
        if [[ ! $filename =~ ^($ALLOWED_PATTERN)$ ]]; then
          echo "Disallowed file found: $filename"
          DISALLOWED_FOUND=true
        fi
      done

      # Final output
      if $DISALLOWED_FOUND; then
        echo "Some files are not allowed."
        exit 1
      else
        echo "All files are allowed."
      fi
    - echo "Linting deployment yaml files"
    - cp ../mono_repo/services/schema/*.yaml .
    - cp ../mono_repo/services/schema/appconfig_schema.json .
    - cp ../mono_repo/services/schema/main_appconfig.json appconfig.json
    - cp ../mono_repo/services/schema/yamllint_rules.yaml yamllint_rules.yaml
    - yamllint --list-files **/*.yaml *.yaml
    - yamllint -s **/*.yaml *.yaml -c yamllint_rules.yaml
    - echo "Validating deployment yaml schema"
    - yamale -s base_values_schema.yaml values.yaml
    - yamale -s tier_values_schema.yaml overrides/prod-tier.yaml
    - yamale -s tier_values_schema.yaml overrides/nonprod-tier.yaml
    - |
      # Iterate over all yaml files in the overrides folder
      for file in overrides/*.yaml; do
          # Extract the filename from the path
          filename=$(basename -- "$file")

          # Check if the file is not prod-tier.yaml or nonprod-tier.yaml
          if [[ "$filename" != "prod-tier.yaml" ]] && [[ "$filename" != "nonprod-tier.yaml" ]]; then
              # Run yamale command on the file
              yamale -s env_values_schema.yaml "$file"
          fi
      done
    - "# Iterate over all yaml files in the overrides folder - validate_resources.sh\nif
      [[ -v ENGINE && \"$ENGINE\" == \"argocd\" ]]; then\n  export CD_INFRA_PROJECT_ID=61508954\n
      \ curl --header \"PRIVATE-TOKEN: $CD_CPU_RAM_REQUEST_LIMIT_READ_ONLY\"  \"https://gitlab.com/api/v4/projects/$CD_INFRA_PROJECT_ID/repository/files/ci-infra%2Fscripts%2Fvalidate_resources.sh/raw?ref=main\"
      -o \"$CI_PROJECT_DIR/validate_resources.sh\"\n  echo \"chmod +x $CI_PROJECT_DIR/validate_resources.sh\"
      \n  chmod +x \"$CI_PROJECT_DIR/validate_resources.sh\"\n  echo \"Searching for
      environments values files...\" \n  ENV_FILES_LIST=$(yamllint --list-files **/*.yaml
      *.yaml | grep -vE 'env_values_schema\\.yaml|tier_values_schema\\.yaml|base_values_schema\\.yaml|yamllint_rules\\.yaml|.*prod-tier\\.yaml|values.yaml'
      || true)\n  if [[ -n \"$ENV_FILES_LIST\" ]]; then\n    echo \"Found environments
      values files\"\n    while IFS= read -r file; do\n      filename=$(basename --
      \"$file\")\n      if [[ \"$filename\" =~ ^(dev[1-9]|dev10|stage|pre1).yaml$
      ]]; then\n        tier_file=\"overrides/nonprod-tier.yaml\"\n      else\n        tier_file=\"overrides/prod-tier.yaml\"
      \ \n      fi\n      echo \"values.yaml <-- $tier_file <-- $file\"\n      yq
      eval-all '. as $item ireduce ({}; . * $item)' values.yaml \"$tier_file\" \"$file\"
      | bash \"$CI_PROJECT_DIR/validate_resources.sh\" -\n    done <<< \"$ENV_FILES_LIST\"\n
      \ else\n    echo \"No environments values files were found. Continuing to the
      tier files.\"\n  fi\necho \"values.yaml <-- overrides/nonprod-tier.yaml\"\nyq
      eval-all '. as $item ireduce ({}; . * $item)' values.yaml overrides/nonprod-tier.yaml
      | bash \"$CI_PROJECT_DIR/validate_resources.sh\" -\necho \"values.yaml <-- overrides/prod-tier.yaml\"
      \nyq eval-all '. as $item ireduce ({}; . * $item)' values.yaml overrides/prod-tier.yaml
      | bash \"$CI_PROJECT_DIR/validate_resources.sh\" -\nelse\n  echo \"Skipping
      resource validation: ENGINE is not set to 'argocd'.\"\nfi\n"
    - ajv validate -s appconfig_schema.json -d appconfig.json
    - echo "Resources verified successfully"
    - echo "Validate filter_policy if exists - should be a valid JSON object"
    - fb deployment:validate . --filter-policy
  - cd ../mono_repo
  - ENV_DESTINATION_PATH=$(echo "${DESTINATION_PATH}/${SVC_NAME}/${ENV}")
  - echo "Copying ${SOURCE_PATH} folder from ${SVC_NAME} service to argocd mono repo
    destination folder at ${ENV_DESTINATION_PATH}"
  - mkdir -pv ${ENV_DESTINATION_PATH}/overrides
  - rm ${ENV_DESTINATION_PATH}/overrides/${ENV}.yaml || true
  - cp  ../${SOURCE_PATH}/values.yaml ${ENV_DESTINATION_PATH}
  - cp ../${SOURCE_PATH}/overrides/${ENV}.yaml  ${ENV_DESTINATION_PATH}/overrides
    || true
  - cp ../${SOURCE_PATH}/overrides/*-tier.yaml  ${ENV_DESTINATION_PATH}/overrides
    || true
  - if [ ! -f ${ENV_DESTINATION_PATH}/appconfig.json ]; then cp ../mono_repo/services/schema/main_appconfig.json
    ${ENV_DESTINATION_PATH}/appconfig.json; fi
  - git status
  - echo "Adding changes to Git"
  - git add ${DESTINATION_PATH}
  - git status
  - COUNT=$(git diff --numstat ${STATE_BRANCH} | awk '{added += $1; deleted += $2}
    END {print added + deleted}')
  - |
    if [ "$COUNT" -eq 0 ]; then
      echo "No changes detected under ${CI_PROJECT_NAME}/${SOURCE_PATH}, exiting"
      exit 0
    fi
  - echo "Committing changes"
  - git commit -m "${CI_JOB_NAME}"
  - echo "Pushing changes to remote"
  - git pull --rebase
  - git status
  - "MAX_RETRIES=3\nINITIAL_DELAY=5\nsuccess=false\n\nfor attempt in $(seq 1 $MAX_RETRIES);
    do\n  if git push; then\n    echo -e \"\\e[32mPush successful\\e[0m\"\n    success=true\n
    \   break\n  else\n    echo -e \"\\e[33mPush failed, retrying ($attempt/$MAX_RETRIES)...\\e[0m\"\n
    \   git pull --rebase\n    \n    # Calculate backoff delay (5s, then 10s, then
    20s)\n    BACKOFF_DELAY=$((INITIAL_DELAY * 2**(attempt-1)))\n    echo \"Waiting
    ${BACKOFF_DELAY} seconds before next attempt...\"\n    sleep $BACKOFF_DELAY\n
    \ fi\ndone\n\nif [ \"$success\" != \"true\" ]; then\n  echo -e \"\\e[31mFailed
    to push after $MAX_RETRIES attempts\\e[0m\"\n  exit 1\nfi\n"
  - git status
  - echo "Resources published to argocd mono repo"
  variables:
    DESTINATION_REPO: https://gitlab.com/fireblocks/devops/iac/argocd.git
    DESTINATION_PROJECT_ID: 50521873
    SOURCE_PATH: deployment
    DESTINATION_PATH: services/shell
    STATE_BRANCH: main
    GITLAB_API_URL: https://gitlab.com/api/v4/projects
    TEMPLATE_REF: "$TEMPLATE_REF"
    GITLAB_RUNNER_TAG: bnym-dev-application-gitlab-runner
    ENV: bnym-dev
  extends:
  - ".publish_resources_bnym-dev"
  - ".manual:deploy_resources"
  needs: []
  rules:
  - if: $IS_PROD_SERVICE != "true"
    when: never
  - if: ($CI_COMMIT_BRANCH == "master" || $CI_COMMIT_BRANCH == "main") && $CI_CONFIG_MANAGEMENT_ENABLED
      == "true"
    when: manual
    allow_failure: true
manual:argocd_sync_resources_bnym-dev:
  stage: manual-override
  retry:
    max: 2
    when:
    - script_failure
  tags:
  - "${GITLAB_RUNNER_TAG}"
  before_script:
  - echo "Install yq & jq from deploy-stage.yml"
  - apk update
  - apk add jq
  - apk add yq
  - |
    if [ ! -d "$SOURCE_PATH" ]; then
      echo "$SOURCE_PATH directory does not exist. Exiting job successfully."
      exit 0
    fi
    echo "$SOURCE_PATH directory exists. Continuing with deployment."
  - apk update
  - apk add curl
  - curl -sSL -o argocd-linux-amd64 https://github.com/argoproj/argo-cd/releases/download/v2.14.9/argocd-linux-amd64
  - install -m 555 argocd-linux-amd64 /usr/local/bin/argocd
  - rm argocd-linux-amd64
  - argocd version --client
  script:
  - echo "Self Service User Guide - https://fireblocks.atlassian.net/wiki/spaces/RD/pages/1413218873/Self+Service+User+Guide"
  - SVC_NAME=$([ "$SERVICE_NAME" ] && echo $SERVICE_NAME || echo $CI_PROJECT_NAME)
  - echo "Syncing resources for ${SVC_NAME} service"
  - ARGOCD_APP_NAME=$(echo "${SVC_NAME}-${ENV}")
  - echo "Refreshing ${ARGOCD_APP_NAME} application"
  - argocd app get ${ARGOCD_APP_NAME} -owide --refresh --insecure --auth-token ${ARGOCD_AUTH_TOKEN}
    --server ${ARGOCD_SERVER}
  - echo "Syncing ${ARGOCD_APP_NAME} application"
  - |
    if [[ "$STRATEGY" == "canary" ]]; then
      argocd app sync --resource '!*:Rollout:*' --resource '!*:Service:*' --prune ${ARGOCD_APP_NAME} --insecure --auth-token ${ARGOCD_AUTH_TOKEN} --server ${ARGOCD_SERVER}
    elif [[ "$STRATEGY" == "in_place" ]]; then
      argocd app sync --resource '!*:Deployment:*' --resource '!*:Service:*' --prune ${ARGOCD_APP_NAME} --insecure --auth-token ${ARGOCD_AUTH_TOKEN} --server ${ARGOCD_SERVER}
    else
      argocd app sync --prune ${ARGOCD_APP_NAME} --insecure --auth-token ${ARGOCD_AUTH_TOKEN} --server ${ARGOCD_SERVER}
    fi
  - echo "Waiting for ${ARGOCD_APP_NAME} application to be synced and healthy"
  - |
    resources_to_sync=$(argocd app get ${ARGOCD_APP_NAME} --insecure --auth-token ${ARGOCD_AUTH_TOKEN} --server ${ARGOCD_SERVER} -o json | jq -r 'select(.status.resources != null) | .status.resources[] | select(.health.status and .kind != "Deployment" and .kind != "Rollout" and .kind != "Ingress" and .kind != "Service") | "\(.group // ""):\(.kind):\(.name)"')
    if [ "x${resources_to_sync}" == "x" ]; then
        echo "There are no resources to sync"
    else
        echo ${resources_to_sync}
        for resource in ${resources_to_sync}; do
            argocd app wait ${ARGOCD_APP_NAME} --resource $resource --health --sync --timeout 600 --loglevel debug --insecure --auth-token ${ARGOCD_AUTH_TOKEN} --server ${ARGOCD_SERVER}
        done
    fi
  variables:
    SOURCE_PATH: deployment
    GITLAB_RUNNER_TAG: devx-application-gitlab-runner
    ARGOCD_SERVER: "${ARGOCD_PROD_SERVER}"
    ARGOCD_AUTH_TOKEN: "${ARGOCD_PROD_SHELL_AUTH_TOKEN}"
    ENV: bnym-dev
  extends:
  - ".argocd_sync_resources_bnym-dev"
  - ".manual:deploy_resources"
  needs:
  - manual:publish_resources_bnym-dev
  rules:
  - if: $IS_PROD_SERVICE != "true"
    when: never
  - if: ($CI_COMMIT_BRANCH == "master" || $CI_COMMIT_BRANCH == "main") && $CI_CONFIG_MANAGEMENT_ENABLED
      == "true"
    when: manual
    allow_failure: true
manual:publish_resources_bnym-prod:
  stage: manual-override
  retry:
    max: 2
    when:
    - script_failure
  tags:
  - "${GITLAB_RUNNER_TAG}"
  before_script:
  - printf "%s:%s\n" DESTINATION_REPO "$DESTINATION_REPO" DESTINATION_PROJECT_ID "$DESTINATION_PROJECT_ID"
    SOURCE_PATH "$SOURCE_PATH" DESTINATION_PATH "$DESTINATION_PATH" STATE_BRANCH "$STATE_BRANCH"
    GITLAB_API_URL "$GITLAB_API_URL"
  - |
    if [ ! -d "$SOURCE_PATH" ]; then
      echo "$SOURCE_PATH directory does not exist. Exiting job successfully."
      exit 0
    fi
    echo "$SOURCE_PATH directory exists. Continuing with deployment."
  - - apk update
    - apk add curl jq yq py3-pip
    - pip3 install --upgrade pip
    - pip3 install yamllint
    - pip3 install yamale --break-system-packages
    - npm install -g ajv-cli
    - echo "Configuring Git"
    - echo "https://argocd-ci-push:${ARGOCD_GITLAB_ACCESS_TOKEN}@gitlab.com" > ~/.git-credentials
    - git remote set-url origin https://argocd-ci-push:${ARGOCD_GITLAB_ACCESS_TOKEN}@gitlab.com/fireblocks/devops/iac/argocd.git
    - git config --global user.email "devops@fireblocks.com"
    - git config --global user.name "argocd-ci-push"
    - git config --global credential.helper store
    - touch .npmrc
    - npm config set --location=user @fireblocks:registry https://gitlab.com/api/v4/packages/npm/
    - npm config set --location=user '//gitlab.com/api/v4/packages/npm/:_authToken'
      "${NPM_REG_TOKEN}"
    - npm config set --location=user '//gitlab.com/api/v4/projects/20565764/packages/npm/:_authToken'
      "${NPM_REG_TOKEN}"
    - echo "@fireblocks:registry=https://gitlab.com/api/v4/packages/npm/">>.npmrc
    - echo "//gitlab.com/api/v4/packages/npm/:_authToken=${NPM_REG_TOKEN}">>.npmrc
    - echo "//gitlab.com/api/v4/projects/20565764/packages/npm/:_authToken=${NPM_REG_TOKEN}">>.npmrc
    - yarn global add @fireblocks/fb-cli
  script:
  - - echo "Self Service User Guide - https://fireblocks.atlassian.net/wiki/spaces/RD/pages/1413218873/Self+Service+User+Guide"
    - SVC_NAME=$([ "$SERVICE_NAME" ] && echo $SERVICE_NAME || echo $CI_PROJECT_NAME)
    - echo "Verifying deployment folder for ${SVC_NAME} service"
    - git clone ${DESTINATION_REPO} mono_repo
    - cd mono_repo
    - git fetch --all
    - git checkout ${STATE_BRANCH}
    - git pull origin ${STATE_BRANCH} --no-rebase
    - cd ../${SOURCE_PATH}
    - |
      # Define the paths
      values_file="values.yaml"

      # Check for values.yaml in the deployment folder
      if [ ! -f "$values_file" ]; then
          echo "Error: The values.yaml file is missing in the ${SOURCE_PATH} folder."
          exit 1
      fi

      echo "Success: All required files are present"
    - |
      # Directory to check
      DIR_TO_CHECK="overrides/"

      # List of allowed files
      ALLOWED_PATTERN=$(printf "|%s" "nonprod-tier.yaml" "prod-tier.yaml" "iac-dev.yaml" "localstack.yaml" "dev1.yaml" "dev2.yaml" "dev3.yaml" "dev4.yaml" "dev5.yaml" "dev6.yaml" "dev7.yaml" "dev8.yaml" "dev9.yaml" "dev10.yaml" "dev11.yaml" "dev11.yaml" "dev12.yaml" "dev13.yaml" "dev14.yaml" "dev15.yaml" "pre1.yaml" "stage.yaml" "sandbox.yaml" "eu-prod.yaml" "eu2-prod.yaml" "bnym-dev.yaml" "bnym-prod.yaml" "us-prod.yaml" | cut -c 2-)

      # Flag to track if there are disallowed files
      DISALLOWED_FOUND=false

      # Check for files in the directory that are not in the allowed list
      for file in "$DIR_TO_CHECK"/*; do
        # Get the base name of the file
        filename=$(basename "$file")

        # Check if the filename is in the allowed list
        if [[ ! $filename =~ ^($ALLOWED_PATTERN)$ ]]; then
          echo "Disallowed file found: $filename"
          DISALLOWED_FOUND=true
        fi
      done

      # Final output
      if $DISALLOWED_FOUND; then
        echo "Some files are not allowed."
        exit 1
      else
        echo "All files are allowed."
      fi
    - echo "Linting deployment yaml files"
    - cp ../mono_repo/services/schema/*.yaml .
    - cp ../mono_repo/services/schema/appconfig_schema.json .
    - cp ../mono_repo/services/schema/main_appconfig.json appconfig.json
    - cp ../mono_repo/services/schema/yamllint_rules.yaml yamllint_rules.yaml
    - yamllint --list-files **/*.yaml *.yaml
    - yamllint -s **/*.yaml *.yaml -c yamllint_rules.yaml
    - echo "Validating deployment yaml schema"
    - yamale -s base_values_schema.yaml values.yaml
    - yamale -s tier_values_schema.yaml overrides/prod-tier.yaml
    - yamale -s tier_values_schema.yaml overrides/nonprod-tier.yaml
    - |
      # Iterate over all yaml files in the overrides folder
      for file in overrides/*.yaml; do
          # Extract the filename from the path
          filename=$(basename -- "$file")

          # Check if the file is not prod-tier.yaml or nonprod-tier.yaml
          if [[ "$filename" != "prod-tier.yaml" ]] && [[ "$filename" != "nonprod-tier.yaml" ]]; then
              # Run yamale command on the file
              yamale -s env_values_schema.yaml "$file"
          fi
      done
    - "# Iterate over all yaml files in the overrides folder - validate_resources.sh\nif
      [[ -v ENGINE && \"$ENGINE\" == \"argocd\" ]]; then\n  export CD_INFRA_PROJECT_ID=61508954\n
      \ curl --header \"PRIVATE-TOKEN: $CD_CPU_RAM_REQUEST_LIMIT_READ_ONLY\"  \"https://gitlab.com/api/v4/projects/$CD_INFRA_PROJECT_ID/repository/files/ci-infra%2Fscripts%2Fvalidate_resources.sh/raw?ref=main\"
      -o \"$CI_PROJECT_DIR/validate_resources.sh\"\n  echo \"chmod +x $CI_PROJECT_DIR/validate_resources.sh\"
      \n  chmod +x \"$CI_PROJECT_DIR/validate_resources.sh\"\n  echo \"Searching for
      environments values files...\" \n  ENV_FILES_LIST=$(yamllint --list-files **/*.yaml
      *.yaml | grep -vE 'env_values_schema\\.yaml|tier_values_schema\\.yaml|base_values_schema\\.yaml|yamllint_rules\\.yaml|.*prod-tier\\.yaml|values.yaml'
      || true)\n  if [[ -n \"$ENV_FILES_LIST\" ]]; then\n    echo \"Found environments
      values files\"\n    while IFS= read -r file; do\n      filename=$(basename --
      \"$file\")\n      if [[ \"$filename\" =~ ^(dev[1-9]|dev10|stage|pre1).yaml$
      ]]; then\n        tier_file=\"overrides/nonprod-tier.yaml\"\n      else\n        tier_file=\"overrides/prod-tier.yaml\"
      \ \n      fi\n      echo \"values.yaml <-- $tier_file <-- $file\"\n      yq
      eval-all '. as $item ireduce ({}; . * $item)' values.yaml \"$tier_file\" \"$file\"
      | bash \"$CI_PROJECT_DIR/validate_resources.sh\" -\n    done <<< \"$ENV_FILES_LIST\"\n
      \ else\n    echo \"No environments values files were found. Continuing to the
      tier files.\"\n  fi\necho \"values.yaml <-- overrides/nonprod-tier.yaml\"\nyq
      eval-all '. as $item ireduce ({}; . * $item)' values.yaml overrides/nonprod-tier.yaml
      | bash \"$CI_PROJECT_DIR/validate_resources.sh\" -\necho \"values.yaml <-- overrides/prod-tier.yaml\"
      \nyq eval-all '. as $item ireduce ({}; . * $item)' values.yaml overrides/prod-tier.yaml
      | bash \"$CI_PROJECT_DIR/validate_resources.sh\" -\nelse\n  echo \"Skipping
      resource validation: ENGINE is not set to 'argocd'.\"\nfi\n"
    - ajv validate -s appconfig_schema.json -d appconfig.json
    - echo "Resources verified successfully"
    - echo "Validate filter_policy if exists - should be a valid JSON object"
    - fb deployment:validate . --filter-policy
  - cd ../mono_repo
  - ENV_DESTINATION_PATH=$(echo "${DESTINATION_PATH}/${SVC_NAME}/${ENV}")
  - echo "Copying ${SOURCE_PATH} folder from ${SVC_NAME} service to argocd mono repo
    destination folder at ${ENV_DESTINATION_PATH}"
  - mkdir -pv ${ENV_DESTINATION_PATH}/overrides
  - rm ${ENV_DESTINATION_PATH}/overrides/${ENV}.yaml || true
  - cp  ../${SOURCE_PATH}/values.yaml ${ENV_DESTINATION_PATH}
  - cp ../${SOURCE_PATH}/overrides/${ENV}.yaml  ${ENV_DESTINATION_PATH}/overrides
    || true
  - cp ../${SOURCE_PATH}/overrides/*-tier.yaml  ${ENV_DESTINATION_PATH}/overrides
    || true
  - if [ ! -f ${ENV_DESTINATION_PATH}/appconfig.json ]; then cp ../mono_repo/services/schema/main_appconfig.json
    ${ENV_DESTINATION_PATH}/appconfig.json; fi
  - git status
  - echo "Adding changes to Git"
  - git add ${DESTINATION_PATH}
  - git status
  - COUNT=$(git diff --numstat ${STATE_BRANCH} | awk '{added += $1; deleted += $2}
    END {print added + deleted}')
  - |
    if [ "$COUNT" -eq 0 ]; then
      echo "No changes detected under ${CI_PROJECT_NAME}/${SOURCE_PATH}, exiting"
      exit 0
    fi
  - echo "Committing changes"
  - git commit -m "${CI_JOB_NAME}"
  - echo "Pushing changes to remote"
  - git pull --rebase
  - git status
  - "MAX_RETRIES=3\nINITIAL_DELAY=5\nsuccess=false\n\nfor attempt in $(seq 1 $MAX_RETRIES);
    do\n  if git push; then\n    echo -e \"\\e[32mPush successful\\e[0m\"\n    success=true\n
    \   break\n  else\n    echo -e \"\\e[33mPush failed, retrying ($attempt/$MAX_RETRIES)...\\e[0m\"\n
    \   git pull --rebase\n    \n    # Calculate backoff delay (5s, then 10s, then
    20s)\n    BACKOFF_DELAY=$((INITIAL_DELAY * 2**(attempt-1)))\n    echo \"Waiting
    ${BACKOFF_DELAY} seconds before next attempt...\"\n    sleep $BACKOFF_DELAY\n
    \ fi\ndone\n\nif [ \"$success\" != \"true\" ]; then\n  echo -e \"\\e[31mFailed
    to push after $MAX_RETRIES attempts\\e[0m\"\n  exit 1\nfi\n"
  - git status
  - echo "Resources published to argocd mono repo"
  variables:
    DESTINATION_REPO: https://gitlab.com/fireblocks/devops/iac/argocd.git
    DESTINATION_PROJECT_ID: 50521873
    SOURCE_PATH: deployment
    DESTINATION_PATH: services/shell
    STATE_BRANCH: main
    GITLAB_API_URL: https://gitlab.com/api/v4/projects
    TEMPLATE_REF: "$TEMPLATE_REF"
    GITLAB_RUNNER_TAG: bnym-prod-application-gitlab-runner
    ENV: bnym-prod
  extends:
  - ".publish_resources_bnym-prod"
  - ".manual:deploy_resources"
  needs: []
  rules:
  - if: $IS_PROD_SERVICE != "true"
    when: never
  - if: ($CI_COMMIT_BRANCH == "master" || $CI_COMMIT_BRANCH == "main") && $CI_CONFIG_MANAGEMENT_ENABLED
      == "true"
    when: manual
    allow_failure: true
manual:argocd_sync_resources_bnym-prod:
  stage: manual-override
  retry:
    max: 2
    when:
    - script_failure
  tags:
  - "${GITLAB_RUNNER_TAG}"
  before_script:
  - echo "Install yq & jq from deploy-stage.yml"
  - apk update
  - apk add jq
  - apk add yq
  - |
    if [ ! -d "$SOURCE_PATH" ]; then
      echo "$SOURCE_PATH directory does not exist. Exiting job successfully."
      exit 0
    fi
    echo "$SOURCE_PATH directory exists. Continuing with deployment."
  - apk update
  - apk add curl
  - curl -sSL -o argocd-linux-amd64 https://github.com/argoproj/argo-cd/releases/download/v2.14.9/argocd-linux-amd64
  - install -m 555 argocd-linux-amd64 /usr/local/bin/argocd
  - rm argocd-linux-amd64
  - argocd version --client
  script:
  - echo "Self Service User Guide - https://fireblocks.atlassian.net/wiki/spaces/RD/pages/1413218873/Self+Service+User+Guide"
  - SVC_NAME=$([ "$SERVICE_NAME" ] && echo $SERVICE_NAME || echo $CI_PROJECT_NAME)
  - echo "Syncing resources for ${SVC_NAME} service"
  - ARGOCD_APP_NAME=$(echo "${SVC_NAME}-${ENV}")
  - echo "Refreshing ${ARGOCD_APP_NAME} application"
  - argocd app get ${ARGOCD_APP_NAME} -owide --refresh --insecure --auth-token ${ARGOCD_AUTH_TOKEN}
    --server ${ARGOCD_SERVER}
  - echo "Syncing ${ARGOCD_APP_NAME} application"
  - |
    if [[ "$STRATEGY" == "canary" ]]; then
      argocd app sync --resource '!*:Rollout:*' --resource '!*:Service:*' --prune ${ARGOCD_APP_NAME} --insecure --auth-token ${ARGOCD_AUTH_TOKEN} --server ${ARGOCD_SERVER}
    elif [[ "$STRATEGY" == "in_place" ]]; then
      argocd app sync --resource '!*:Deployment:*' --resource '!*:Service:*' --prune ${ARGOCD_APP_NAME} --insecure --auth-token ${ARGOCD_AUTH_TOKEN} --server ${ARGOCD_SERVER}
    else
      argocd app sync --prune ${ARGOCD_APP_NAME} --insecure --auth-token ${ARGOCD_AUTH_TOKEN} --server ${ARGOCD_SERVER}
    fi
  - echo "Waiting for ${ARGOCD_APP_NAME} application to be synced and healthy"
  - |
    resources_to_sync=$(argocd app get ${ARGOCD_APP_NAME} --insecure --auth-token ${ARGOCD_AUTH_TOKEN} --server ${ARGOCD_SERVER} -o json | jq -r 'select(.status.resources != null) | .status.resources[] | select(.health.status and .kind != "Deployment" and .kind != "Rollout" and .kind != "Ingress" and .kind != "Service") | "\(.group // ""):\(.kind):\(.name)"')
    if [ "x${resources_to_sync}" == "x" ]; then
        echo "There are no resources to sync"
    else
        echo ${resources_to_sync}
        for resource in ${resources_to_sync}; do
            argocd app wait ${ARGOCD_APP_NAME} --resource $resource --health --sync --timeout 600 --loglevel debug --insecure --auth-token ${ARGOCD_AUTH_TOKEN} --server ${ARGOCD_SERVER}
        done
    fi
  variables:
    SOURCE_PATH: deployment
    GITLAB_RUNNER_TAG: devx-application-gitlab-runner
    ARGOCD_SERVER: "${ARGOCD_PROD_SERVER}"
    ARGOCD_AUTH_TOKEN: "${ARGOCD_PROD_SHELL_AUTH_TOKEN}"
    ENV: bnym-prod
  extends:
  - ".argocd_sync_resources_bnym-prod"
  - ".manual:deploy_resources"
  needs:
  - manual:publish_resources_bnym-prod
  rules:
  - if: $IS_PROD_SERVICE != "true"
    when: never
  - if: ($CI_COMMIT_BRANCH == "master" || $CI_COMMIT_BRANCH == "main") && $CI_CONFIG_MANAGEMENT_ENABLED
      == "true"
    when: manual
    allow_failure: true
".release_common":
  image: registry.gitlab.com/gitlab-org/release-cli:latest
  retry: 2
  before_script:
  - apk add nodejs yarn npm bash git python3 make docker-compose curl
  - touch .npmrc
  - npm config set --location=user @fireblocks:registry https://gitlab.com/api/v4/packages/npm/
  - npm config set --location=user '//gitlab.com/api/v4/packages/npm/:_authToken'
    "${NPM_REG_TOKEN}"
  - npm config set --location=user '//gitlab.com/api/v4/projects/20565764/packages/npm/:_authToken'
    "${NPM_REG_TOKEN}"
  - echo "@fireblocks:registry=https://gitlab.com/api/v4/packages/npm/">>.npmrc
  - echo "//gitlab.com/api/v4/packages/npm/:_authToken=${NPM_REG_TOKEN}">>.npmrc
  - echo "//gitlab.com/api/v4/projects/20565764/packages/npm/:_authToken=${NPM_REG_TOKEN}">>.npmrc
  - yarn global add @fireblocks/fb-cli auto-changelog
  tags:
  - build-shell
  rules:
  - if: "$CI_COMMIT_TAG"
    when: never
  - if: "$CI_COMMIT_BRANCH == $CI_DEFAULT_BRANCH"
  script:
  - export VERSION=$(fb bump-version)
  - release-cli create --name "$VERSION" --description ./VERSION_CHANGELOG.md --tag-name
    "${VERSION}" --ref "$CI_COMMIT_SHA"
release:
  image: registry.gitlab.com/gitlab-org/release-cli:latest
  retry: 2
  before_script:
  - apk add nodejs yarn npm bash git python3 make docker-compose curl
  - touch .npmrc
  - npm config set --location=user @fireblocks:registry https://gitlab.com/api/v4/packages/npm/
  - npm config set --location=user '//gitlab.com/api/v4/packages/npm/:_authToken'
    "${NPM_REG_TOKEN}"
  - npm config set --location=user '//gitlab.com/api/v4/projects/20565764/packages/npm/:_authToken'
    "${NPM_REG_TOKEN}"
  - echo "@fireblocks:registry=https://gitlab.com/api/v4/packages/npm/">>.npmrc
  - echo "//gitlab.com/api/v4/packages/npm/:_authToken=${NPM_REG_TOKEN}">>.npmrc
  - echo "//gitlab.com/api/v4/projects/20565764/packages/npm/:_authToken=${NPM_REG_TOKEN}">>.npmrc
  - yarn global add @fireblocks/fb-cli auto-changelog
  tags:
  - devx-application-gitlab-runner
  rules:
  - if: $IS_PROD_SERVICE != "true" && $CI_PIPELINE_SOURCE != 'merge_request_event'
      && ($CI_COMMIT_BRANCH == "master" || $CI_COMMIT_BRANCH == "main")
    when: manual
  - if: "$CI_COMMIT_TAG"
    when: never
  - if: $CI_COMMIT_BRANCH == "master" || $CI_COMMIT_BRANCH == "main"
  script:
  - export VERSION=$(fb bump-version)
  - release-cli create --name "$VERSION" --description ./VERSION_CHANGELOG.md --tag-name
    "${VERSION}" --ref "$CI_COMMIT_SHA"
  extends: ".release_common"
  allow_failure: true
  stage: release
  needs:
  - job: deploy_prod-us
    optional: true
  - job: deploy_us_prod_k8s
    optional: true
  - job: deploy_prod_sandbox_k8s
    optional: true
  - job: deploy_prod-sandbox
    optional: true
  - job: deploy_eu_prod_k8s
    optional: true
  - job: deploy_eu-prod-fr
    optional: true
release-manual:
  image: registry.gitlab.com/gitlab-org/release-cli:latest
  retry: 2
  before_script:
  - apk add nodejs yarn npm bash git python3 make docker-compose curl
  - touch .npmrc
  - npm config set --location=user @fireblocks:registry https://gitlab.com/api/v4/packages/npm/
  - npm config set --location=user '//gitlab.com/api/v4/packages/npm/:_authToken'
    "${NPM_REG_TOKEN}"
  - npm config set --location=user '//gitlab.com/api/v4/projects/20565764/packages/npm/:_authToken'
    "${NPM_REG_TOKEN}"
  - echo "@fireblocks:registry=https://gitlab.com/api/v4/packages/npm/">>.npmrc
  - echo "//gitlab.com/api/v4/packages/npm/:_authToken=${NPM_REG_TOKEN}">>.npmrc
  - echo "//gitlab.com/api/v4/projects/20565764/packages/npm/:_authToken=${NPM_REG_TOKEN}">>.npmrc
  - yarn global add @fireblocks/fb-cli auto-changelog
  tags:
  - build-shell
  rules:
  - if: $IS_PROD_SERVICE != "true"
    when: never
  - if: "$CI_COMMIT_TAG"
    when: never
  - if: $CI_COMMIT_BRANCH == "master" || $CI_COMMIT_BRANCH == "main"
    when: manual
    allow_failure: true
  script:
  - export VERSION=$(fb bump-version)
  - release-cli create --name "$VERSION" --description ./VERSION_CHANGELOG.md --tag-name
    "${VERSION}" --ref "$CI_COMMIT_SHA"
  extends: ".release_common"
  stage: release
  allow_failure: true
  needs: []
generate-sdk:
  stage: release
  allow_failure: true
  retry: 2
  tags:
  - shell-application-gitlab-runner
  rules:
  - if: $GENERATE_SDK == "true" && $CI_COMMIT_TAG
    when: always
  - when: never
  script:
  - yarn install --production=false --frozen-lockfile
  - yarn generate-client ${CI_COMMIT_TAG}
  - apk add jq
  - PACKAGE_NAME="@fireblocks/$(jq -r '.name' package.json)-client-rest"
  - fb notify-user $SLACK_MESSENGER_ACCESS_TOKEN $GITLAB_USER_EMAIL "$CI_PROJECT_NAME
    - new SDK version released" --copiable-code "$CI_COMMIT_TAG" --copiable-code "yarn
    add $PACKAGE_NAME@$CI_COMMIT_TAG"
generate-beta-sdk:
  stage: release
  allow_failure: true
  tags:
  - shell-application-gitlab-runner
  needs: []
  retry: 2
  rules:
  - if: "$CI_COMMIT_TAG"
    when: never
  - if: $GENERATE_SDK == "true" && $CI_PIPELINE_SOURCE != 'merge_request_event'
    when: always
    allow_failure: false
  - when: never
  script:
  - yarn install --production=false --frozen-lockfile
  - apk add jq
  - CLEANED_COMMIT_REF_NAME=$(echo "$CI_COMMIT_REF_NAME" | sed 's/[^A-Za-z0-9.-]/-/g');
  - |
    if [ $(git describe --tags --abbrev=0) ]; then
      NPM_VER="$(git describe --tags --abbrev=0)-experimental.${CLEANED_COMMIT_REF_NAME}-${CI_COMMIT_SHORT_SHA}";
    else
      NPM_VER="1.0.0-experimental.${CLEANED_COMMIT_REF_NAME}-${CI_COMMIT_SHORT_SHA}" ;
    fi
  - yarn generate-client $NPM_VER --tag beta
  - PACKAGE_NAME="@fireblocks/$(jq -r '.name' package.json)-client-rest"
  - fb notify-user $SLACK_MESSENGER_ACCESS_TOKEN $GITLAB_USER_EMAIL "$CI_PROJECT_NAME
    - new experimental SDK version released" --copiable-code "$NPM_VER" --copiable-code
    "yarn add $PACKAGE_NAME@$NPM_VER"
messaging-component-test:
  image: registry.gitlab.com/fireblocks/shell/infra/provisioning/node-18.17:latest
  stage: test
  services:
  - name: localstack/localstack
    alias: localstack
  tags:
  - shell-application-gitlab-runner
  variables:
    HUSKY: 0
  retry:
    max: 2
    when:
    - always
  allow_failure: false
  rules:
  - if: $CI_PIPELINE_SOURCE == 'merge_request_event' && $CI_MERGE_REQUEST_TITLE =~
      /^Draft:/ && $RUN_MESSAGING_LIBRARY_COMPONENT_TESTS == "true"
    changes:
      paths:
      - package.json
      - yarn.lock
    when: manual
  - if: $CI_PIPELINE_SOURCE == 'merge_request_event' && $RUN_MESSAGING_LIBRARY_COMPONENT_TESTS
      == "true"
    changes:
      paths:
      - package.json
      - yarn.lock
    when: always
  - if: $CI_COMMIT_BRANCH == "master" || $CI_COMMIT_BRANCH == "main" || $CI_COMMIT_BRANCH
      == "next" || $RUN_MESSAGING_LIBRARY_COMPONENT_TESTS == "true"
    changes:
      paths:
      - package.json
      - yarn.lock
    when: always
  - if: $CI_PIPELINE_SOURCE == 'merge_request_event' && $CI_MERGE_REQUEST_TITLE =~
      /^Draft:/ && $RUN_MESSAGING_LIBRARY_COMPONENT_TESTS == "true" && $CI_PROJECT_NAME
      == "messaging"
    when: manual
  - if: $CI_PIPELINE_SOURCE == 'merge_request_event' && $RUN_MESSAGING_LIBRARY_COMPONENT_TESTS
      == "true" && $CI_PROJECT_NAME == "messaging"
    when: always
  - if: ($CI_COMMIT_BRANCH == "master" || $CI_COMMIT_BRANCH == "main" || $CI_COMMIT_BRANCH
      == "next") && $RUN_MESSAGING_LIBRARY_COMPONENT_TESTS == "true" && $CI_PROJECT_NAME
      == "messaging"
    when: always
  - when: never
  script:
  - echo "Checking trigger source..."
  - |
    if [[ "$CI_PROJECT_NAMESPACE/$CI_PROJECT_NAME" == "fireblocks/shell/common/messaging" ]]; then
      echo "Triggered from messaging library. Running common component test logic..."
      export TRIGGERED_FROM_MESSAGING_LIB=true
    else
      echo "Triggered from a service. Validating conditions..."
      export TRIGGERED_FROM_MESSAGING_LIB=false
    fi
  - |
    if [[ "$TRIGGERED_FROM_MESSAGING_LIB" == "false" ]]; then
      if [[ "$RUN_MESSAGING_LIBRARY_COMPONENT_TESTS" != "true" ]]; then
        echo "RUN_MESSAGING_LIBRARY_COMPONENT_TESTS is not enabled. Skipping tests."
        exit 0
      fi

      echo "Checking if @fireblocks/messaging exists in yarn.lock..."
      MESSAGING_LIB_VERSION=""
      if [[ -f yarn.lock ]]; then
        if grep -q "@fireblocks/messaging" yarn.lock; then
        MESSAGING_LIB_VERSION=$(cat yarn.lock | grep -A 1 @fireblocks/messaging | grep version | awk '{print $2}' | tr -d '"')
        fi
      fi

      if [[ -z "$MESSAGING_LIB_VERSION" ]]; then
        echo "@fireblocks/messaging is not part of service dependencies. Skipping tests."
        exit 0
      fi

      if [[ $(echo "$MESSAGING_LIB_VERSION" | wc -l) -gt 1 ]]; then
        echo "Multiple versions of @fireblocks/messaging found:"
        echo "$MESSAGING_LIB_VERSION"
        LATEST_VERSION=$(echo "$MESSAGING_LIB_VERSION" | sort -V | tail -n 1)
        echo "Selecting the latest version: $LATEST_VERSION"
        export MESSAGING_LIB_VERSION=$LATEST_VERSION
      else
        export MESSAGING_LIB_VERSION=$MESSAGING_LIB_VERSION
      fi
      MIN_VERSION="5.2.4"
      if [[ "$MESSAGING_LIB_VERSION" < "$MIN_VERSION" ]]; then
        echo "Messaging library version $MESSAGING_LIB_VERSION is less than $MIN_VERSION. Skipping tests."
        exit 0
      fi

      echo "Business logic validation passed. Cloning messaging library with version $MESSAGING_LIB_VERSION"
      echo "Configuring Git"
      echo "https://argocd-ci-push:${ARGOCD_GITLAB_ACCESS_TOKEN}@gitlab.com" > ~/.git-credentials
      git remote set-url origin https://argocd-ci-push:${ARGOCD_GITLAB_ACCESS_TOKEN}@gitlab.com:fireblocks/shell/common/messaging.git
      git config --global user.email "devops@fireblocks.com"
      git config --global user.name "argocd-ci-push"
      git config --global credential.helper store
      git clone https://gitlab.com/fireblocks/shell/common/messaging.git
      cd messaging
      git fetch --tags
      git checkout "v$MESSAGING_LIB_VERSION"
      cd ../

      echo "Copying service's package.json and yarn.lock to messaging/localstack-tests..."
      cp package.json messaging/localstack-tests/service.package.json
      if [[ -f yarn.lock ]]; then
        echo "service yarn.lock file found"
        cp yarn.lock messaging/localstack-tests/yarn.lock
      else
        echo "service yarn.lock file not found"
        rm messaging/localstack-tests/yarn.lock
      fi
      echo "Merging scripts section of messaging and service package.json..."
      LOCALSTACK_SCRIPTS=$(jq '.scripts' messaging/localstack-tests/package.json)
      jq --argjson newScripts "$LOCALSTACK_SCRIPTS" '.scripts |= . + $newScripts' messaging/localstack-tests/service.package.json > messaging/localstack-tests/package.json
      rm messaging/localstack-tests/service.package.json
      echo "Entering messaging directory..."
      cd messaging
    fi
  - echo "Checkout the latest version of the messaging library README.md for documentation
    and troubleshooting -> https://gitlab.com/fireblocks/shell/common/messaging/-/blob/master/README.md?ref_type=heads"
  - yarn install --production=false --frozen-lockfile
  - yarn build
  - cp -r localstack-tests/localstack/.aws ~/.aws
  - cd localstack-tests
  - yarn install --production=false --frozen-lockfile
  - yarn test:component
  after_script:
  - echo "Component tests finished"
".component-test_global-setup":
  script:
  - podman system service -t 0 >/dev/null 2>&1 &
  - docker login -u $CI_REGISTRY_USER -p $CI_REGISTRY_PASSWORD $CI_REGISTRY
  - npm install -g @fireblocks/firemock-cli
".component-test_move-to-tests-dir":
  script:
  - export COMPONENT_TESTS_DIR="${COMPONENT_TESTS_DIR:-component}"
  - |
    if [ ! -d "$COMPONENT_TESTS_DIR" ]; then
      echo "Component Tests directory '$COMPONENT_TESTS_DIR' not found"
      exit 1
    fi
  - cd $COMPONENT_TESTS_DIR
".component-test_firemock-setup":
  script:
  - firemock up
  - firemock generate-env
  - firemock provision-resources
  - firemock connect docker-compose.yml
  - echo "Waiting for services to start, since podman doesn't wait to be healthy"
  - sleep 60
".component-test_common":
  stage: test
  image: registry.gitlab.com/fireblocks/shell/infra/images/python-infra-3.11-alpine:fb1.6
  tags:
  - builders-application-gitlab-runner
  rules:
  - if: $RUN_COMPONENT_TESTS != "true"
    when: never
  - if: "$CI_PIPELINE_SOURCE == 'merge_request_event' && $CI_MERGE_REQUEST_TITLE =~
      /^Draft:/"
    when: manual
    allow_failure: false
  - if: "$CI_PIPELINE_SOURCE == 'merge_request_event' && ($CI_MERGE_REQUEST_TITLE
      =~ /^Hotfix:/ || $CI_MERGE_REQUEST_TITLE =~ /^hotfix:/)"
    when: always
    allow_failure: true
  - if: "$CI_PIPELINE_SOURCE == 'merge_request_event'"
    when: always
    allow_failure: false
  - if: $CI_COMMIT_BRANCH == "master" || $CI_COMMIT_BRANCH == "main"
    when: always
    allow_failure: false
  - when: never
  after_script:
  - firemock export-logs || true
  - firemock down || true
  artifacts:
    when: always
    paths:
    - firemock-logs/
".component-test_node":
  stage: test
  image: registry.gitlab.com/fireblocks/shell/infra/images/python-infra-3.11-alpine:fb1.6
  tags:
  - builders-application-gitlab-runner
  rules:
  - if: $RUN_COMPONENT_TESTS != "true"
    when: never
  - if: "$CI_PIPELINE_SOURCE == 'merge_request_event' && $CI_MERGE_REQUEST_TITLE =~
      /^Draft:/"
    when: manual
    allow_failure: false
  - if: "$CI_PIPELINE_SOURCE == 'merge_request_event' && ($CI_MERGE_REQUEST_TITLE
      =~ /^Hotfix:/ || $CI_MERGE_REQUEST_TITLE =~ /^hotfix:/)"
    when: always
    allow_failure: true
  - if: "$CI_PIPELINE_SOURCE == 'merge_request_event'"
    when: always
    allow_failure: false
  - if: $CI_COMMIT_BRANCH == "master" || $CI_COMMIT_BRANCH == "main"
    when: always
    allow_failure: false
  - when: never
  after_script:
  - firemock export-logs || true
  - firemock down || true
  artifacts:
    when: always
    paths:
    - firemock-logs/
  extends: ".component-test_common"
  script:
  - - podman system service -t 0 >/dev/null 2>&1 &
    - docker login -u $CI_REGISTRY_USER -p $CI_REGISTRY_PASSWORD $CI_REGISTRY
    - npm install -g @fireblocks/firemock-cli
  - yarn install --production=false --frozen-lockfile
  - - export COMPONENT_TESTS_DIR="${COMPONENT_TESTS_DIR:-component}"
    - |
      if [ ! -d "$COMPONENT_TESTS_DIR" ]; then
        echo "Component Tests directory '$COMPONENT_TESTS_DIR' not found"
        exit 1
      fi
    - cd $COMPONENT_TESTS_DIR
  - yarn install --production=false --frozen-lockfile
  - - firemock up
    - firemock generate-env
    - firemock provision-resources
    - firemock connect docker-compose.yml
    - echo "Waiting for services to start, since podman doesn't wait to be healthy"
    - sleep 60
  - yarn test:component
".component-test_python":
  stage: test
  image: registry.gitlab.com/fireblocks/shell/infra/images/python-infra-3.11-alpine:fb1.6
  tags:
  - builders-application-gitlab-runner
  rules:
  - if: $RUN_COMPONENT_TESTS != "true"
    when: never
  - if: "$CI_PIPELINE_SOURCE == 'merge_request_event' && $CI_MERGE_REQUEST_TITLE =~
      /^Draft:/"
    when: manual
    allow_failure: false
  - if: "$CI_PIPELINE_SOURCE == 'merge_request_event' && ($CI_MERGE_REQUEST_TITLE
      =~ /^Hotfix:/ || $CI_MERGE_REQUEST_TITLE =~ /^hotfix:/)"
    when: always
    allow_failure: true
  - if: "$CI_PIPELINE_SOURCE == 'merge_request_event'"
    when: always
    allow_failure: false
  - if: $CI_COMMIT_BRANCH == "master" || $CI_COMMIT_BRANCH == "main"
    when: always
    allow_failure: false
  - when: never
  after_script:
  - firemock export-logs || true
  - firemock down || true
  artifacts:
    when: always
    paths:
    - firemock-logs/
  extends: ".component-test_common"
  script:
  - - podman system service -t 0 >/dev/null 2>&1 &
    - docker login -u $CI_REGISTRY_USER -p $CI_REGISTRY_PASSWORD $CI_REGISTRY
    - npm install -g @fireblocks/firemock-cli
  - poetry install --no-interaction --no-ansi
  - - export COMPONENT_TESTS_DIR="${COMPONENT_TESTS_DIR:-component}"
    - |
      if [ ! -d "$COMPONENT_TESTS_DIR" ]; then
        echo "Component Tests directory '$COMPONENT_TESTS_DIR' not found"
        exit 1
      fi
    - cd $COMPONENT_TESTS_DIR
  - poetry install --no-interaction --no-ansi
  - - firemock up
    - firemock generate-env
    - firemock provision-resources
    - firemock connect docker-compose.yml
    - echo "Waiting for services to start, since podman doesn't wait to be healthy"
    - sleep 60
  - poetry run pytest --verbose -s
".generate-mock-catalog":
  stage: release
  image: registry.gitlab.com/fireblocks/shell/infra/images/node-infra-20:latest
  tags:
  - build-shell
  variables:
    GITLAB_TOKEN: "$NPM_REG_TOKEN"
  needs: []
  allow_failure: true
  rules:
  - if: "$CI_PIPELINE_SOURCE == 'merge_request_event'"
    when: never
  - if: "$CI_COMMIT_TAG"
    when: never
  - if: $GENERATE_MOCK_CATALOG == "true"
    when: always
  - when: never
  script:
  - export COMPONENT_TESTS_DIR="${COMPONENT_TESTS_DIR:-component}"
  - export MOCK_CATALOG_DIR="${COMPONENT_TESTS_DIR}/mock-catalog"
  - echo "Checking if ${MOCK_CATALOG_DIR} directory exists..."
  - |
    if [ ! -d "$MOCK_CATALOG_DIR" ]; then \
      echo "Directory does not exist. Skipping..."; \
      exit 0; \
    fi
  - export PUBLISH_BETA=
  - echo "Directory exists. Proceeding..."
  - export BETA_FLAG=""
  - if [[ "$CI_COMMIT_BRANCH" != "master" && "$CI_COMMIT_BRANCH" != "main" ]]; then
    export BETA_FLAG="--beta"; fi
  - npx --package @fireblocks/mock-generator publish-catalog $BETA_FLAG
component-test:
  stage: test
  image: registry.gitlab.com/fireblocks/shell/infra/images/python-infra-3.11-alpine:fb1.6
  tags:
  - builders-application-gitlab-runner
  rules:
  - if: $RUN_COMPONENT_TESTS != "true"
    when: never
  - if: "$CI_PIPELINE_SOURCE == 'merge_request_event' && $CI_MERGE_REQUEST_TITLE =~
      /^Draft:/"
    when: manual
    allow_failure: false
  - if: "$CI_PIPELINE_SOURCE == 'merge_request_event' && ($CI_MERGE_REQUEST_TITLE
      =~ /^Hotfix:/ || $CI_MERGE_REQUEST_TITLE =~ /^hotfix:/)"
    when: always
    allow_failure: true
  - if: "$CI_PIPELINE_SOURCE == 'merge_request_event'"
    when: always
    allow_failure: false
  - if: $CI_COMMIT_BRANCH == "master" || $CI_COMMIT_BRANCH == "main"
    when: always
    allow_failure: false
  - when: never
  after_script:
  - firemock export-logs || true
  - firemock down || true
  artifacts:
    when: always
    paths:
    - firemock-logs/
  extends: ".component-test_node"
  script:
  - - podman system service -t 0 >/dev/null 2>&1 &
    - docker login -u $CI_REGISTRY_USER -p $CI_REGISTRY_PASSWORD $CI_REGISTRY
    - npm install -g @fireblocks/firemock-cli
  - yarn install --production=false --frozen-lockfile
  - - export COMPONENT_TESTS_DIR="${COMPONENT_TESTS_DIR:-component}"
    - |
      if [ ! -d "$COMPONENT_TESTS_DIR" ]; then
        echo "Component Tests directory '$COMPONENT_TESTS_DIR' not found"
        exit 1
      fi
    - cd $COMPONENT_TESTS_DIR
  - yarn install --production=false --frozen-lockfile
  - - firemock up
    - firemock generate-env
    - firemock provision-resources
    - firemock connect docker-compose.yml
    - echo "Waiting for services to start, since podman doesn't wait to be healthy"
    - sleep 60
  - yarn test:component
generate-mock-catalog:
  stage: release
  image: registry.gitlab.com/fireblocks/shell/infra/images/node-infra-20:latest
  tags:
  - build-shell
  variables:
    GITLAB_TOKEN: "$NPM_REG_TOKEN"
  needs: []
  allow_failure: true
  rules:
  - if: "$CI_PIPELINE_SOURCE == 'merge_request_event'"
    when: never
  - if: "$CI_COMMIT_TAG"
    when: never
  - if: $GENERATE_MOCK_CATALOG == "true"
    when: always
  - when: never
  script:
  - export COMPONENT_TESTS_DIR="${COMPONENT_TESTS_DIR:-component}"
  - export MOCK_CATALOG_DIR="${COMPONENT_TESTS_DIR}/mock-catalog"
  - echo "Checking if ${MOCK_CATALOG_DIR} directory exists..."
  - |
    if [ ! -d "$MOCK_CATALOG_DIR" ]; then \
      echo "Directory does not exist. Skipping..."; \
      exit 0; \
    fi
  - export PUBLISH_BETA=
  - echo "Directory exists. Proceeding..."
  - export BETA_FLAG=""
  - if [[ "$CI_COMMIT_BRANCH" != "master" && "$CI_COMMIT_BRANCH" != "main" ]]; then
    export BETA_FLAG="--beta"; fi
  - npx --package @fireblocks/mock-generator publish-catalog $BETA_FLAG
  extends: ".generate-mock-catalog"
image: registry.gitlab.com/fireblocks/shell/infra/images/node-infra-20:latest
stages:
- ".pre"
- test
- lint
- build
- image-scan
- env-status-check
- deploy
- canary
- deploy-prod
- deploy-prod-in-place
- manual-override
- release
- ".post"
workflow:
  rules:
  - if: "$GENERATE_SDK && $CI_COMMIT_TAG"
    when: always
  - if: "$CI_COMMIT_TAG"
    when: never
  - when: always
before_script:
- touch .npmrc
- npm config set --location=user @fireblocks:registry https://gitlab.com/api/v4/packages/npm/
- npm config set --location=user "//gitlab.com/api/v4/packages/npm/:_authToken" "${NPM_REG_TOKEN}"
- npm config set --location=user "//gitlab.com/api/v4/projects/${SHELL_LIBS_PROJECT_ID}/packages/npm/:_authToken"
  "${NPM_REG_TOKEN}"
- echo "@fireblocks:registry=https://gitlab.com/api/v4/packages/npm/">>.npmrc
- echo "//gitlab.com/api/v4/packages/npm/:_authToken=${NPM_REG_TOKEN}">>.npmrc
- echo "//gitlab.com/api/v4/projects/${SHELL_LIBS_PROJECT_ID}/packages/npm/:_authToken=${NPM_REG_TOKEN}">>.npmrc
- echo "started installing global dependencies $(date +"%T")"
- echo "Install yq & jq from .gitlab-ci.yml"
- apk update
- apk add jq
- apk add yq
- yarn global add @fireblocks/fb-cli auto-changelog dot-json
- fb verify-ci-project-path "${CI_PROJECT_PATH}" "service"
- "(fb get-service-metadata ${SERVICE_NAME} false > $CI_PROJECT_DIR/service-metadata.json)
  || /bin/true"
- |
  if [ -f "$CI_PROJECT_DIR/service-metadata.json" ]; then
    echo "Service: {$SERVICE_NAME} exists in component registry"
    OWNER_GROUP=$(jq -r '.owner.parent.name' service-metadata.json)
    OWNER_TEAM=$(jq -r '.owner.name' service-metadata.json)
    SERVICE_SCOPE=$(jq -r '.scope' service-metadata.json)
    npx @datadog/datadog-ci tag --no-fail --level pipeline --tags "owner.group:${OWNER_GROUP}"  || /bin/true
    npx @datadog/datadog-ci tag --no-fail --level pipeline --tags "owner.team:${OWNER_TEAM}" || /bin/true
  else
      echo "Service: {$SERVICE_NAME} does not exist in component registry, skipping any service metadata processing"
  fi
- echo "finished installing global dependencies $(date +"%T")"
deploy_to_lightsail:
  stage: seethelight
  image: amazon/aws-cli:latest
  before_script:
  - aws sts get-caller-identity
  - chmod +x deployment/scripts/deploy.sh
  script:
  - echo "Deploying $EW_IMAGE_TAG to $ENVIRONMENT"
  - ./deployment/scripts/deploy.sh --environment "$ENVIRONMENT" --image "$EW_IMAGE_TAG"
  rules:
  - when: manual
